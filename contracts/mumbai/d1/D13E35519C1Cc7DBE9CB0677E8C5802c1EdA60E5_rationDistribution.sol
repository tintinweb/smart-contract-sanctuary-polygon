// SPDX-License-Identifier: MIT

import "./item.sol";
import "./citizen.sol";
import "./rationShop.sol";
import "./dateTime.sol";
import "./AutomationCompatible.sol";

pragma solidity ^0.8.7;

contract rationDistribution is item,citizen,rationShop,dateTime, AutomationCompatible{
    
    struct rationDistributionToPublic{
        uint rationCardNo;
        uint rationShopNo;
        string purchasedItem;
        uint deliveryTime;
        uint price;
        uint receiptNo;
    }
    
    mapping(uint => mapping(string => uint))public goods;
    rationDistributionToPublic[] public rationDelivery;
    event StoreItemToRationShop(uint indexed rationShopId,string itemName,uint weight);
    event RationDelivery(uint indexed rationCardNo,uint indexed ReceiptNo);
    event ResetRationDetails(address indexed RationResetcaller, uint indexed timeOfReset);

    uint public lastTimeStamp;
    uint immutable interval;

    constructor() {
        interval = 24*60*60*27;
    }

     function checkUpkeep(bytes calldata /* checkData */)external view override returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        uint Todaydate=getDay(block.timestamp);
        upkeepNeeded = Todaydate == 9 && (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        uint Todaydate=getDay(block.timestamp);
        if (Todaydate == 9 && (block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            deleteRationDetails();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }


    function addItemToRationShop(uint _rationShopNo, string[] calldata _itemName,uint[] calldata _weight) public onlyOwner{
        uint len = _weight.length;
        require(_itemName.length == len,"No of item name is not equal to no of Weight");
        for(uint i; i<len ; i++){
            goods[_rationShopNo][_itemName[i]] += _weight[i];
            emit StoreItemToRationShop(_rationShopNo,_itemName[i],_weight[i]);
        }
    }
    function deleteRationDetails() public{
	    uint Todaydate;	    
	    Todaydate=getDay(block.timestamp);
        require(Todaydate==9 && (block.timestamp - lastTimeStamp) > interval,"Today is not the ninth Day of the Month");
        lastTimeStamp = block.timestamp;
        delete rationDelivery;
        emit ResetRationDetails(msg.sender, block.timestamp);
	} 

    function rationDeliveryToCitizen(uint _rationCardNo,uint _rationShopNo,string calldata _itemName,bytes memory _signature)public {
        (,address _rationCardOwner, uint _financialStatus) = citizenInformation(_rationCardNo);
        (, address rationWallet) = shopInformation(_rationShopNo);
        //registerItem memory buying = items[_itemName];
        uint Todaydate=getDay(block.timestamp);
	    require(Todaydate!=9,"Today Ration will not be provided... Kindly Visit Tomorrow to eight day of the Month For Ration");
        require(_rationCardOwner != address(0),"this Ration Card No doesnot exist");        
        require(rationWallet != address(0),"this Ration Card No doesnot exist");
        (bool _status) = verifyPurchase(_rationCardOwner, _rationCardNo,_rationShopNo,_itemName,_signature);
        require(_status == true,"signature doesnot match");
        uint availableGoods = goods[_rationShopNo][_itemName];
        uint _weight = items[_itemName].weight;
        require(availableGoods >= _weight,"Purchased Item not available in this Ration Shop");
        uint len = rationDelivery.length;      
        for(uint i; i<len; i++){
            if(rationDelivery[i].rationCardNo == _rationCardNo){
                require(uint(keccak256(abi.encodePacked(rationDelivery[i].purchasedItem))) != uint(keccak256(abi.encodePacked(_itemName))),"Already purchased Item");
            }  
        }
        if(_financialStatus == 0){            
            rationDelivery.push(rationDistributionToPublic(_rationCardNo, _rationShopNo,_itemName,block.timestamp,items[_itemName].bplPrice * _weight,len));
        }
        else{
            rationDelivery.push(rationDistributionToPublic(_rationCardNo, _rationShopNo,_itemName,block.timestamp,items[_itemName].aplPrice * _weight,len));
        }
        goods[_rationCardNo][_itemName] -= _weight;
        emit RationDelivery(_rationCardNo,len);
    }
    
}