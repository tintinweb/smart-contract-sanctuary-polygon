// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

interface IAccessControlledAndUpgradeable {
  function ADMIN_ROLE() external returns (bytes32);

  function MINOR_ADMIN_ROLE() external returns (bytes32);

  function EMERGENCY_ROLE() external returns (bytes32);

  function UPGRADER_ROLE() external returns (bytes32);
}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

interface IGEMS {
  function initialize() external;

  function gm(address) external;

  function GEM_ROLE() external returns (bytes32);

  function balanceOf(address) external returns (uint256);
}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

import "./IMarketExtended.sol";
import "./IOracleManager.sol";

import "./IAccessControlledAndUpgradeable.sol";

/// @title Interface for the main functions of the market
/// @author float
interface IMarketCore is IAccessControlledAndUpgradeable {
  /*╔═════════════════════════╗
    ║          ERRORS         ║
    ╚═════════════════════════╝*/

  /// @notice Thrown when there is an error pausing the mint action
  error MintingPaused();

  /// @notice Thrown when minting to a pool that doesn't exist
  error InvalidPool();

  /// @notice Thrown when there is an error deprecating the  market
  error MarketDeprecated();

  /// @notice Thrown when an amount of tokens to take action on is outside of the operational range
  error InvalidActionAmount(uint112 amount);

  /// @notice Thrown when an action is taken on a market that is behind on system updates
  error MarketStale(uint32 currentEpoch, uint32 latestExecutedEpoch);

  /*╔═════════════════════════╗
    ║          EVENTS         ║
    ╚═════════════════════════╝*/

  /// @notice Emitted every time a mint action is successfully accepted
  event Deposit(uint8 indexed poolId, uint112 depositAdded, uint256 fee, address indexed user, uint32 indexed epoch);

  /// @notice Emitted each time a redeem action is successfully accepted
  event Redeem(uint8 indexed poolId, uint112 poolTokenRedeemed, address indexed user, uint32 indexed epoch);

  /// @notice Emitted when a user's mint/deposit order is successfully executed
  event ExecuteEpochSettlementMintUser(uint8 indexed poolId, address indexed user, uint32 indexed epochSettledUntil, uint256 amountPoolTokenMinted);

  /// @notice Emitted when a user's redeem order is successfully executed
  event ExecuteEpochSettlementRedeemUser(
    uint8 indexed poolId,
    address indexed user,
    uint32 indexed epochSettledUntil,
    uint256 amountPaymentTokenRecieved
  );

  /// @notice All variables needed for a pool to be well defined
  struct PoolState {
    uint8 poolId;
    uint256 tokenPrice;
    int256 value;
  }

  /// @notice Emitted when an epoch has successfully updated
  event EpochUpdated(uint32 indexed epoch, int256 underlyingAssetPrice, int256 valueChange, int256[2] fundingAmount, PoolState[] poolStates);

  /// @notice Emitted when the market has been deprecated
  event MarketDeprecation();

  /*╔═════════════════════════════╗
    ║        EXTERNAL CALLS       ║
    ╚═════════════════════════════╝*/

  /// @notice System state update function that verifies (instead of trying to find) oracle prices
  /// @param oracleRoundIdsToExecute The oracle prices that will be the prices for each epoch
  function updateSystemStateUsingValidatedOracleRoundIds(uint80[] memory oracleRoundIdsToExecute) external;

  /// @notice Allows mint long pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param poolTier leveraged poolTier index
  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.
  /// @param user Address of the user.
  function mintLongFor(
    uint256 poolTier,
    uint112 amount,
    address user
  ) external;

  /// @notice Allows mint short pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param poolTier leveraged poolTier index
  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.
  /// @param user Address of the user.
  function mintShortFor(
    uint256 poolTier,
    uint112 amount,
    address user
  ) external;

  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param poolTier leveraged poolTier index
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.
  function redeemLong(uint256 poolTier, uint112 amount) external;

  /// @notice Allows users to redeem short pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param poolTier leveraged poolTier index
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.
  function redeemShort(uint256 poolTier, uint112 amount) external;

  /// @notice Allows users to redeem float pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.
  function redeemFloatPool(uint112 amount) external;

  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param poolTier leveraged poolTier index
  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.
  function mintLong(uint256 poolTier, uint112 amount) external;

  /// @notice Allows users to mint short pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param poolTier leveraged poolTier index
  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.
  function mintShort(uint256 poolTier, uint112 amount) external;

  /// @notice Allows users to mint float pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.
  function mintFloatPool(uint112 amount) external;

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their mints during that epoch to that user.
  /// @param user Address of the user.
  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier leveraged poolTier index
  function settlePoolUserMints(
    address user,
    IMarketCommon.PoolType poolType,
    uint256 poolTier
  ) external;

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their redeems during that epoch to that user.
  /// @param user Address of the user.
  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier leveraged poolTier index
  function settlePoolUserRedeems(
    address user,
    IMarketCommon.PoolType poolType,
    uint256 poolTier
  ) external;

  /// @notice Place the market in a state where no more price updates or mints are allowed
  function deprecateMarket() external;

  /// @notice Allows users to exit the market after it has been deprecated
  /// @param user Users address to remove from the market
  function exitDeprecatedMarket(address user) external;
}

interface IMarketView {
  /*╔════════════════════════════╗
    ║          GETTERS           ║
    ╚════════════════════════════╝*/

  /// @notice Getter function for the state variable numberOfPoolsOfType
  /// @param poolType The type of pool (e.g. long, short)
  /// @return The address of the numberOfPoolsOfType for this market
  function numberOfPoolsOfType(IMarketCommon.PoolType poolType) external view returns (uint256);

  /// @notice Returns the interface of OracleManager for the market
  /// @return oracleManager OracleManager interface
  function get_oracleManager() external view returns (IOracleManager);

  /// @notice Returns all information about a particular pool
  /// @param poolType An enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return Struct containing information about the pool i.e. value, leverage etc.
  function get_pool(IMarketCommon.PoolType poolType, uint256 poolTier) external view returns (IMarketCommon.Pool memory);

  /// @notice Returns the pool liquidity given poolType and poolTier.
  /// @param poolType An enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return Liquidity of the pool
  function get_pool_value(IMarketCommon.PoolType poolType, uint256 poolTier) external view returns (uint256);

  /// @notice Returns the pool token address given poolType and poolTier.
  /// @param poolType An enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return Address of the pool token
  function get_pool_token(IMarketCommon.PoolType poolType, uint256 poolTier) external view returns (address);

  /// @notice Returns the pool leverage given poolType and poolTier.
  /// @param poolType An enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return Leverage of the pool
  function get_pool_leverage(IMarketCommon.PoolType poolType, uint256 poolTier) external view returns (int96);

  /// @notice Returns the address of the YieldManager for the market
  /// @return liquidityManager address of the YieldManager
  function get_liquidityManager() external view returns (address);

  /// @notice Returns the deposit action in payment tokens of provided user for the given poolType and poolTier.
  /// @dev Action amounts have a fixed 18 decimals.
  /// @param user Address of the user.
  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return userAction_depositPaymentToken Outstanding deposit action by user for the given poolType and poolTier.
  function get_userAction_depositPaymentToken(
    address user,
    IMarketCommon.PoolType poolType,
    uint256 poolTier
  ) external view returns (IMarketCommon.UserAction memory);

  /// @notice Returns the redeem action in pool tokens of provided user for the given poolType and poolTier.
  /// @dev Action amounts have a fixed 18 decimals.
  /// @param user Address of the user.
  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return userAction_redeemPoolToken Outstanding redeem action by user for the given poolType and poolTier.
  function get_userAction_redeemPoolToken(
    address user,
    IMarketCommon.PoolType poolType,
    uint256 poolTier
  ) external view returns (IMarketCommon.UserAction memory);

  /// @notice Returns the price of the pool token given poolType and poolTier.
  /// @dev Prices have a fixed 18 decimals.
  /// @param epoch Number of epoch that has been executed.
  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return poolToken_priceSnapshot Price of the pool tokens in the pool.
  function get_poolToken_priceSnapshot(
    uint32 epoch,
    IMarketCommon.PoolType poolType,
    uint256 poolTier
  ) external view returns (uint256);

  /// @notice Returns the epochInfo struct.
  /// @return epochInfo Struct containing info about the latest executed epoch and previous epoch.
  function get_epochInfo() external view returns (IMarketCommon.EpochInfo memory);

  /// @notice Returns the balance of user actions in epochs which have been executed but not yet distributed to users.
  /// @dev Prices have a fixed 18 decimals.
  /// @param user Address of user.
  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.
  /// @param poolTier The index of the pool in the side.
  /// @return confirmedButNotSettledBalance Returns balance of user actions in epochs which have been executed but not yet distributed to users.
  function getUsersConfirmedButNotSettledPoolTokenBalance(
    address user,
    IMarketCommon.PoolType poolType,
    uint8 poolTier
  ) external view returns (uint256 confirmedButNotSettledBalance);

  /// @notice Getter function for the state variable paymentToken
  /// @return The address of the paymentToken for this market
  function get_paymentToken() external view returns (address);

  /// @notice Getter function for the FLOAT_POOL_ROLE
  /// @return The role code for the float pool
  function get_FLOAT_POOL_ROLE() external view returns (bytes32);
}

/// @title Combined interface of core view and mutate functions
/// @author float
interface IMarketTieredLeverage is IMarketCore, IMarketView {

}

/// @title Combined interface of core and non-core functions
/// @author float
interface IMarket is IMarketTieredLeverage, IMarketExtended {

}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

/// @title Interface of shared variable types
/// @author float
/// @notice Top-level interface for the market contract tree
interface IMarketCommon {
  /// @notice Thrown when an unsupported address in used (e.g. 0 address)
  error InvalidAddress(address invalidAddress);

  /// @notice Info on the current epoch state
  struct EpochInfo {
    uint32 latestExecutedEpochIndex;
    // Reference to Chainlink Index
    uint80 latestExecutedOracleRoundId;
    // This should be large enough for all price data.
    uint144 lastEpochPrice;
  }

  /// @notice Each market has 3 different types of pools
  enum PoolType {
    SHORT,
    LONG,
    FLOAT,
    LAST // useful for getting last element of enum, commonly used in cpp/c also eg: https://stackoverflow.com/a/2102615
  }

  /// @notice Collection of all user actions (deposit is for mints)
  struct BatchedActions {
    uint256 paymentToken_deposit;
    uint256 poolToken_redeem;
  }

  /// @notice Static values that each pool needs to have
  struct PoolFixedConfig {
    address token;
    int96 leverage;
  }

  /// @notice Total values that define each pool
  struct Pool {
    uint256 value;
    // first element is for even epochs and second element for odd epochs
    BatchedActions[2] batchedAmount;
    PoolFixedConfig fixedConfig;
  }

  /// @notice Total values that define each action per user
  struct UserAction {
    uint32 correspondingEpoch;
    uint112 amount;
    uint112 nextEpochAmount;
  }

  /// @notice Ephemeral values used when updating the system state each epoch
  struct ValueChangeAndFunding {
    int256 valueChange;
    int256[2] fundingAmount;
    uint256 underBalancedSide;
  }
}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

import "./IMarketCommon.sol";
import "./IOracleManager.sol";
import "./IRegistry.sol";

/// @title Interface for the mutating admin functions of the market
/// @author float
/// @notice Events & functions that are to be callable only by the admin account.
interface IMarketExtendedCore is IMarketCommon {
  /// @notice Parameters of a new pool
  struct SinglePoolInitInfo {
    string name;
    string symbol;
    PoolType poolType;
    uint8 poolTier;
    address token;
    uint96 leverage;
  }

  /// @notice Params for initializing the contract
  /// @dev Without this struct we get stack to deep errors. Grouping the data helps!
  struct InitializePoolsParams {
    SinglePoolInitInfo[] initPools;
    uint256 initialLiquidityToSeedEachPool;
    address seederAndAdmin;
    uint32 _marketIndex;
    address oracleManager;
    address liquidityManager;
  }

  /// @notice Parameters when oracle manager address is updated
  /// @dev Can only be called by the current admin.
  struct OracleUpdate {
    IOracleManager prevOracle;
    IOracleManager newOracle;
  }

  /// @notice Parameters when funding rate is updated
  /// @dev Can only be called by the current admin.
  struct FundingRateUpdate {
    uint128 prevMultiplier;
    uint128 newMultiplier;
    uint128 prevMinFloatPoolFundingBoost;
    uint128 newMinFloatPoolFundingBoost;
  }

  /// @notice Parameters when funding rate is updated
  /// @dev Can only be called by the current admin.
  struct StabilityFeeUpdate {
    uint256 prevStabilityFee;
    uint256 newStabilityFee;
  }

  /// @notice Used in event
  enum ConfigType {
    marketOracleUpdate,
    fundingVariables,
    stabilityFee
  }

  /// @notice Emitted when core system parameters are changed by admin
  event ConfigChange(ConfigType indexed configChangeType, bytes data);

  /// @notice Emitted when minting is paused/unpaused by admin
  event MintingPauseChange(bool isPaused);

  /// @notice Emitted when market contract is initialized
  event SeparateMarketLaunchedAndSeeded(
    uint32 marketIndex,
    address admin,
    address oracleManager,
    address liquidityManager,
    address paymentToken,
    int256 initialAssetPrice
  );

  /// @notice Emitted when a new pool has been added to an existing market
  event TierAdded(SinglePoolInitInfo newTier, uint256 initialSeed);

  /// @notice Initialize pools in the market
  /// @dev Can only be called by registry contract
  /// @param params struct containing addresses of dependency contracts and other market initialization parameters
  /// @return initializationSuccess bool value indicating whether initialization was successful.
  function initializePools(InitializePoolsParams memory params) external returns (bool);

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param oracleConfig Address of the replacement oracle manager.
  function updateMarketOracle(OracleUpdate memory oracleConfig) external;

  /// @notice Stop allowing mints on the market
  /// @dev Can only be called by the current admin.
  function pauseMinting() external;

  /// @notice Resume allowing mints on the market
  /// @dev Can only be called by the current admin.
  function unpauseMinting() external;

  /// @notice Update the yearly funding rate multiplier for the market
  /// @dev Can only be called by the current admin.
  /// @param fundingRateConfig New funding rate multiplier
  function changeMarketFundingRateMultiplier(FundingRateUpdate memory fundingRateConfig) external;

  /// @notice Update the yearly funding rate multiplier for the market
  /// @dev Can only be called by the current admin.
  /// @param stabilityFeeConfig New funding rate multiplier
  function changeStabilityFeeBasisPoints(StabilityFeeUpdate memory stabilityFeeConfig) external;
}

/// @title Interface of read only functions for a market
/// @author float
interface IMarketExtendedView is IMarketCommon {
  /// @notice Whether the minting action is paused or not
  function get_mintingPaused() external view returns (bool);

  /// @notice Whether the market is deprecated or not
  function get_marketDeprecated() external view returns (bool);

  /// @notice Purely a convenience function to get the seeder address. Used in testing.
  function getSeederAddress() external view returns (address);

  /// @notice Purely a convenience function to get the pool token address. Used in testing.
  function getPoolTokenAddress(IMarketCommon.PoolType poolType, uint256 index) external view returns (address);

  /// @notice The largest acceptable percentage that the underlying asset can move in 1 epoch
  function get_maxPercentChange() external view returns (int256);

  /// @notice Admin-adjustable value that determines the magnitude of funding amount each epoch
  function get_fundingRateMultiplier() external view returns (uint128);

  /// @notice Admin-adjustable value that determines the minimum magnitude of funding amount each epoch
  function get_minFloatPoolFundingBoost() external view returns (uint128);

  /// @notice Admin-adjustable value that determines the mint fee
  function get_stabilityFee_basisPoints() external view returns (uint256);

  /// @notice Returns batched deposit amount in payment token for even numbered epochs.
  /// @param poolType indicates either Long or Short pool type
  /// @param pool index of the pool on the market side
  function get_even_batchedAmountPaymentToken_deposit(IMarketCommon.PoolType poolType, uint256 pool) external view returns (uint256);

  /// @notice Returns batched deposit amount in payment token for odd numbered epochs.
  /// @param poolType indicates either Long or Short pool type
  /// @param pool index of the pool on the market side
  function get_odd_batchedAmountPaymentToken_deposit(IMarketCommon.PoolType poolType, uint256 pool) external view returns (uint256);

  /// @notice Returns batched redeem amount in pool token for even numbered epochs.
  /// @param poolType indicates either Long or Short pool type
  /// @param pool index of the pool on the market side
  function get_even_batchedAmountPoolToken_redeem(IMarketCommon.PoolType poolType, uint256 pool) external view returns (uint256);

  /// @notice Returns batched redeem amount in pool token for odd numbered epochs.
  /// @param poolType indicates either Long or Short pool type
  /// @param pool index of the pool on the market side
  function get_odd_batchedAmountPoolToken_redeem(IMarketCommon.PoolType poolType, uint256 pool) external view returns (uint256);

  /// @notice The effective liquidity (actual liquidity * leverage) for all the pools of a specific type
  /// @return The contract stored value for effective liquidity
  function get_effectiveLiquidityForPoolType() external view returns (uint256[2] memory);

  /// @notice View function for the gems state variable
  /// @return address of the gems contract
  function get_gems() external view returns (address);

  /// @notice View function for the registry state variable
  /// @return address of the registry contract
  function get_registry() external view returns (IRegistry);
}

/// @title Combined interface for the admin functions and view functions
/// @author float
interface IMarketExtended is IMarketExtendedCore, IMarketExtendedView {

}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

import "../interfaces/chainlink/AggregatorV3Interface.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/// @title Interface for the Chainlink oracle manager
/// @notice Manages price feeds from Chainlink oracles.
/// @author float
/*
 * Manages price feeds from different oracle implementations.
 */
interface IOracleManager {
  error EmptyArrayOfIndexes();

  error InvalidOracleExecutionRoundId(uint80 oracleRoundId);

  error InvalidOraclePrice(int256 oraclePrice);

  /// @notice Getter function for the state variable chainlinkOracle
  /// @return AggregatorV3Interface for the Chainlink oracle address
  function chainlinkOracle() external view returns (AggregatorV3Interface);

  /// @notice Getter function for the state variable initialEpochStartTimestamp
  /// @return Timestamp of the start of the first ever epoch for the market
  function initialEpochStartTimestamp() external view returns (uint256);

  /// @notice Getter function for the state variable EPOCH_LENGTH
  /// @return Length of the epoch for this market, in seconds
  function EPOCH_LENGTH() external view returns (uint256);

  /// @notice Getter function for the state variable MINIMUM_EXECUTION_WAIT_THRESHOLD
  /// @return Least amount of time needed to wait after epoch end time for the next valid price
  function MINIMUM_EXECUTION_WAIT_THRESHOLD() external view returns (uint256);

  /// @notice Returns index of the current epoch based on block.timestamp
  /// @dev Called by internal functions to get current epoch index
  /// @return getCurrentEpochIndex the current epoch index
  function getCurrentEpochIndex() external view returns (uint256);

  /// @notice Returns start timestamp of current epoch
  /// @return getEpochStartTimestamp start timestamp of the current epoch
  function getEpochStartTimestamp() external view returns (uint256);

  /// @notice Check that the given array of oracle prices are valid for the epochs that need executing
  /// @param _latestExecutedEpochIndex The index of the epoch that was last executed
  /// @param oracleRoundIdsToExecute Array of roundIds to be validated
  /// @return prices Array of prices to be used for epoch execution
  function validateAndReturnMissedEpochInformation(uint32 _latestExecutedEpochIndex, uint80[] memory oracleRoundIdsToExecute)
    external
    view
    returns (int256[] memory prices);
}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

/// @title Registry interface
/// @author float
/// @notice High-level information about all Float markets
interface IRegistry {
  /// @notice Emitted when the registry contract is initialized
  event RegistryArctic(address admin);

  /// @notice Emitted when a new market is successfully launched
  event SeparateMarketCreated(string name, string symbol, address market, uint32 marketIndex);

  /// @notice Getter function for the separateMarketContracts state variable
  /// @param marketIndex Launch ordinal of the market
  /// @return The address of the market contract
  function separateMarketContracts(uint32 marketIndex) external view returns (address);

  /// @notice Getter function for the latestMarket state variable
  /// @return The index of the latest market added to the registry
  function latestMarket() external view returns (uint32);

  /// @notice Getter function for the gems state variable
  /// @return The address of the gems contract
  function gems() external view returns (address);
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  // getRoundData and latestRoundData should both raise "No data present"
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}

interface AggregatorV3InterfaceS {
  struct LatestRoundData {
    uint80 roundId;
    int256 answer;
    uint256 startedAt;
    uint256 updatedAt;
    uint80 answeredInRound;
  }

  function latestRoundData() external view returns (LatestRoundData memory);

  function getRoundData(uint80 data) external view returns (LatestRoundData memory);
}

// Depolyed on polygon at: https://polygonscan.com/address/0xcb3a66ed5f43eb3676826597fa49b47ba9d8df81#readContract
contract MultiPriceGetter {
  function searchForEarliestIndex(AggregatorV3InterfaceS oracle, uint80 earliestKnownOracleIndex)
    public
    view
    returns (uint80 earliestOracleIndex, uint256 numberOfOracleUpdatesScanned)
  {
    AggregatorV3InterfaceS.LatestRoundData memory correctResult = oracle.getRoundData(earliestKnownOracleIndex);

    // Can see if searching 1,000,000 entries is fine or too much for the node
    for (; numberOfOracleUpdatesScanned < 1_000_000; ++numberOfOracleUpdatesScanned) {
      AggregatorV3InterfaceS.LatestRoundData memory currentResult = oracle.getRoundData(--earliestKnownOracleIndex);

      // Check if there was a 'phase change' AND the `_currentOracleUpdateTimestamp` is zero.
      if ((correctResult.roundId >> 64) != (earliestKnownOracleIndex >> 64) && correctResult.answer == 0) {
        // Check 5 phase changes at maximum.
        for (int256 phaseChangeChecker = 0; phaseChangeChecker < 5 && correctResult.answer == 0; ++phaseChangeChecker) {
          // startId = (((startId >> 64) + 1) << 64) | uint80(uint64(startId));
          earliestKnownOracleIndex -= (1 << 64); // ie add 2^64

          currentResult = oracle.getRoundData(earliestKnownOracleIndex);
        }
      }

      if (correctResult.answer == 0) {
        break;
      }

      correctResult = currentResult;
    }

    earliestOracleIndex = correctResult.roundId;
  }

  function getRoundDataMulti(
    AggregatorV3InterfaceS oracle,
    uint80 startId,
    uint256 numberToFetch
  ) public view returns (AggregatorV3InterfaceS.LatestRoundData[] memory result) {
    result = new AggregatorV3InterfaceS.LatestRoundData[](numberToFetch);
    AggregatorV3InterfaceS.LatestRoundData memory latestRoundData = oracle.latestRoundData();

    for (uint256 i = 0; i < numberToFetch && startId <= latestRoundData.roundId; ++i) {
      result[i] = oracle.getRoundData(startId);

      // Check if there was a 'phase change' AND the `_currentOracleUpdateTimestamp` is zero.
      if ((latestRoundData.roundId >> 64) != (startId >> 64) && result[i].answer == 0) {
        // NOTE: if the phase changes, then we want to correct the phase of the update.
        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).
        //       But chainlink does promise that it will be sequential.
        while (result[i].answer == 0) {
          // startId = (((startId >> 64) + 1) << 64) | uint80(uint64(startId));
          startId += (1 << 64); // ie add 2^64

          result[i] = oracle.getRoundData(startId);
        }
      }
      ++startId;
    }
  }
}

// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.17;

import "forge-std/console2.sol";

import "../interfaces/IRegistry.sol";
import "../interfaces/IGEMS.sol";
import "../interfaces/IMarket.sol";
import "../interfaces/IMarketExtended.sol";
import "../interfaces/IOracleManager.sol";

library OracleManagerUtils {
  function getOracleInfoForSystemStateUpdate(IOracleManager oracleManager, uint32 _latestExecutedEpochIndex)
    external
    view
    returns (uint80[] memory _missedEpochOracleRoundIds)
  {
    AggregatorV3Interface chainlinkOracle = oracleManager.chainlinkOracle();
    (uint80 lastQueriedRoundId, int256 currentOraclePrice, uint256 currentOracleUpdateTimestamp, , ) = chainlinkOracle.latestRoundData();

    uint256 epochLength = oracleManager.EPOCH_LENGTH();
    uint256 mewt = oracleManager.MINIMUM_EXECUTION_WAIT_THRESHOLD();

    uint256 latestValidEpoch = ((currentOracleUpdateTimestamp - mewt - oracleManager.getEpochStartTimestamp()) / epochLength);
    uint256 relevantEpochStartTimestampWithMEWT = oracleManager.getEpochStartTimestamp() + (latestValidEpoch * epochLength) + mewt;

    uint256 _numberOfMissedEpochs = latestValidEpoch - _latestExecutedEpochIndex;
    //// TODO: work out way to catchup epochs without the 'timeout' issue from the keeper.
    // // If the oracle falls more than 6 epochs behind it will only return 6 of them (but catch up 6 at a time).
    // //      And 30 for mumbai (because it can handle bigger transactions)
    // if (_numberOfMissedEpochs > (6 * (block.chainid == 80001 ? 5 : 1))) {
    //   _numberOfMissedEpochs = 6 * (block.chainid == 80001 ? 5 : 1);
    // }

    _missedEpochOracleRoundIds = new uint80[](_numberOfMissedEpochs);

    if (_numberOfMissedEpochs == 0) return (_missedEpochOracleRoundIds);

    uint256 currentUpdateIndex = _numberOfMissedEpochs - 1;

    while (currentUpdateIndex > 0) {
      --lastQueriedRoundId;
      // Get Previous round data to validate correctness.
      (, int256 previousOraclePrice, uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(lastQueriedRoundId);

      // Check if the previous oracle timestamp was zero, but the current one wasn't - then check if there was a phase change.
      if (previousOracleUpdateTimestamp == 0 && currentOracleUpdateTimestamp != 0) {
        console2.log(10, lastQueriedRoundId);
        uint80 numberOfPhaseChanges = 1;
        // NOTE: if the phase changes, then we want to correct the phase of the update.
        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).
        //       But chainlink does promise that it will be sequential.
        // View how phase changes happen here: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol#L335
        while (previousOracleUpdateTimestamp == 0) {
          // NOTE: re-using this variable to keep gas costs low for this edge case.
          (, previousOraclePrice, previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(
            lastQueriedRoundId - (numberOfPhaseChanges++ << 64)
          );
        }
      }

      if (
        previousOracleUpdateTimestamp < relevantEpochStartTimestampWithMEWT ||
        currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT ||
        currentOracleUpdateTimestamp < relevantEpochStartTimestampWithMEWT + epochLength
      ) {
        // Just a little sanity check that the price is correct!
        require(currentOraclePrice > 0, "invalid price");

        _missedEpochOracleRoundIds[currentUpdateIndex] = lastQueriedRoundId + 1;

        relevantEpochStartTimestampWithMEWT -= epochLength;
        currentUpdateIndex -= 1;
      }

      currentOracleUpdateTimestamp = previousOracleUpdateTimestamp;
      currentOraclePrice = previousOraclePrice;
    }
  }

  //////////////////////////
  //// OLD IMPLEMENTATION
  //////////////////////////

  //// Types:
  // NOTE: this struct is used to reduce stack usage and fix coverage.
  // it does use more gas though :/ Coverage is more important than gas optimization currently.
  struct MissedEpochExecution {
    bool _isSearchingForuint80;
    uint80 _currentOracleRoundId;
    uint32 _currentMissedEpochPriceUpdatesArrayIndex;
  }

  function _shouldOracleUpdateExecuteEpoch(
    IOracleManager oracleManager,
    uint256 currentEpochStartTimestamp,
    uint256 previousOracleUpdateTimestamp,
    uint256 currentOracleUpdateTimestamp
  ) internal view returns (bool) {
    //Don't use price for execution because MEWT has not expired yet
    //current price update epoch is ahead of MEWT so we check if the previous value
    //occurred before MEWT to validate that this is the correct price update to use

    //  first condition checks for whether the oracle price update occurs before Minimum Execution Wait Threshold is expired.
    return
      (previousOracleUpdateTimestamp < currentEpochStartTimestamp + oracleManager.MINIMUM_EXECUTION_WAIT_THRESHOLD()) &&
      (currentOracleUpdateTimestamp >= currentEpochStartTimestamp + oracleManager.MINIMUM_EXECUTION_WAIT_THRESHOLD());
  }

  /// @notice Calculates number of epochs which have missed system state update, due to bot failing
  /// @dev Called by internal function to decide how many epoch execution info (oracle price update details) should be returned
  /// @dev It is "maximum" as this is just the upper
  /// @param _latestExecutedEpochIndex index of the most recently executed epoch
  function _getMaximumNumberOfMissedEpochs(
    IOracleManager oracleManager,
    uint256 _latestExecutedEpochIndex,
    uint256 latestOraclePriceUpdateTime
  ) internal view returns (uint256 _numberOfMissedEpochs) {
    _numberOfMissedEpochs = oracleManager.getCurrentEpochIndex() - _latestExecutedEpochIndex - 1;

    if (_numberOfMissedEpochs == 0) return 0;

    // Checks for whether the oracle price update occurs before Minimum Execution Wait Threshold is expired.
    if (latestOraclePriceUpdateTime < oracleManager.getEpochStartTimestamp() + oracleManager.MINIMUM_EXECUTION_WAIT_THRESHOLD()) {
      _numberOfMissedEpochs -= 1;
    }
  }

  /// @notice returns an array of info on each epoch price update that was missed
  /// @dev This function gets executed in a system update on the market contract
  /// @param _latestExecutedEpochIndex the most recent epoch index in which a price update has been executed
  /// @param _previousOracleUpdateIndex the "roundId" used to reference the most recently executed oracle price on chainlink
  function getMissedEpochPriceUpdates(
    IOracleManager oracleManager,
    uint32 _latestExecutedEpochIndex,
    uint80 _previousOracleUpdateIndex,
    uint256 _numberOfUpdatesToTryFetch
  ) public view returns (uint80[] memory _missedEpochOracleRoundIds) {
    AggregatorV3Interface chainlinkOracle = oracleManager.chainlinkOracle();
    AggregatorV3InterfaceS.LatestRoundData memory latestRoundData = AggregatorV3InterfaceS(address(chainlinkOracle)).latestRoundData();

    // check whether latestRoundData.startedAt is before end point of previous epoch
    // if met, then break
    if (oracleManager.getEpochStartTimestamp() - oracleManager.EPOCH_LENGTH() > latestRoundData.startedAt) {
      _missedEpochOracleRoundIds = new uint80[](0);

      return (_missedEpochOracleRoundIds);
    }
    uint256 _numberOfMissedEpochs = Math.min(
      _getMaximumNumberOfMissedEpochs(oracleManager, _latestExecutedEpochIndex, latestRoundData.startedAt),
      _numberOfUpdatesToTryFetch
    );

    _missedEpochOracleRoundIds = new uint80[](_numberOfMissedEpochs);

    if (_numberOfMissedEpochs == 0) {
      return (_missedEpochOracleRoundIds);
    }

    MissedEpochExecution memory _missedEpochExecution = MissedEpochExecution({
      _isSearchingForuint80: true,
      _currentOracleRoundId: _previousOracleUpdateIndex + 1,
      _currentMissedEpochPriceUpdatesArrayIndex: 0
    });

    //  Start at the timestamp of the first epoch index after the latest executed epoch index
    // We add 1 to get the end timestamp of the latest executed epoch, then another 1 to get the next epoch, hence we add 2.
    latestRoundData.startedAt = (uint256(_latestExecutedEpochIndex) + 2) * oracleManager.EPOCH_LENGTH() + oracleManager.initialEpochStartTimestamp();

    // Called outside of the loop and then updated on each iteration within the loop
    (, , uint256 _previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(_previousOracleUpdateIndex);

    while (_missedEpochExecution._isSearchingForuint80 && latestRoundData.roundId >= _missedEpochExecution._currentOracleRoundId) {
      (, , uint256 _currentOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(_missedEpochExecution._currentOracleRoundId);

      // Check if there was a 'phase change' AND the `_currentOracleUpdateTimestamp` is zero.
      if ((latestRoundData.roundId >> 64) != (_previousOracleUpdateIndex >> 64) && _currentOracleUpdateTimestamp == 0) {
        // NOTE: if the phase changes, then we want to correct the phase of the update.
        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).
        //       But chainlink does promise that it will be sequential.
        while (_currentOracleUpdateTimestamp == 0) {
          _missedEpochExecution._currentOracleRoundId =
            (((_missedEpochExecution._currentOracleRoundId >> 64) + 1) << 64) |
            uint80(uint64(_missedEpochExecution._currentOracleRoundId));

          (, , _currentOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(_missedEpochExecution._currentOracleRoundId);
        }
      }
      if (_shouldOracleUpdateExecuteEpoch(oracleManager, latestRoundData.startedAt, _previousOracleUpdateTimestamp, _currentOracleUpdateTimestamp)) {
        // check whether oracle update is after end point of next epoch
        // if met, break the loop and send back the false
        // Checks for whether the oracle price update happened before end of current epoch end timestamp
        if (_currentOracleUpdateTimestamp > latestRoundData.startedAt + oracleManager.EPOCH_LENGTH()) {
          uint80[] memory truncatedMissedEpochOracleRoundIds = new uint80[](_missedEpochExecution._currentMissedEpochPriceUpdatesArrayIndex);
          for (uint256 i = 0; i < _missedEpochExecution._currentMissedEpochPriceUpdatesArrayIndex; ++i) {
            truncatedMissedEpochOracleRoundIds[i] = _missedEpochOracleRoundIds[i];
          }
          return (truncatedMissedEpochOracleRoundIds);
        } else {
          _missedEpochOracleRoundIds[_missedEpochExecution._currentMissedEpochPriceUpdatesArrayIndex] = _missedEpochExecution._currentOracleRoundId;
        }

        // Increment to the next array index and the correct timestamp
        _missedEpochExecution._currentMissedEpochPriceUpdatesArrayIndex += 1;
        latestRoundData.startedAt += uint32(oracleManager.EPOCH_LENGTH());

        // Check that we have retrieved all the missed epoch updates that we are searching
        // for and end the while loop
        if (_missedEpochExecution._currentMissedEpochPriceUpdatesArrayIndex == _numberOfMissedEpochs) {
          _missedEpochExecution._isSearchingForuint80 = false;
        }
      }

      //Previous oracle update timestamp can be reassigned to the current for the next iteration
      _previousOracleUpdateTimestamp = _currentOracleUpdateTimestamp;
      ++_missedEpochExecution._currentOracleRoundId;
    }
  }

  /// @notice Returns oracle information for executing historical epoch(s)
  /// @param latestExecutedEpochIndex the most recent epoch index in which a price update has been executed
  /// @param latestExecutedOracleRoundId the "roundId" used to reference the most recently executed oracle price on chainlink
  /// @return missedEpochOracleRoundIds list of epoch execution information
  function getOracleInfoForSystemStateUpdate(
    IOracleManager oracleManager,
    uint32 latestExecutedEpochIndex,
    uint80 latestExecutedOracleRoundId
  ) external view returns (uint80[] memory missedEpochOracleRoundIds) {
    uint256 numberOfEpochsSinceLastEpoch = (oracleManager.getCurrentEpochIndex() - latestExecutedEpochIndex) * oracleManager.EPOCH_LENGTH();

    // If the oracle falls more than 6 epochs behind it will only return 6 of them (but catch up 6 at a time).
    //      And 30 for mumbai (because it can handle bigger transactions)
    if (numberOfEpochsSinceLastEpoch > (6 * (block.chainid == 80001 ? 5 : 1))) {
      numberOfEpochsSinceLastEpoch = 6 * (block.chainid == 80001 ? 5 : 1);
    }

    missedEpochOracleRoundIds = getMissedEpochPriceUpdates(
      oracleManager,
      latestExecutedEpochIndex,
      latestExecutedOracleRoundId,
      numberOfEpochsSinceLastEpoch
    );
  }

  /// @notice Returns start timestamp of current epoch
  /// @return getEpochStartTimestamp start timestamp of the current epoch
  function getEpochStartTimestamp(IOracleManager oracleManager, uint32 epochIndex) external view returns (uint256) {
    return (uint256(epochIndex) * oracleManager.EPOCH_LENGTH()) + oracleManager.initialEpochStartTimestamp();
  }
}

// SPDX-License-Identifier: MIT
pragma solidity >=0.4.22 <0.9.0;

// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should
// use `int256` and `uint256`. This modified version fixes that. This version is recommended
// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in
// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.
// Reference: https://github.com/NomicFoundation/hardhat/issues/2178

library console2 {
    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

    function _sendLogPayload(bytes memory payload) private view {
        uint256 payloadLength = payload.length;
        address consoleAddress = CONSOLE_ADDRESS;
        assembly {
            let payloadStart := add(payload, 32)
            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
        }
    }

    function log() internal view {
        _sendLogPayload(abi.encodeWithSignature("log()"));
    }

    function logInt(int256 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
    }

    function logUint(uint256 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
    }

    function logString(string memory p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    }

    function logBool(bool p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    }

    function logAddress(address p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    }

    function logBytes(bytes memory p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
    }

    function logBytes1(bytes1 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
    }

    function logBytes2(bytes2 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
    }

    function logBytes3(bytes3 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
    }

    function logBytes4(bytes4 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
    }

    function logBytes5(bytes5 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
    }

    function logBytes6(bytes6 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
    }

    function logBytes7(bytes7 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
    }

    function logBytes8(bytes8 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
    }

    function logBytes9(bytes9 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
    }

    function logBytes10(bytes10 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
    }

    function logBytes11(bytes11 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
    }

    function logBytes12(bytes12 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
    }

    function logBytes13(bytes13 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
    }

    function logBytes14(bytes14 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
    }

    function logBytes15(bytes15 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
    }

    function logBytes16(bytes16 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
    }

    function logBytes17(bytes17 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
    }

    function logBytes18(bytes18 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
    }

    function logBytes19(bytes19 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
    }

    function logBytes20(bytes20 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
    }

    function logBytes21(bytes21 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
    }

    function logBytes22(bytes22 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
    }

    function logBytes23(bytes23 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
    }

    function logBytes24(bytes24 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
    }

    function logBytes25(bytes25 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
    }

    function logBytes26(bytes26 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
    }

    function logBytes27(bytes27 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
    }

    function logBytes28(bytes28 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
    }

    function logBytes29(bytes29 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
    }

    function logBytes30(bytes30 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
    }

    function logBytes31(bytes31 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
    }

    function logBytes32(bytes32 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
    }

    function log(uint256 p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
    }

    function log(string memory p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
    }

    function log(bool p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
    }

    function log(address p0) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
    }

    function log(uint256 p0, uint256 p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
    }

    function log(uint256 p0, string memory p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
    }

    function log(uint256 p0, bool p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
    }

    function log(uint256 p0, address p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
    }

    function log(string memory p0, uint256 p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
    }

    function log(string memory p0, string memory p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
    }

    function log(string memory p0, bool p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
    }

    function log(string memory p0, address p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
    }

    function log(bool p0, uint256 p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
    }

    function log(bool p0, string memory p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
    }

    function log(bool p0, bool p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
    }

    function log(bool p0, address p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
    }

    function log(address p0, uint256 p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
    }

    function log(address p0, string memory p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
    }

    function log(address p0, bool p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
    }

    function log(address p0, address p1) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
    }

    function log(uint256 p0, uint256 p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
    }

    function log(uint256 p0, uint256 p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
    }

    function log(uint256 p0, uint256 p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
    }

    function log(uint256 p0, uint256 p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
    }

    function log(uint256 p0, string memory p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
    }

    function log(uint256 p0, string memory p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
    }

    function log(uint256 p0, string memory p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
    }

    function log(uint256 p0, string memory p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
    }

    function log(uint256 p0, bool p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
    }

    function log(uint256 p0, bool p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
    }

    function log(uint256 p0, bool p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
    }

    function log(uint256 p0, bool p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
    }

    function log(uint256 p0, address p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
    }

    function log(uint256 p0, address p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
    }

    function log(uint256 p0, address p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
    }

    function log(uint256 p0, address p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
    }

    function log(string memory p0, uint256 p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
    }

    function log(string memory p0, uint256 p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
    }

    function log(string memory p0, uint256 p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
    }

    function log(string memory p0, uint256 p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
    }

    function log(string memory p0, string memory p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
    }

    function log(string memory p0, string memory p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
    }

    function log(string memory p0, string memory p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
    }

    function log(string memory p0, string memory p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
    }

    function log(string memory p0, bool p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
    }

    function log(string memory p0, bool p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
    }

    function log(string memory p0, bool p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
    }

    function log(string memory p0, bool p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
    }

    function log(string memory p0, address p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
    }

    function log(string memory p0, address p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
    }

    function log(string memory p0, address p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
    }

    function log(string memory p0, address p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
    }

    function log(bool p0, uint256 p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
    }

    function log(bool p0, uint256 p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
    }

    function log(bool p0, uint256 p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
    }

    function log(bool p0, uint256 p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
    }

    function log(bool p0, string memory p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
    }

    function log(bool p0, string memory p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
    }

    function log(bool p0, string memory p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
    }

    function log(bool p0, string memory p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
    }

    function log(bool p0, bool p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
    }

    function log(bool p0, bool p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
    }

    function log(bool p0, bool p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
    }

    function log(bool p0, bool p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
    }

    function log(bool p0, address p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
    }

    function log(bool p0, address p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
    }

    function log(bool p0, address p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
    }

    function log(bool p0, address p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
    }

    function log(address p0, uint256 p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
    }

    function log(address p0, uint256 p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
    }

    function log(address p0, uint256 p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
    }

    function log(address p0, uint256 p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
    }

    function log(address p0, string memory p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
    }

    function log(address p0, string memory p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
    }

    function log(address p0, string memory p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
    }

    function log(address p0, string memory p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
    }

    function log(address p0, bool p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
    }

    function log(address p0, bool p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
    }

    function log(address p0, bool p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
    }

    function log(address p0, bool p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
    }

    function log(address p0, address p1, uint256 p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
    }

    function log(address p0, address p1, string memory p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
    }

    function log(address p0, address p1, bool p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
    }

    function log(address p0, address p1, address p2) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
    }

    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, string memory p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, bool p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
    }

    function log(uint256 p0, address p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, uint256 p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, string memory p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, bool p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
    }

    function log(string memory p0, address p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, uint256 p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, string memory p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, bool p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
    }

    function log(bool p0, address p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
    }

    function log(address p0, uint256 p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
    }

    function log(address p0, string memory p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
    }

    function log(address p0, bool p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, uint256 p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, uint256 p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, uint256 p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, string memory p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, string memory p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, string memory p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, string memory p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, bool p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, bool p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, bool p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, bool p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, address p2, uint256 p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, address p2, string memory p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, address p2, bool p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
    }

    function log(address p0, address p1, address p2, address p3) internal view {
        _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
    }

}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`.
        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.
        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.
        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a
        // good first aproximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1;
        uint256 x = a;
        if (x >> 128 > 0) {
            x >>= 128;
            result <<= 64;
        }
        if (x >> 64 > 0) {
            x >>= 64;
            result <<= 32;
        }
        if (x >> 32 > 0) {
            x >>= 32;
            result <<= 16;
        }
        if (x >> 16 > 0) {
            x >>= 16;
            result <<= 8;
        }
        if (x >> 8 > 0) {
            x >>= 8;
            result <<= 4;
        }
        if (x >> 4 > 0) {
            x >>= 4;
            result <<= 2;
        }
        if (x >> 2 > 0) {
            result <<= 1;
        }

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        uint256 result = sqrt(a);
        if (rounding == Rounding.Up && result * result < a) {
            result += 1;
        }
        return result;
    }
}