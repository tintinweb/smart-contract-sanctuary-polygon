/**
 *Submitted for verification at polygonscan.com on 2023-07-06
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Distribution
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
	function burn(uint256 amount) external returns (bool);
}

interface ERC721{
	function ownerOf(uint256 tokenId) external view returns (address);
}

contract Airdrop {

	address owner;
	mapping(uint256 => uint256) public nosCreditsPerToken;
	uint256 public totalToDrain = uint256(0);
	event Claimed (uint256 indexed tokenId);
	uint256 public claimCoinPrice0 = uint256(1000000000000000000);
	uint256 public claimCoinPrice0SourceAmtInBank = uint256(0);
	uint256 public claimCoinPrice0SourceSplit0 = uint256(100);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

/**
 * Function changeValueOf_claimCoinPrice0
 * Notes for _claimCoinPrice0 : 10^18 represents 1 Coin_CUESPoly
 * The function takes in 1 variable, (zero or a positive integer) _claimCoinPrice0. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates claimCoinPrice0 as _claimCoinPrice0
*/
	function changeValueOf_claimCoinPrice0(uint256 _claimCoinPrice0) external onlyOwner {
		claimCoinPrice0  = _claimCoinPrice0;
	}

/**
 * Function changeValueOf_claimCoinPrice0SourceSplit0
 * Notes for _claimCoinPrice0SourceSplit0 : Set Percentage of the Tax diverted by this address. 1 = 1%
 * The function takes in 1 variable, (zero or a positive integer) _claimCoinPrice0SourceSplit0. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates claimCoinPrice0SourceSplit0 as _claimCoinPrice0SourceSplit0
*/
	function changeValueOf_claimCoinPrice0SourceSplit0(uint256 _claimCoinPrice0SourceSplit0) external onlyOwner {
		claimCoinPrice0SourceSplit0  = _claimCoinPrice0SourceSplit0;
	}

/**
 * Function sendInTokens
 * The function takes in 1 variable, (zero or a positive integer) _nosTokens. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalParts with initial value 0
 * calls ERC20(Address 0x94C0d50207E9492d6DADBD49414778fdbF182413)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _nosTokens
 * repeat ((1) + (14)) - (1) times with loop variable i0 :  (creates an internal variable thisValue with initial value 1000; and then updates totalParts as (totalParts) + (thisValue))
 * checks that totalParts is strictly greater than 0
 * repeat ((1) + (14)) - (1) times with loop variable i0 :  (creates an internal variable value with initial value ((_nosTokens) * (1000)) / (totalParts); and then updates nosCreditsPerToken (Element (1) + (Loop Variable i0)) as (nosCreditsPerToken with element (1) + (Loop Variable i0)) + (value))
*/
	function sendInTokens(uint256 _nosTokens) public {
		uint256 totalParts = uint256(0);
		ERC20(address(0x94C0d50207E9492d6DADBD49414778fdbF182413)).transferFrom(msg.sender, address(this), _nosTokens);
		for (uint i0 = 0; i0 < ((uint256(1) + uint256(14)) - uint256(1)); i0++){
			uint256 thisValue = uint256(1000);
			totalParts  = (totalParts + thisValue);
		}
		require((totalParts > uint256(0)), "No NFTs to Distribute To");
		for (uint i0 = 0; i0 < ((uint256(1) + uint256(14)) - uint256(1)); i0++){
			uint256 value = ((_nosTokens * uint256(1000)) / totalParts);
			nosCreditsPerToken[(uint256(1) + i0)]  = (nosCreditsPerToken[(uint256(1) + i0)] + value);
		}
	}

/**
 * Function claim
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (the address that called this function) is equals to (ERC721(Address 0xA196E006ae71eCF9074fCcB4DF84A56dbe4ACF37)'s at ownerOf function  with variable tokenId as _tokenId)
 * checks that (ERC20(Address 0x94C0d50207E9492d6DADBD49414778fdbF182413)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (nosCreditsPerToken with element _tokenId)
 * if (nosCreditsPerToken with element _tokenId) is strictly greater than 0 then (calls ERC20(Address 0x94C0d50207E9492d6DADBD49414778fdbF182413)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (nosCreditsPerToken with element _tokenId))
 * calls ERC20(Address 0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as (((claimCoinPrice0) * (nosCreditsPerToken with element _tokenId)) / (10**18))
 * checks that (ERC20(Address 0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((((claimCoinPrice0) * (nosCreditsPerToken with element _tokenId)) / (10**18)) * (claimCoinPrice0SourceSplit0)) / (100))
 * if (((((claimCoinPrice0) * (nosCreditsPerToken with element _tokenId)) / (10**18)) * (claimCoinPrice0SourceSplit0)) / (100)) is strictly greater than 0 then (calls ERC20(Address 0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)'s at burn function  with variable amount as (((((claimCoinPrice0) * (nosCreditsPerToken with element _tokenId)) / (10**18)) * (claimCoinPrice0SourceSplit0)) / (100)))
 * updates claimCoinPrice0SourceAmtInBank as (claimCoinPrice0SourceAmtInBank) + (((((claimCoinPrice0) * (nosCreditsPerToken with element _tokenId)) / (10**18)) * ((100) - (claimCoinPrice0SourceSplit0))) / (100))
 * updates nosCreditsPerToken (Element _tokenId) as 0
 * emits event Claimed with inputs _tokenId
*/
	function claim(uint256 _tokenId) public {
		require((msg.sender == ERC721(address(0xA196E006ae71eCF9074fCcB4DF84A56dbe4ACF37)).ownerOf(_tokenId)), "Not the owner of the token");
		require((ERC20(address(0x94C0d50207E9492d6DADBD49414778fdbF182413)).balanceOf(address(this)) >= nosCreditsPerToken[_tokenId]), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((nosCreditsPerToken[_tokenId] > uint256(0))){
			ERC20(address(0x94C0d50207E9492d6DADBD49414778fdbF182413)).transfer(msg.sender, nosCreditsPerToken[_tokenId]);
		}
		ERC20(address(0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)).transferFrom(msg.sender, address(this), ((claimCoinPrice0 * nosCreditsPerToken[_tokenId]) / uint256(10**18)));
		require((ERC20(address(0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)).balanceOf(address(this)) >= ((((claimCoinPrice0 * nosCreditsPerToken[_tokenId]) / uint256(10**18)) * claimCoinPrice0SourceSplit0) / uint256(100))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((((claimCoinPrice0 * nosCreditsPerToken[_tokenId]) / uint256(10**18)) * claimCoinPrice0SourceSplit0) / uint256(100)) > uint256(0))){
			ERC20(address(0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)).burn(((((claimCoinPrice0 * nosCreditsPerToken[_tokenId]) / uint256(10**18)) * claimCoinPrice0SourceSplit0) / uint256(100)));
		}
		claimCoinPrice0SourceAmtInBank  = (claimCoinPrice0SourceAmtInBank + ((((claimCoinPrice0 * nosCreditsPerToken[_tokenId]) / uint256(10**18)) * (uint256(100) - claimCoinPrice0SourceSplit0)) / uint256(100)));
		nosCreditsPerToken[_tokenId]  = uint256(0);
		emit Claimed(_tokenId);
	}

/**
 * Function drain
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * repeat ((1) + (14)) - (1) times with loop variable i0 :  (if (nosCreditsPerToken with element (1) + (Loop Variable i0)) is strictly greater than 0 then (updates totalToDrain as (totalToDrain) + (nosCreditsPerToken with element (1) + (Loop Variable i0)); and then updates nosCreditsPerToken (Element (1) + (Loop Variable i0)) as 0))
 * checks that (ERC20(Address 0x94C0d50207E9492d6DADBD49414778fdbF182413)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to totalToDrain
 * if totalToDrain is strictly greater than 0 then (calls ERC20(Address 0x94C0d50207E9492d6DADBD49414778fdbF182413)'s at transfer function  with variable recipient as (the address that called this function), variable amount as totalToDrain)
*/
	function drain() public onlyOwner {
		for (uint i0 = 0; i0 < ((uint256(1) + uint256(14)) - uint256(1)); i0++){
			if ((nosCreditsPerToken[(uint256(1) + i0)] > uint256(0))){
				totalToDrain  = (totalToDrain + nosCreditsPerToken[(uint256(1) + i0)]);
				nosCreditsPerToken[(uint256(1) + i0)]  = uint256(0);
			}
		}
		require((ERC20(address(0x94C0d50207E9492d6DADBD49414778fdbF182413)).balanceOf(address(this)) >= totalToDrain), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((totalToDrain > uint256(0))){
			ERC20(address(0x94C0d50207E9492d6DADBD49414778fdbF182413)).transfer(msg.sender, totalToDrain);
		}
	}

/**
 * Function claimCoinPrice0SourceTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to claimCoinPrice0SourceAmtInBank
 * if claimCoinPrice0SourceAmtInBank is strictly greater than 0 then (calls ERC20(Address 0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)'s at transfer function  with variable recipient as (the address that called this function), variable amount as claimCoinPrice0SourceAmtInBank)
 * updates claimCoinPrice0SourceAmtInBank as 0
*/
	function claimCoinPrice0SourceTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)).balanceOf(address(this)) >= claimCoinPrice0SourceAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((claimCoinPrice0SourceAmtInBank > uint256(0))){
			ERC20(address(0xdB829Be222872adf77FCfc3e09525Aa3E091a98B)).transfer(msg.sender, claimCoinPrice0SourceAmtInBank);
		}
		claimCoinPrice0SourceAmtInBank  = uint256(0);
	}

/**
 * Function costInCoinPrice0ToClaimForTokenId
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * returns (claimCoinPrice0) * (nosCreditsPerToken with element _tokenId) as output
*/
	function costInCoinPrice0ToClaimForTokenId(uint256 _tokenId) public view returns (uint256) {
		return (claimCoinPrice0 * nosCreditsPerToken[_tokenId]);
	}
}