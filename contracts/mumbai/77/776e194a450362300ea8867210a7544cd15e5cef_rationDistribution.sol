// SPDX-License-Identifier: MIT

import "./item.sol";
import "./citizen.sol";
import "./rationShop.sol";
import "./dateTime.sol";
import "./AutomationCompatible.sol";

pragma solidity ^0.8.7;

contract rationDistribution is item,citizen,rationShop,dateTime, AutomationCompatible{

    struct BuyerSeller{
        uint rationCardNo;
        uint rationShopNo;
    }
    
    struct rationDistributionToPublic{
        BuyerSeller BuyerSellerInfo;
        string purchasedItem;
        uint sellingPrice;
        uint sellingTime;
        uint receiptNo;
    }
    
    mapping(uint => mapping(string => uint))public goodsDeliveryToRationShop;
    rationDistributionToPublic[] public rationDelivery;
    mapping(bytes => bool) public usedSignature;
    event StoreItemToRationShop(uint indexed rationShopId,string itemName,uint weight);
    event RationDelivery(uint indexed rationCardNo,uint indexed ReceiptNo);
    event ResetRationDetails(address indexed RationResetcaller, uint indexed timeOfReset);

    uint public lastTimeStamp;
    uint immutable interval;

    constructor() {
        interval = 24*60*60*27;
    }

     function checkUpkeep(bytes calldata /* checkData */)external view override returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        uint Todaydate=getDay(block.timestamp);
        upkeepNeeded = Todaydate == 15 && (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        uint Todaydate=getDay(block.timestamp);
        if (Todaydate == 15 && (block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            deleteRationDetails();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }


    function addItemToRationShop(uint _rationShopNo, string[] calldata _itemName,uint[] calldata _weight) public onlyOwner{
        uint len = _weight.length;
        require(_itemName.length == len,"No of item name is not equal to no of Weight");
        for(uint i; i<len ; i++){
            require(items[_itemName[i]].weight !=0,"This item is not given in Ration Shop");
            goodsDeliveryToRationShop[_rationShopNo][_itemName[i]] += _weight[i];
            emit StoreItemToRationShop(_rationShopNo,_itemName[i],_weight[i]);
        }
    }
    function deleteRationDetails() public{
	    uint Todaydate;	    
	    Todaydate=getDay(block.timestamp);
        require(Todaydate==15,"Today is not the Fifteenth Day of the Month");
        require((block.timestamp - lastTimeStamp) > interval,"time left before deletion of record");
        lastTimeStamp = block.timestamp;
        delete rationDelivery;
        emit ResetRationDetails(msg.sender, block.timestamp);
	} 

    function rationDeliveryToCitizen(bytes memory encodedData)public {
        (uint _rationCardNo, uint _rationShopNo, string memory _itemName, uint _timeStamp, bytes memory _signature) = decodeData(encodedData);
        (bool _status,uint _financialStatus) = checkingSignature(_rationCardNo,_rationShopNo,_itemName,_timeStamp,_signature);
        require(_status == true,"signature doesnot match");
        _timeStamp = getDay(block.timestamp);
	    require(_timeStamp != 15,"Today Ration will not be provided... Kindly Visit Tomorrow to fourteenth day of the Month For Ration");
        uint availableGoods = goodsDeliveryToRationShop[_rationShopNo][_itemName];
        uint _weight = items[_itemName].weight;
        require(availableGoods >= _weight,"Purchased Item not available in this Ration Shop");
        uint len = rationDelivery.length;      
        for(uint i; i<len; i++){
            if(rationDelivery[i].BuyerSellerInfo.rationCardNo == _rationCardNo){
                require(uint(keccak256(abi.encodePacked(rationDelivery[i].purchasedItem))) != uint(keccak256(abi.encodePacked(_itemName))),"Already purchased Item");
            }  
        }
        len = len + 1;
        if(_financialStatus == 0){  
            uint totalPrice = items[_itemName].bplPrice * _weight;          
            rationDelivery.push(rationDistributionToPublic(BuyerSeller(_rationCardNo, _rationShopNo),_itemName,totalPrice,block.timestamp,len));
        }
        else{
            uint totalPrice = items[_itemName].aplPrice * _weight; 
            rationDelivery.push(rationDistributionToPublic(BuyerSeller(_rationCardNo, _rationShopNo),_itemName,totalPrice,block.timestamp,len));
        }
        goodsDeliveryToRationShop[_rationCardNo][_itemName] -= _weight;
        usedSignature[_signature] = true;
        emit RationDelivery(_rationCardNo,len);
    }

    function checkingSignature(uint _rationCardNo,uint _rationShopNo,string memory _itemName,uint _timeStamp,bytes memory _signature) public view returns(bool,uint){
        (,address _rationCardOwner, uint _financialStatus) = citizenInformation(_rationCardNo);
        (, address rationWallet) = shopInformation(_rationShopNo);
        require(_rationCardOwner != address(0),"this Ration Card No doesnot exist");        
        require(rationWallet != address(0),"this Ration Card No doesnot exist");
        //registerItem memory buying = items[_itemName];
        require(_rationCardOwner != address(0),"this Ration Card No doesnot exist");        
        require(rationWallet != address(0),"this Ration Card No doesnot exist");
        require(!usedSignature[_signature],"Already used signature");
        require(items[_itemName].weight !=0,"This item is not given in Ration Shop");
        (bool _status) = verifyPurchase(_rationCardOwner, _rationCardNo,_rationShopNo,_itemName,_timeStamp,_signature);
        return (_status,_financialStatus);
    }


    function encodeData(uint _rationCardNo,uint _rationShopNo,string calldata _itemName,uint _timeStamp,bytes memory _signature) public pure returns (bytes memory) {
        return abi.encode(_rationCardNo, _rationShopNo, bytes(_itemName), _timeStamp, _signature);  
    }

    function decodeData(bytes memory encodedData) public pure returns (uint, uint, string memory, uint, bytes memory) {
        (uint _rationCardNo, uint _rationShopNo, bytes memory _itemNameBytes, uint _timeStamp, bytes memory _signature) = abi.decode(encodedData, (uint, uint, bytes, uint, bytes));
        string memory _itemName = string(_itemNameBytes);
        return (_rationCardNo, _rationShopNo, _itemName, _timeStamp, _signature);
    }

}