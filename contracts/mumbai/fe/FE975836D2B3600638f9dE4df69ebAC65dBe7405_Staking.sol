/**
 *Submitted for verification at polygonscan.com on 2023-07-03
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Staking
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Staking {

	address owner;
	struct record { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; }
	mapping(address => record) public informationAboutStakeScheme;
	mapping(uint256 => address) public addressStore;
	uint256 public numberOfAddressesCurrentlyStaked = uint256(0);
	uint256 public totalWithdrawals = uint256(0);
	address[] public whitelist = [address(0x82137f52C632043410Fcc95C17254CDaE1E93824)];
	event Staked (address indexed account);
	event Unstaked (address indexed account);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function isInside_address(address _j0, address[] memory _j1) internal pure returns (bool){
		for (uint _i = 0; _i < _j1.length; _i++){
			if (_j0 == _j1[_i]){
				return true;
			}
		}
		return false;
	}

/**
 * Function stake
 * Daily Interest Rate : 1.4
 * Address Map : informationAboutStakeScheme
 * The function takes in 1 variable, (zero or a positive integer) _stakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that _stakeAmt is strictly greater than 0
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme with element the address that called this function
 * if (thisRecord with element stakeAmt) is equals to 0 then (updates informationAboutStakeScheme (Element the address that called this function) as Struct comprising current time, _stakeAmt, current time, 0; then updates addressStore (Element numberOfAddressesCurrentlyStaked) as the address that called this function; and then updates numberOfAddressesCurrentlyStaked as (numberOfAddressesCurrentlyStaked) + (1)) otherwise (updates informationAboutStakeScheme (Element the address that called this function) as Struct comprising current time, ((thisRecord with element stakeAmt) + (_stakeAmt)), current time, ((thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (14000)) / (86400000000))))
 * calls ERC20(Address 0x0Cfa285c38760512AE631063ea0A8ad4C2eFD124)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _stakeAmt
 * checks that check if (the address that called this function) is inside whitelist
 * emits event Staked with inputs the address that called this function
*/
	function stake(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
		if ((thisRecord.stakeAmt == uint256(0))){
			informationAboutStakeScheme[msg.sender]  = record (block.timestamp, _stakeAmt, block.timestamp, uint256(0));
			addressStore[numberOfAddressesCurrentlyStaked]  = msg.sender;
			numberOfAddressesCurrentlyStaked  = (numberOfAddressesCurrentlyStaked + uint256(1));
		}else{
			informationAboutStakeScheme[msg.sender]  = record (block.timestamp, (thisRecord.stakeAmt + _stakeAmt), block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * uint256(14000)) / uint256(86400000000))));
		}
		ERC20(address(0x0Cfa285c38760512AE631063ea0A8ad4C2eFD124)).transferFrom(msg.sender, address(this), _stakeAmt);
		require(isInside_address(msg.sender, whitelist), "Address not on whitelist");
		emit Staked(msg.sender);
	}

/**
 * Function unstake
 * The function takes in 1 variable, (zero or a positive integer) _unstakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme with element the address that called this function
 * checks that _unstakeAmt is less than or equals to (thisRecord with element stakeAmt)
 * creates an internal variable newAccum with initial value (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (14000)) / (86400000000))
 * creates an internal variable interestToRemove with initial value ((newAccum) * (_unstakeAmt)) / (thisRecord with element stakeAmt)
 * if _unstakeAmt is equals to (thisRecord with element stakeAmt) then (repeat numberOfAddressesCurrentlyStaked times with loop variable i0 :  (if (addressStore with element Loop Variable i0) is equals to (the address that called this function) then (updates addressStore (Element Loop Variable i0) as addressStore with element (numberOfAddressesCurrentlyStaked) - (1); then updates numberOfAddressesCurrentlyStaked as (numberOfAddressesCurrentlyStaked) - (1); and then terminates the for-next loop)))
 * updates informationAboutStakeScheme (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), ((thisRecord with element stakeAmt) - (_unstakeAmt)), current time, ((newAccum) - (interestToRemove))
 * emits event Unstaked with inputs the address that called this function
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (transfers interestToRemove of the native currency to the address that called this function)
 * checks that (ERC20(Address 0x0Cfa285c38760512AE631063ea0A8ad4C2eFD124)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _unstakeAmt
 * if _unstakeAmt is strictly greater than 0 then (calls ERC20(Address 0x0Cfa285c38760512AE631063ea0A8ad4C2eFD124)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _unstakeAmt)
 * updates totalWithdrawals as (totalWithdrawals) + (interestToRemove)
*/
	function unstake(uint256 _unstakeAmt) public {
		record memory thisRecord = informationAboutStakeScheme[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * uint256(14000)) / uint256(86400000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
				if ((addressStore[i0] == msg.sender)){
					addressStore[i0]  = addressStore[(numberOfAddressesCurrentlyStaked - uint256(1))];
					numberOfAddressesCurrentlyStaked  = (numberOfAddressesCurrentlyStaked - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme[msg.sender]  = record (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove));
		emit Unstaked(msg.sender);
		require((address(this).balance >= interestToRemove), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((interestToRemove > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : interestToRemove}(""); require(success_1, "can't send money");
		}
		require((ERC20(address(0x0Cfa285c38760512AE631063ea0A8ad4C2eFD124)).balanceOf(address(this)) >= _unstakeAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_unstakeAmt > uint256(0))){
			ERC20(address(0x0Cfa285c38760512AE631063ea0A8ad4C2eFD124)).transfer(msg.sender, _unstakeAmt);
		}
		totalWithdrawals  = (totalWithdrawals + interestToRemove);
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme with element _address
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((current time) - (thisRecord with element lastUpdateTime)) * (14000)) / (86400000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(address _address) public view returns (uint256) {
		record memory thisRecord = informationAboutStakeScheme[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (block.timestamp - thisRecord.lastUpdateTime) * uint256(14000)) / uint256(86400000000)));
	}

/**
 * Function totalStakedAmount
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme with element addressStore with element Loop Variable i0; and then updates total as (total) + (thisRecord with element stakeAmt))
 * returns total as output
*/
	function totalStakedAmount() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked; i0++){
			record memory thisRecord = informationAboutStakeScheme[addressStore[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

/**
 * Function withdrawNativeCurrency
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (amount of native currency owned by the address of this contract) is greater than or equals to _amt
 * if _amt is strictly greater than 0 then (transfers _amt of the native currency to the address that called this function)
*/
	function withdrawNativeCurrency(uint256 _amt) public onlyOwner {
		require((address(this).balance >= _amt), "Insufficient amount of native currency in this contract to transfer out. Please contact the contract owner to top up the native currency.");
		if ((_amt > uint256(0))){
			(bool success_1, ) =  payable(msg.sender).call{value : _amt}(""); require(success_1, "can't send money");
		}
	}

/**
 * Function addToWhitelist
 * The function takes in 1 variable, (an address) _addressToAdd. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * if check if _addressToAdd is inside whitelist then it does nothing else otherwise (adds _addressToAdd to whitelist)
*/
	function addToWhitelist(address _addressToAdd) public onlyOwner {
		if (isInside_address(_addressToAdd, whitelist)){
		}else{
			whitelist.push(_addressToAdd);
		}
	}

/**
 * Function removeFromWhitelist
 * The function takes in 1 variable, (an address) _addressToAdd. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * if check if _addressToAdd is inside whitelist then (repeat length of whitelist times with loop variable i0 :  (if _addressToAdd is equals to (whitelist with element (Loop Variable i0) - (1)) then (if (length of whitelist) is strictly greater than (Loop Variable i0) then (updates whitelist (Element (Loop Variable i0) - (1)) as whitelist with element (length of whitelist) - (1)); and then removes last item from whitelist)))
*/
	function removeFromWhitelist(address _addressToAdd) public onlyOwner {
		if (isInside_address(_addressToAdd, whitelist)){
			for (uint i0 = (whitelist).length; i0 > 0; i0--){
				if ((_addressToAdd == whitelist[(i0 - uint256(1))])){
					if (((whitelist).length > i0)){
						whitelist[(i0 - uint256(1))]  = whitelist[((whitelist).length - uint256(1))];
					}
					whitelist.pop();
				}
			}
		}
	}

	function sendMeNativeCurrency() external payable {
	}
}