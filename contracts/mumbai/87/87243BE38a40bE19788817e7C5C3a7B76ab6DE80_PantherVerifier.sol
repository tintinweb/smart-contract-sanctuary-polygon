// SPDX-License-Identifier: AGPL-3.0-only
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
// SPDX-FileCopyrightText: Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)
pragma solidity ^0.8.16;

/**
 * @notice Read bytecode at given address from given position.
 */
library Bytecode {
    function read(address pointer, uint256 offset)
        internal
        view
        returns (bytes memory data)
    {
        uint256 size = pointer.code.length;
        require(size >= offset, "OUT_OF_BOUNDS");

        unchecked {
            size -= offset;
        }

        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Get a pointer to some free memory.
            data := mload(0x40)

            // Update the free memory pointer to prevent overriding our data.
            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).
            // Adding 31 to size and running the result through the logic above ensures
            // the memory pointer remains word-aligned, following the Solidity convention.
            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))

            // Store the size of the data in the first 32 byte chunk of free memory.
            mstore(data, size)

            // Copy the code into memory right after the 32 bytes we used to store the size.
            extcodecopy(pointer, add(data, 32), offset, size)
        }
    }
}

// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
// slither-disable-next-line solc-version
pragma solidity ^0.8.4;

struct G1Point {
    uint256 x;
    uint256 y;
}

// Encoding of field elements is: X[0] * z + X[1]
struct G2Point {
    uint256[2] x;
    uint256[2] y;
}

// Verification key for SNARK
struct VerifyingKey {
    G1Point alfa1;
    G2Point beta2;
    G2Point gamma2;
    G2Point delta2;
    G1Point[] ic;
}

struct SnarkProof {
    G1Point a;
    G2Point b;
    G1Point c;
}

struct PluginData {
    address contractAddress;
    bytes callData;
}

struct ElGamalCiphertext {
    G1Point c1;
    G1Point c2;
}

// For MASP V0 and V1
struct ZAsset {
    // reserved (for networkId, tokenIdPolicy. etc..)
    uint64 _unused;
    // 0x00 by default
    uint8 version;
    // Refer to Constants.sol
    uint8 status;
    // Refer to Constants.sol
    uint8 tokenType;
    // 0x00 - no scaling
    uint8 scale;
    // token contract address
    address token;
}

struct LockData {
    // Refer to Constants.sol
    uint8 tokenType;
    // Token contract address
    address token;
    // For ERC-721, ERC-1155 tokens
    uint256 tokenId;
    // The account to transfer the token from/to (on `lock`/`unlock`)
    address extAccount;
    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)
    uint96 extAmount;
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.16;

import { G1Point, G2Point } from "../../common/Types.sol";
import { PRIME_Q } from "./SnarkConstants.sol";

/// @dev This is slightly modified `library Paring` generated by the `snarkjs` lib (v.0.6.9).
abstract contract EllipticCurveMath {
    /// @return the generator of G1
    function P1() internal pure returns (G1Point memory) {
        return G1Point(1, 2);
    }

    /// @return the generator of G2
    function P2() internal pure returns (G2Point memory) {
        return
            G2Point(
                [
                    11559732032986387107991004021392285783925812861821192530917403151452391805634,
                    10857046999023057135944570762232829481370756359578518086990519993285655852781
                ],
                [
                    4082367875863433681332203403145435568316851327593401208105741076214120093531,
                    8495653923123431417604973247489272438418190587263600148770280649306958101930
                ]
            );
    }

    /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.
    function negate(G1Point memory p) internal pure returns (G1Point memory r) {
        if (p.x == 0 && p.y == 0) return G1Point(0, 0);
        return G1Point(p.x, PRIME_Q - (p.y % PRIME_Q));
    }

    /// @return r the sum of two points of G1
    function addition(G1Point memory p1, G1Point memory p2)
        internal
        view
        returns (G1Point memory r)
    {
        uint256[4] memory input;
        input[0] = p1.x;
        input[1] = p1.y;
        input[2] = p2.x;
        input[3] = p2.y;
        bool success;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)
            // Use "invalid" to make gas estimation work
            switch success
            case 0 {
                invalid()
            }
        }
        require(success, "pairing-add-failed");
    }

    /// @return r the product of a point on G1 and a scalar, i.e.
    /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.
    function scalar_mul(G1Point memory p, uint256 s)
        internal
        view
        returns (G1Point memory r)
    {
        uint256[3] memory input;
        input[0] = p.x;
        input[1] = p.y;
        input[2] = s;
        bool success;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)
            // Use "invalid" to make gas estimation work
            switch success
            case 0 {
                invalid()
            }
        }
        require(success, "pairing-mul-failed");
    }

    /// @return the result of computing the pairing check
    /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1
    /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should
    /// return true.
    function pairing(G1Point[] memory p1, G2Point[] memory p2)
        internal
        view
        returns (bool)
    {
        require(p1.length == p2.length, "pairing-lengths-failed");
        uint256 elements = p1.length;
        uint256 inputSize = elements * 6;
        uint256[] memory input = new uint256[](inputSize);
        for (uint256 i = 0; i < elements; i++) {
            input[i * 6 + 0] = p1[i].x;
            input[i * 6 + 1] = p1[i].y;
            input[i * 6 + 2] = p2[i].x[0];
            input[i * 6 + 3] = p2[i].x[1];
            input[i * 6 + 4] = p2[i].y[0];
            input[i * 6 + 5] = p2[i].y[1];
        }
        uint256[1] memory out;
        bool success;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            success := staticcall(
                sub(gas(), 2000),
                8,
                add(input, 0x20),
                mul(inputSize, 0x20),
                out,
                0x20
            )
            // Use "invalid" to make gas estimation work
            switch success
            case 0 {
                invalid()
            }
        }
        require(success, "pairing-opcode-failed");
        return out[0] != 0;
    }

    /// Convenience method for a pairing check for four pairs.
    function pairingProd4(
        G1Point memory a1,
        G2Point memory a2,
        G1Point memory b1,
        G2Point memory b2,
        G1Point memory c1,
        G2Point memory c2,
        G1Point memory d1,
        G2Point memory d2
    ) internal view returns (bool) {
        G1Point[] memory p1 = new G1Point[](4);
        G2Point[] memory p2 = new G2Point[](4);
        p1[0] = a1;
        p1[1] = b1;
        p1[2] = c1;
        p1[3] = d1;
        p2[0] = a2;
        p2[1] = b2;
        p2[2] = c2;
        p2[3] = d2;
        return pairing(p1, p2);
    }
}

// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
// solhint-disable var-name-mixedcase
pragma solidity ^0.8.16;

// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash
uint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

// @dev Field prime of alt_bn128
uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
pragma solidity ^0.8.16;

import { VerifyingKey } from "../../common/Types.sol";
import "./IVerifier.sol";

interface IPantherVerifier is IVerifier {
    /**
     * @notice Get the verifying key for the specified circuits
     * @param circuitId ID of the circuit
     * @dev circuitId is an address where the key is deployed as bytecode
     * @return Verifying key
     */
    function getVerifyingKey(uint160 circuitId)
        external
        view
        returns (VerifyingKey memory);
}

// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
pragma solidity ^0.8.16;

import { SnarkProof } from "../../common/Types.sol";
import "./IVerifier.sol";

interface IVerifier {
    /**
     * @notice Verify the SNARK proof
     * @param circuitId ID of the circuit (it tells which verifying key to use)
     * @param input Public input signals
     * @param proof SNARK proof
     * @return isVerified bool true if proof is valid
     */
    function verify(
        uint160 circuitId,
        uint256[] memory input,
        SnarkProof memory proof
    ) external view returns (bool isVerified);
}

// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
pragma solidity ^0.8.16;

import "../common/Bytecode.sol";
import { VerifyingKey } from "../common/Types.sol";
import "./pantherVerifier/Verifier.sol";
import "./interfaces/IPantherVerifier.sol";

contract PantherVerifier is Verifier, IPantherVerifier {
    /// @inheritdoc IPantherVerifier
    function getVerifyingKey(uint160 circuitId)
        external
        view
        override
        returns (VerifyingKey memory)
    {
        return loadVerifyingKey(circuitId);
    }

    /// @dev It reads the verifying key from bytecode at `address(circuitId)`
    function loadVerifyingKey(uint160 circuitId)
        internal
        view
        virtual
        override
        returns (VerifyingKey memory)
    {
        return
            // Stored key MUST be `abi.encode`d and prepended by 0x00
            abi.decode(
                Bytecode.read(address(circuitId), DATA_OFFSET),
                (VerifyingKey)
            );
    }

    // Keys in deployed bytecode MUST be prepended by 0x00 (STOP opcode)
    uint256 private constant DATA_OFFSET = 1;
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.16;

import { SnarkProof, VerifyingKey } from "../../common/Types.sol";
import "../interfaces/IVerifier.sol";
import "../crypto/EllipticCurveMath.sol";
import { FIELD_SIZE } from "../crypto/SnarkConstants.sol";

/// @dev This is slightly modified code generated by the `snarkjs` lib (v.0.6.9).
abstract contract Verifier is EllipticCurveMath, IVerifier {
    /// @inheritdoc IVerifier
    function verify(
        uint160 circuitId,
        uint256[] memory input,
        SnarkProof memory proof
    ) public view override returns (bool isVerified) {
        VerifyingKey memory vk = loadVerifyingKey(circuitId);
        require(input.length + 1 == vk.ic.length, "verifier-bad-input");

        // Compute the linear combination vk_x
        G1Point memory vk_x = G1Point(0, 0);
        for (uint256 i = 0; i < input.length; i++) {
            require(input[i] < FIELD_SIZE, "verifier-gte-snark-scalar-field");
            vk_x = addition(vk_x, scalar_mul(vk.ic[i + 1], input[i]));
        }
        vk_x = addition(vk_x, vk.ic[0]);

        isVerified = pairingProd4(
            negate(proof.a),
            proof.b,
            vk.alfa1,
            vk.beta2,
            vk_x,
            vk.gamma2,
            proof.c,
            vk.delta2
        );
    }

    function loadVerifyingKey(uint160 circuitId)
        internal
        view
        virtual
        returns (VerifyingKey memory);
}