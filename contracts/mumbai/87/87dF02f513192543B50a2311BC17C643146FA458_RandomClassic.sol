// SPDX-License-Identifier: MIT

pragma solidity ^0.8.16;
import "./AccessControl.sol";

contract RandomClassic is AccessControl {
    // The random result generated by the `createRandomNumber` function
    uint256 public randomResult;

    // The timestamp of the last time a random number was generated
    uint256 private lastTimeRandom;

    // The time interval (in seconds) between generating random numbers
    uint256 private genInterval;

    constructor() {
        // Initialize the last time a random number was generated to the current timestamp
        lastTimeRandom = block.timestamp;
        // Set the generation interval to 12 seconds
        genInterval = 1;
        // Set the contract deployer as the owner
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(RANDOM_NUMBER_FLAG, msg.sender);
        _grantRole(UPDATER_FEE_RANDOM, msg.sender);
        _grantRole(CLAIM_TOKEN_FLAG, msg.sender);
    }

    bytes32 public constant RANDOM_NUMBER_FLAG = keccak256("RANDOM_NUMBER_FLAG"); 
    bytes32 public constant UPDATER_FEE_RANDOM = keccak256("UPDATER_FEE_RANDOM"); 
    bytes32 public constant CLAIM_TOKEN_FLAG = keccak256("CLAIM_TOKEN_FLAG"); 

    /**
    * This function is used to check if a given reward limit is greater than 0, 
    * and returns a random number within the limit.
    */
    function createRandomNumberOnlyTime(uint256 _randomWithLimitValue) public onlyRole(RANDOM_NUMBER_FLAG) {
        require(_randomWithLimitValue > 0, "THE REWARD IS OVER.");
        /**
        * This function generates a random number using the keccak256 h_isRandomOnlyTime &&ashing algorithm
        * It takes in parameters including the current timestamp, difficulty level, coinbase address, and block number
        * It then calculates a hash value using the keccak256 algorithm, and returns the modulus of that value with the given limit
        * This ensures that the random value falls within the range of 1 to the given limit (inclusive)
        * The returned value is the generated random number
        */
        uint256 firstRandomValue = uint256(
            keccak256(
                abi.encodePacked(block.timestamp, block.difficulty, block.coinbase, block.number, blockhash(block.number - 1))
            )
        ) % _randomWithLimitValue;
        
        if( block.timestamp - lastTimeRandom > genInterval) {
            randomResult = firstRandomValue + 1;
            lastTimeRandom = block.timestamp;
        }
    } 

    /**
    * This function is used to check if a given reward limit is greater than 0, 
    * and returns a random number within the limit.
    */
    function createRandomNumberMultipleTime(uint256 _randomWithLimitValue) public view onlyRole(RANDOM_NUMBER_FLAG) returns(uint256){
        require(_randomWithLimitValue > 0, "THE REWARD IS OVER.");
        /**
        * This function generates a random number using the keccak256 h_isRandomOnlyTime &&ashing algorithm
        * It takes in parameters including the current timestamp, difficulty level, coinbase address, and block number
        * It then calculates a hash value using the keccak256 algorithm, and returns the modulus of that value with the given limit
        * This ensures that the random value falls within the range of 1 to the given limit (inclusive)
        * The returned value is the generated random number
        */
        uint256 firstRandomValue = uint256(
            keccak256(
                abi.encodePacked(block.timestamp, block.difficulty, block.coinbase, block.number)
            )
        ) % _randomWithLimitValue;

        return firstRandomValue + 1;
    }
    
    /**
    * @dev Sets the generation interval for creating random numbers.
    * @param _genInterval The new generation interval to set.
    * Requirements:
    * The caller must be the contract owner.
    */
    function setGenInterval(uint256 _genInterval) external onlyRole(DEFAULT_ADMIN_ROLE) {
        genInterval = _genInterval;
    }
}