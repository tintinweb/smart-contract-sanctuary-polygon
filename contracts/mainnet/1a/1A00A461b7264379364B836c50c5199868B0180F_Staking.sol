/**
 *Submitted for verification at polygonscan.com on 2023-07-10
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Staking
*/

interface Nft_SSOPass{
	function balanceOf(address owner) external view returns (uint256);
}

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Staking {

	address owner;
	uint256 public principalAmtInBank = uint256(0);
	struct record1 { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(address => record1) public informationAboutStakeScheme1;
	mapping(uint256 => address) public addressStore1;
	uint256 public numberOfAddressesCurrentlyStaked1 = uint256(0);
	uint256 public totalWithdrawals1 = uint256(0);
	struct record2 { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(address => record2) public informationAboutStakeScheme2;
	mapping(uint256 => address) public addressStore2;
	uint256 public numberOfAddressesCurrentlyStaked2 = uint256(0);
	uint256 public totalWithdrawals2 = uint256(0);
	struct record3 { uint256 stakeTime; uint256 stakeAmt; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; }
	mapping(address => record3) public informationAboutStakeScheme3;
	mapping(uint256 => address) public addressStore3;
	uint256 public numberOfAddressesCurrentlyStaked3 = uint256(0);
	uint256 public totalWithdrawals3 = uint256(0);
	event Staked (address indexed account);
	event Unstaked (address indexed account);

	constructor() {
		owner = 0xBDCBD23316AAA2aDecA774e107868adCE38cC69E;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function minUIntPair(uint _i, uint _j) internal pure returns (uint){
		if (_i < _j){
			return _i;
		}else{
			return _j;
		}
	}

/**
 * Function stake1
 * Daily Interest Rate : 0.2
 * Address Map : informationAboutStakeScheme1
 * The function takes in 1 variable, (zero or a positive integer) _stakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that _stakeAmt is strictly greater than 0
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element the address that called this function
 * if (thisRecord with element stakeAmt) is equals to 0 then (updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising current time, _stakeAmt, current time, 0, 0; then updates addressStore1 (Element numberOfAddressesCurrentlyStaked1) as the address that called this function; and then updates numberOfAddressesCurrentlyStaked1 as (numberOfAddressesCurrentlyStaked1) + (1)) otherwise (updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising current time, ((thisRecord with element stakeAmt) + (_stakeAmt)), current time, ((thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((10000) * (864)))) - (thisRecord with element lastUpdateTime)) * (2000)) / (86400000000))), (thisRecord with element amtWithdrawn))
 * calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _stakeAmt
 * emits event Staked with inputs the address that called this function
*/
	function stake1(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record1 memory thisRecord = informationAboutStakeScheme1[msg.sender];
		if ((thisRecord.stakeAmt == uint256(0))){
			informationAboutStakeScheme1[msg.sender]  = record1 (block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
			addressStore1[numberOfAddressesCurrentlyStaked1]  = msg.sender;
			numberOfAddressesCurrentlyStaked1  = (numberOfAddressesCurrentlyStaked1 + uint256(1));
		}else{
			informationAboutStakeScheme1[msg.sender]  = record1 (block.timestamp, (thisRecord.stakeAmt + _stakeAmt), block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(10000) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(2000)) / uint256(86400000000))), thisRecord.amtWithdrawn);
		}
		ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transferFrom(msg.sender, address(this), _stakeAmt);
		emit Staked(msg.sender);
	}

/**
 * Function unstake1
 * The function takes in 1 variable, (zero or a positive integer) _unstakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element the address that called this function
 * checks that _unstakeAmt is less than or equals to (thisRecord with element stakeAmt)
 * creates an internal variable newAccum with initial value (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((10000) * (864)))) - (thisRecord with element lastUpdateTime)) * (2000)) / (86400000000))
 * creates an internal variable interestToRemove with initial value ((newAccum) * (_unstakeAmt)) / (thisRecord with element stakeAmt)
 * updates principalAmtInBank as (principalAmtInBank) + (((_unstakeAmt) * (1000000) * (100)) / (100000000))
 * if _unstakeAmt is equals to (thisRecord with element stakeAmt) then (repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (if (addressStore1 with element Loop Variable i0) is equals to (the address that called this function) then (updates addressStore1 (Element Loop Variable i0) as addressStore1 with element (numberOfAddressesCurrentlyStaked1) - (1); then updates numberOfAddressesCurrentlyStaked1 as (numberOfAddressesCurrentlyStaked1) - (1); and then terminates the for-next loop)))
 * updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), ((thisRecord with element stakeAmt) - (_unstakeAmt)), current time, ((newAccum) - (interestToRemove)), ((thisRecord with element amtWithdrawn) + (interestToRemove))
 * emits event Unstaked with inputs the address that called this function
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as interestToRemove)
 * checks that (ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000))
 * if (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000)) is strictly greater than 0 then (calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000)))
 * updates totalWithdrawals1 as (totalWithdrawals1) + (interestToRemove)
*/
	function unstake1(uint256 _unstakeAmt) public {
		record1 memory thisRecord = informationAboutStakeScheme1[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(10000) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(2000)) / uint256(86400000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		principalAmtInBank  = (principalAmtInBank + ((_unstakeAmt * uint256(1000000) * uint256(100)) / uint256(100000000)));
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
				if ((addressStore1[i0] == msg.sender)){
					addressStore1[i0]  = addressStore1[(numberOfAddressesCurrentlyStaked1 - uint256(1))];
					numberOfAddressesCurrentlyStaked1  = (numberOfAddressesCurrentlyStaked1 - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme1[msg.sender]  = record1 (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove), (thisRecord.amtWithdrawn + interestToRemove));
		emit Unstaked(msg.sender);
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= interestToRemove), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((interestToRemove > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, interestToRemove);
		}
		require((ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).balanceOf(address(this)) >= ((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000)) > uint256(0))){
			ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transfer(msg.sender, ((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000)));
		}
		totalWithdrawals1  = (totalWithdrawals1 + interestToRemove);
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element _address
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((10000) * (864)))) - (thisRecord with element lastUpdateTime)) * (2000)) / (86400000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(address _address) public view returns (uint256) {
		record1 memory thisRecord = informationAboutStakeScheme1[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(10000) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(2000)) / uint256(86400000000)));
	}

/**
 * Function totalStakedAmount1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element addressStore1 with element Loop Variable i0; and then updates total as (total) + (thisRecord with element stakeAmt))
 * returns total as output
*/
	function totalStakedAmount1() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
			record1 memory thisRecord = informationAboutStakeScheme1[addressStore1[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

/**
 * Function totalAccumulatedInterest1
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked1 times with loop variable i0 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _address as (addressStore1 with element Loop Variable i0)))
 * returns total as output
*/
	function totalAccumulatedInterest1() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked1; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(addressStore1[i0]));
		}
		return total;
	}

/**
 * Function withdrawInterestWithoutUnstaking1
 * The function takes in 1 variable, (zero or a positive integer) _withdrawalAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _address as (the address that called this function)
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme1 with element the address that called this function
 * updates informationAboutStakeScheme1 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), (thisRecord with element stakeAmt), (minimum of current time, ((thisRecord with element stakeTime) + ((10000) * (864)))), ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals1 as (totalWithdrawals1) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking1(uint256 _withdrawalAmt) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(msg.sender);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record1 memory thisRecord = informationAboutStakeScheme1[msg.sender];
		informationAboutStakeScheme1[msg.sender]  = record1 (thisRecord.stakeTime, thisRecord.stakeAmt, minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(10000) * uint256(864)))), (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals1  = (totalWithdrawals1 + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestWithoutUnstaking1
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking1 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1 with variable _address as (the address that called this function))
*/
	function withdrawAllInterestWithoutUnstaking1() external {
		withdrawInterestWithoutUnstaking1(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn1(msg.sender));
	}

/**
 * Function stake2
 * Daily Interest Rate : 0.11
 * Address Map : informationAboutStakeScheme2
 * The function takes in 1 variable, (zero or a positive integer) _stakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that _stakeAmt is strictly greater than 0
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element the address that called this function
 * if (thisRecord with element stakeAmt) is equals to 0 then (updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising current time, _stakeAmt, current time, 0, 0; then updates addressStore2 (Element numberOfAddressesCurrentlyStaked2) as the address that called this function; and then updates numberOfAddressesCurrentlyStaked2 as (numberOfAddressesCurrentlyStaked2) + (1)) otherwise (updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising current time, ((thisRecord with element stakeAmt) + (_stakeAmt)), current time, ((thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((36500) * (864)))) - (thisRecord with element lastUpdateTime)) * (1100)) / (86400000000))), (thisRecord with element amtWithdrawn))
 * calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _stakeAmt
 * emits event Staked with inputs the address that called this function
*/
	function stake2(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record2 memory thisRecord = informationAboutStakeScheme2[msg.sender];
		if ((thisRecord.stakeAmt == uint256(0))){
			informationAboutStakeScheme2[msg.sender]  = record2 (block.timestamp, _stakeAmt, block.timestamp, uint256(0), uint256(0));
			addressStore2[numberOfAddressesCurrentlyStaked2]  = msg.sender;
			numberOfAddressesCurrentlyStaked2  = (numberOfAddressesCurrentlyStaked2 + uint256(1));
		}else{
			informationAboutStakeScheme2[msg.sender]  = record2 (block.timestamp, (thisRecord.stakeAmt + _stakeAmt), block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(36500) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(1100)) / uint256(86400000000))), thisRecord.amtWithdrawn);
		}
		ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transferFrom(msg.sender, address(this), _stakeAmt);
		emit Staked(msg.sender);
	}

/**
 * Function unstake2
 * The function takes in 1 variable, (zero or a positive integer) _unstakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element the address that called this function
 * checks that _unstakeAmt is less than or equals to (thisRecord with element stakeAmt)
 * creates an internal variable newAccum with initial value (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((36500) * (864)))) - (thisRecord with element lastUpdateTime)) * (1100)) / (86400000000))
 * creates an internal variable interestToRemove with initial value ((newAccum) * (_unstakeAmt)) / (thisRecord with element stakeAmt)
 * updates principalAmtInBank as (principalAmtInBank) + (((_unstakeAmt) * (1000000) * (100)) / (100000000))
 * if _unstakeAmt is equals to (thisRecord with element stakeAmt) then (repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (if (addressStore2 with element Loop Variable i0) is equals to (the address that called this function) then (updates addressStore2 (Element Loop Variable i0) as addressStore2 with element (numberOfAddressesCurrentlyStaked2) - (1); then updates numberOfAddressesCurrentlyStaked2 as (numberOfAddressesCurrentlyStaked2) - (1); and then terminates the for-next loop)))
 * updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), ((thisRecord with element stakeAmt) - (_unstakeAmt)), current time, ((newAccum) - (interestToRemove)), ((thisRecord with element amtWithdrawn) + (interestToRemove))
 * emits event Unstaked with inputs the address that called this function
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as interestToRemove)
 * checks that (ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000))
 * if (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000)) is strictly greater than 0 then (calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000)))
 * updates totalWithdrawals2 as (totalWithdrawals2) + (interestToRemove)
*/
	function unstake2(uint256 _unstakeAmt) public {
		record2 memory thisRecord = informationAboutStakeScheme2[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(36500) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(1100)) / uint256(86400000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		principalAmtInBank  = (principalAmtInBank + ((_unstakeAmt * uint256(1000000) * uint256(100)) / uint256(100000000)));
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
				if ((addressStore2[i0] == msg.sender)){
					addressStore2[i0]  = addressStore2[(numberOfAddressesCurrentlyStaked2 - uint256(1))];
					numberOfAddressesCurrentlyStaked2  = (numberOfAddressesCurrentlyStaked2 - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme2[msg.sender]  = record2 (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove), (thisRecord.amtWithdrawn + interestToRemove));
		emit Unstaked(msg.sender);
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= interestToRemove), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((interestToRemove > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, interestToRemove);
		}
		require((ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).balanceOf(address(this)) >= ((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000)) > uint256(0))){
			ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transfer(msg.sender, ((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000)));
		}
		totalWithdrawals2  = (totalWithdrawals2 + interestToRemove);
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element _address
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((36500) * (864)))) - (thisRecord with element lastUpdateTime)) * (1100)) / (86400000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(address _address) public view returns (uint256) {
		record2 memory thisRecord = informationAboutStakeScheme2[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(36500) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(1100)) / uint256(86400000000)));
	}

/**
 * Function totalStakedAmount2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element addressStore2 with element Loop Variable i0; and then updates total as (total) + (thisRecord with element stakeAmt))
 * returns total as output
*/
	function totalStakedAmount2() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
			record2 memory thisRecord = informationAboutStakeScheme2[addressStore2[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

/**
 * Function totalAccumulatedInterest2
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked2 times with loop variable i0 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _address as (addressStore2 with element Loop Variable i0)))
 * returns total as output
*/
	function totalAccumulatedInterest2() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked2; i0++){
			total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(addressStore2[i0]));
		}
		return total;
	}

/**
 * Function withdrawInterestWithoutUnstaking2
 * The function takes in 1 variable, (zero or a positive integer) _withdrawalAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _address as (the address that called this function)
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme2 with element the address that called this function
 * updates informationAboutStakeScheme2 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), (thisRecord with element stakeAmt), (minimum of current time, ((thisRecord with element stakeTime) + ((36500) * (864)))), ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals2 as (totalWithdrawals2) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking2(uint256 _withdrawalAmt) public {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(msg.sender);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record2 memory thisRecord = informationAboutStakeScheme2[msg.sender];
		informationAboutStakeScheme2[msg.sender]  = record2 (thisRecord.stakeTime, thisRecord.stakeAmt, minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(36500) * uint256(864)))), (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals2  = (totalWithdrawals2 + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestWithoutUnstaking2
 * The function takes in 0 variables. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking2 with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2 with variable _address as (the address that called this function))
*/
	function withdrawAllInterestWithoutUnstaking2() external {
		withdrawInterestWithoutUnstaking2(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn2(msg.sender));
	}

/**
 * Function stake3
 * Daily Interest Rate : 0.22
 * Address Map : informationAboutStakeScheme3
 * The function takes in 1 variable, (zero or a positive integer) _stakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that _stakeAmt is strictly greater than 0
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme3 with element the address that called this function
 * if (thisRecord with element stakeAmt) is equals to 0 then (updates informationAboutStakeScheme3 (Element the address that called this function) as Struct comprising current time, _stakeAmt, current time, 0; then updates addressStore3 (Element numberOfAddressesCurrentlyStaked3) as the address that called this function; and then updates numberOfAddressesCurrentlyStaked3 as (numberOfAddressesCurrentlyStaked3) + (1)) otherwise (updates informationAboutStakeScheme3 (Element the address that called this function) as Struct comprising current time, ((thisRecord with element stakeAmt) + (_stakeAmt)), current time, ((thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((30000) * (864)))) - (thisRecord with element lastUpdateTime)) * (2200)) / (86400000000))))
 * calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _stakeAmt
 * checks that (Contract with variables (the address that called this function)) is strictly greater than 0
 * emits event Staked with inputs the address that called this function
*/
	function stake3(uint256 _stakeAmt) public {
		require((_stakeAmt > uint256(0)), "Staked amount needs to be greater than 0");
		record3 memory thisRecord = informationAboutStakeScheme3[msg.sender];
		if ((thisRecord.stakeAmt == uint256(0))){
			informationAboutStakeScheme3[msg.sender]  = record3 (block.timestamp, _stakeAmt, block.timestamp, uint256(0));
			addressStore3[numberOfAddressesCurrentlyStaked3]  = msg.sender;
			numberOfAddressesCurrentlyStaked3  = (numberOfAddressesCurrentlyStaked3 + uint256(1));
		}else{
			informationAboutStakeScheme3[msg.sender]  = record3 (block.timestamp, (thisRecord.stakeAmt + _stakeAmt), block.timestamp, (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(30000) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(2200)) / uint256(86400000000))));
		}
		ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transferFrom(msg.sender, address(this), _stakeAmt);
		require((Nft_SSOPass(0xDa688ebF6B0cAa9C166fAB3F080975fF573Aa93a).balanceOf(msg.sender) > uint256(0)), "You must hold a StarSeeds Original Pass to use this option. ");
		emit Staked(msg.sender);
	}

/**
 * Function unstake3
 * The function takes in 1 variable, (zero or a positive integer) _unstakeAmt. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme3 with element the address that called this function
 * checks that _unstakeAmt is less than or equals to (thisRecord with element stakeAmt)
 * creates an internal variable newAccum with initial value (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((30000) * (864)))) - (thisRecord with element lastUpdateTime)) * (2200)) / (86400000000))
 * creates an internal variable interestToRemove with initial value ((newAccum) * (_unstakeAmt)) / (thisRecord with element stakeAmt)
 * updates principalAmtInBank as (principalAmtInBank) + (((_unstakeAmt) * (1000000) * (100)) / (100000000))
 * if _unstakeAmt is equals to (thisRecord with element stakeAmt) then (repeat numberOfAddressesCurrentlyStaked3 times with loop variable i0 :  (if (addressStore3 with element Loop Variable i0) is equals to (the address that called this function) then (updates addressStore3 (Element Loop Variable i0) as addressStore3 with element (numberOfAddressesCurrentlyStaked3) - (1); then updates numberOfAddressesCurrentlyStaked3 as (numberOfAddressesCurrentlyStaked3) - (1); and then terminates the for-next loop)))
 * updates informationAboutStakeScheme3 (Element the address that called this function) as Struct comprising (thisRecord with element stakeTime), ((thisRecord with element stakeAmt) - (_unstakeAmt)), current time, ((newAccum) - (interestToRemove))
 * emits event Unstaked with inputs the address that called this function
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as interestToRemove)
 * checks that (ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000))
 * if (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000)) is strictly greater than 0 then (calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transfer function  with variable recipient as (the address that called this function), variable amount as (((_unstakeAmt) * ((1000000) - (1000000))) / (1000000)))
 * updates totalWithdrawals3 as (totalWithdrawals3) + (interestToRemove)
*/
	function unstake3(uint256 _unstakeAmt) public {
		record3 memory thisRecord = informationAboutStakeScheme3[msg.sender];
		require((_unstakeAmt <= thisRecord.stakeAmt), "Withdrawing more than staked amount");
		uint256 newAccum = (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(30000) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(2200)) / uint256(86400000000)));
		uint256 interestToRemove = ((newAccum * _unstakeAmt) / thisRecord.stakeAmt);
		principalAmtInBank  = (principalAmtInBank + ((_unstakeAmt * uint256(1000000) * uint256(100)) / uint256(100000000)));
		if ((_unstakeAmt == thisRecord.stakeAmt)){
			for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked3; i0++){
				if ((addressStore3[i0] == msg.sender)){
					addressStore3[i0]  = addressStore3[(numberOfAddressesCurrentlyStaked3 - uint256(1))];
					numberOfAddressesCurrentlyStaked3  = (numberOfAddressesCurrentlyStaked3 - uint256(1));
					break;
				}
			}
		}
		informationAboutStakeScheme3[msg.sender]  = record3 (thisRecord.stakeTime, (thisRecord.stakeAmt - _unstakeAmt), block.timestamp, (newAccum - interestToRemove));
		emit Unstaked(msg.sender);
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= interestToRemove), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((interestToRemove > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, interestToRemove);
		}
		require((ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).balanceOf(address(this)) >= ((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000)) > uint256(0))){
			ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transfer(msg.sender, ((_unstakeAmt * (uint256(1000000) - uint256(1000000))) / uint256(1000000)));
		}
		totalWithdrawals3  = (totalWithdrawals3 + interestToRemove);
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn3
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme3 with element _address
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + (((thisRecord with element stakeAmt) * ((minimum of current time, ((thisRecord with element stakeTime) + ((30000) * (864)))) - (thisRecord with element lastUpdateTime)) * (2200)) / (86400000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn3(address _address) public view returns (uint256) {
		record3 memory thisRecord = informationAboutStakeScheme3[_address];
		return (thisRecord.accumulatedInterestToUpdateTime + ((thisRecord.stakeAmt * (minUIntPair(block.timestamp, (thisRecord.stakeTime + (uint256(30000) * uint256(864)))) - thisRecord.lastUpdateTime) * uint256(2200)) / uint256(86400000000)));
	}

/**
 * Function totalStakedAmount3
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat numberOfAddressesCurrentlyStaked3 times with loop variable i0 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme3 with element addressStore3 with element Loop Variable i0; and then updates total as (total) + (thisRecord with element stakeAmt))
 * returns total as output
*/
	function totalStakedAmount3() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < numberOfAddressesCurrentlyStaked3; i0++){
			record3 memory thisRecord = informationAboutStakeScheme3[addressStore3[i0]];
			total  = (total + thisRecord.stakeAmt);
		}
		return total;
	}

/**
 * Function principalTaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to principalAmtInBank
 * if principalAmtInBank is strictly greater than 0 then (calls ERC20(Address 0x17840DF7CAa07e298b16E8612157B90ED231C973)'s at transfer function  with variable recipient as (the address that called this function), variable amount as principalAmtInBank)
 * updates principalAmtInBank as 0
*/
	function principalTaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).balanceOf(address(this)) >= principalAmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((principalAmtInBank > uint256(0))){
			ERC20(address(0x17840DF7CAa07e298b16E8612157B90ED231C973)).transfer(msg.sender, principalAmtInBank);
		}
		principalAmtInBank  = uint256(0);
	}

/**
 * Function withdrawToken
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (totalAccumulatedInterest1) + (totalAccumulatedInterest2))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawToken(uint256 _amt) public onlyOwner {
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= (_amt + totalAccumulatedInterest1() + totalAccumulatedInterest2())), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, _amt);
		}
	}
}