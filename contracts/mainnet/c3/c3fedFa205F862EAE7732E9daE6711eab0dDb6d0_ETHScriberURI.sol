// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

error EmptyDataField();
error InvalidFunctionCall(bytes response);
error NonExistantContractOrToken(address addr, uint256 tokenId);
error NotEnoughETHProvided(uint256 value);

interface ITokenURI {
    /**
     * @dev Returns the token URI for a given token ID
     * @param tokenId The token ID to return the URI for
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

/**
 * @title ETHScriberURI
 * @author @ownerlessInc
 * @notice This contract is just a study case of the development of the Ethscriptions
 * initiative. Use as you wish, but be aware that this is not a production ready contract.
 * Rather than that, it's a proof of concept that can be used as a base for further
 * developments. Any transactions will be considered donations
 */
contract ETHScriberURI {
    // Global address of the Ethscriber contract
    address public constant ETHSCRIBER =
        0xD15EBb0658DC90D30A4256Da8A891B6A89f7cc4D;

    // Price of the Inscription
    uint256 public constant price = 0.001 ether;

    // Owner of the contract
    address public immutable owner;

    // Constructor
    constructor() {
        owner = msg.sender;
    }

    /**
     * @dev This function is used to ethscribe NFTs from contracts that implement the
     * `tokenURI(uint256)` function, which is part of the ERC721 standard.
     *
     * We send a transaction to the Ethscriber contract with the tokenURI as `msg.data`.
     * The Ethscriber will send us back a modified `msg.data` with a blackspace in front,
     * which determines that this ethscriptions was generated using internal transactions.
     *
     * IMPORTANT! Blank spaces won't alter the visibility of the Ethscriptions in the
     * indexers, that is because all compilers ignore the `0x20`which representes a blank
     * space. We can say the ethscription will belong to the caller of the contract, because
     * the Ethscriber contract will send the caller a transaction containing the modified
     * `msg.data`. The standard is yet uncertain, but following the msg.data field being the
     * ethscription itself, we can say that the ethscription will belong to the caller.
     * It's fun to realize that a lot of ethscriptions were already made before, but it will
     * very costly to investigate such chained events in the past blocks.
     *
     * Requirements:
     * - The contract that holds the NFT must implement the `tokenURI(uint256)` function.
     * - The contract that holds the NFT must be deployed on the same network as the Ethscriber.
     * - Price for the inscription must be provided.
     *
     * @param _addr The address of the contract that holds the desired NFT.
     * @param _tokenId The ID of the NFT to be ethscribed.
     */
    function ethscribe(address _addr, uint256 _tokenId) public payable {
        if (msg.value < price) revert NotEnoughETHProvided(msg.value);

        try ITokenURI(_addr).tokenURI(_tokenId) returns (
            string memory tokenURI
        ) {
            _ethscribe(tokenURI);
        } catch {
            revert NonExistantContractOrToken(_addr, _tokenId);
        }
    }

    /**
     * @dev This internal function will ethscribe an existing NFT to the data field
     * of the transaction hash generated by the caller.
     * @param _tokenURI The token URI of the NFT to be ethscribed.
     */
    function _ethscribe(string memory _tokenURI) internal {
        (bool sent, bytes memory response) = address(ETHSCRIBER).delegatecall(
            bytes(_tokenURI)
        );
        if (!sent) revert InvalidFunctionCall(response);
    }

    /**
     * @dev This function is used withdraw funds from the contract.
     */
    function withdraw() public {
        address(owner).call{value: address(this).balance}("");
    }

    /* Receive ETH */
    receive() external payable {}
}