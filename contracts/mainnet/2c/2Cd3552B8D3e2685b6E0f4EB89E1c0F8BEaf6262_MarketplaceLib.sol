// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "./IIdentity.sol";

interface IClaimIssuer is IIdentity {
    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);
    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);
    function isClaimRevoked(bytes calldata _sig) external view returns (bool);
    function isClaimValid(IIdentity _identity, uint256 claimTopic, bytes calldata sig, bytes calldata data) external view returns (bool);
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

/**
 * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.
 */
interface IERC734 {

    /**
     * @dev Emitted when an execution request was approved.
     *
     * Specification: MUST be triggered when approve was successfully called.
     */
    event Approved(uint256 indexed executionId, bool approved);

    /**
     * @dev Emitted when an execute operation was approved and successfully performed.
     *
     * Specification: MUST be triggered when approve was called and the execution was successfully approved.
     */
    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);

    /**
     * @dev Emitted when an execution request was performed via `execute`.
     *
     * Specification: MUST be triggered when execute was successfully called.
     */
    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);

    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);

    /**
     * @dev Emitted when a key was added to the Identity.
     *
     * Specification: MUST be triggered when addKey was successfully called.
     */
    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);

    /**
     * @dev Emitted when a key was removed from the Identity.
     *
     * Specification: MUST be triggered when removeKey was successfully called.
     */
    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);

    /**
     * @dev Emitted when the list of required keys to perform an action was updated.
     *
     * Specification: MUST be triggered when changeKeysRequired was successfully called.
     */
    event KeysRequiredChanged(uint256 purpose, uint256 number);


    /**
     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.
     *
     * Triggers Event: `KeyAdded`
     *
     * Specification: MUST only be done by keys of purpose 1, or the identity itself. If it's the identity itself, the approval process will determine its approval.
     */
    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);

    /**
    * @dev Approves an execution or claim addition.
    *
    * Triggers Event: `Approved`, `Executed`
    *
    * Specification:
    * This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution.
    * And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.
    */
    function approve(uint256 _id, bool _approve) external returns (bool success);

    /**
     * @dev Passes an execution instruction to an ERC725 identity.
     *
     * Triggers Event: `ExecutionRequested`, `Executed`
     *
     * Specification:
     * SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution.
     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.
     */
    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);

    /**
     * @dev Returns the full key data, if present in the identity.
     */
    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);

    /**
     * @dev Returns the list of purposes associated with a key.
     */
    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);

    /**
     * @dev Returns an array of public key bytes32 held by this identity.
     */
    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);

    /**
     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.
     */
    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);

    /**
     * @dev Removes _purpose for _key from the identity.
     *
     * Triggers Event: `KeyRemoved`
     *
     * Specification: MUST only be done by keys of purpose 1, or the identity itself. If it's the identity itself, the approval process will determine its approval.
     */
    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

/**
 * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.
 */
interface IERC735 {

    /**
     * @dev Emitted when a claim request was performed.
     *
     * Specification: Is not clear
     */
    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);

    /**
     * @dev Emitted when a claim was added.
     *
     * Specification: MUST be triggered when a claim was successfully added.
     */
    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);

    /**
     * @dev Emitted when a claim was removed.
     *
     * Specification: MUST be triggered when removeClaim was successfully called.
     */
    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);

    /**
     * @dev Emitted when a claim was changed.
     *
     * Specification: MUST be triggered when changeClaim was successfully called.
     */
    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);

    /**
     * @dev Get a claim by its ID.
     *
     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.
     */
    function getClaim(bytes32 _claimId) external view returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);

    /**
     * @dev Returns an array of claim IDs by topic.
     */
    function getClaimIdsByTopic(uint256 _topic) external view returns(bytes32[] memory claimIds);

    /**
     * @dev Add or update a claim.
     *
     * Triggers Event: `ClaimRequested`, `ClaimAdded`, `ClaimChanged`
     *
     * Specification: Requests the ADDITION or the CHANGE of a claim from an issuer.
     * Claims can requested to be added by anybody, including the claim holder itself (self issued).
     *
     * _signature is a signed message of the following structure: `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.
     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.
     *
     * This COULD implement an approval process for pending claims, or add them right away.
     * MUST return a claimRequestId (use claim ID) that COULD be sent to the approve function.
     */
    function addClaim(uint256 _topic, uint256 _scheme, address issuer, bytes calldata _signature, bytes calldata _data, string calldata _uri) external returns (bytes32 claimRequestId);

    /**
     * @dev Removes a claim.
     *
     * Triggers Event: `ClaimRemoved`
     *
     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.
     */
    function removeClaim(bytes32 _claimId) external returns (bool success);
}

// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import "./IERC734.sol";
import "./IERC735.sol";

interface IIdentity is IERC734, IERC735 {}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/draft-IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.9;

// import {PropertyToken2} from "./propertyToken.sol";
// import {Identity} from "@onchain-id/solidity/contracts/Identity.sol";
// import {ImplementationAuthority} from "@onchain-id/solidity/contracts/proxy/ImplementationAuthority.sol";
// import {IdentityProxy} from "@onchain-id/solidity/contracts/proxy/IdentityProxy.sol";

/**
 * @title ZeroXInterfaces
 * @notice Stores common interface names used throughout 0xequity.
 */
library ZeroXInterfaces {
    bytes32 public constant RENT_SHARE = "RentShare";
    bytes32 public constant PRICE_FEED = "PriceFeed";
    bytes32 public constant PROPERTY_TOKEN = "PropertyToken";
    bytes32 public constant IDENTITY = "Identity";
    bytes32 public constant IMPLEMENTATION_AUTHORITY =
        "ImplementationAuthority";
    bytes32 public constant IDENTITY_PROXY = "IdentityProxy";
    bytes32 public constant MAINTAINER_ROLE = keccak256("Maintainer");
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 public constant REWARD_TOKEN = "RewardToken";
    bytes32 public constant SBT = "SBT";
    bytes32 public constant MARKETPLACE = "Marketplace";
    bytes32 public constant TRUSTED_FORWARDER = "TrustedForwarder";
    bytes32 public constant FEEMANAGER = "FeeManager";
    bytes32 public constant XEQ = "XEQ";
    bytes32 public constant OCLROUTER = "OCLRouter";
    bytes32 public constant XJTRY = "XJTRY";
    bytes32 public constant XUSDC = "XUSDC";
    bytes32 public constant SWAPCONTROLLER = "SwapController";
    bytes32 public constant JTRYVAULT = "ERC4626StakingPoolJTRY";
    bytes32 public constant CUSTOMVAULTJTRY = "CustomVaultJTRY";
    bytes32 public constant USDCVAULT = "ERC4626StakingPoolUSDC";
    bytes32 public constant CUSTOMVAULTUSDC = "CustomVaultUSDC";
    bytes32 public constant MANAGER = "Manager";
    bytes32 public constant DFX = "Dfx";
    bytes32 public constant JARVISDEX = "JarvisDex";
    bytes32 public constant TOKENSWHITELIST = "TokensWhitelist";
    bytes32 public constant USDC = "Usdc";
    bytes32 public constant VTRY = "Vtry";
}

// library ZeroXBtyeCodes {
//     bytes public constant PropertyToken = type(PropertyToken2).creationCode;
//     bytes public constant identity = type(Identity).creationCode;
//     bytes public constant implementationAuthority =
//         type(ImplementationAuthority).creationCode;
//     bytes public constant identityProxy = type(IdentityProxy).creationCode;
// }

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.9;

/**
 * @title Provides addresses of the contracts implementing certain interfaces.
 */
interface IFinder {
    /**
     * @notice Updates the address of the contract that implements `interfaceName`.
     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.
     * @param implementationAddress address of the deployed contract that implements the interface.
     */
    function changeImplementationAddress(
        bytes32 interfaceName,
        address implementationAddress
    ) external;

    /**
     * @notice Gets the address of the contract that implements the given `interfaceName`.
     * @param interfaceName queried interface.
     * @return implementationAddress Address of the deployed contract that implements the interface.
     */
    function getImplementationAddress(
        bytes32 interfaceName
    ) external view returns (address);

    function changeImplementationBytecode(
        bytes32 interfaceName,
        bytes calldata implementationBytecode
    ) external;

    function getImplementationBytecode(
        bytes32 interfaceName
    ) external view returns (bytes memory);
}

// SPDX-License-Identifier: GPL-3.0-or-later
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity 0.8.9;

// solhint-disable

/**
 * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are
 * supported.
 * Uses the default '0XEQ' prefix for the error code
 */
function _require(bool condition, uint256 errorCode) pure {
    if (!condition) _revert(errorCode);
}

/**
 * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.
 * Uses the default '0XEQ' prefix for the error code
 */
function _revert(uint256 errorCode) pure {
    _revert(errorCode, 0x584551); // This is the raw byte representation of "0XEQ"
}

/**
 * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.
 */
function _revert(uint256 errorCode, bytes3 prefix) pure {
    uint256 prefixUint = uint256(uint24(prefix));
    // We're going to dynamically create a revert string based on the error code, with the following format:
    // '0XEQ#{errorCode}'
    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).
    //
    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a
    // number (8 to 16 bits) than the individual string characters.
    //
    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a
    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a
    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.
    assembly {
        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999
        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for
        // the '0' character.

        let units := add(mod(errorCode, 10), 0x30)

        errorCode := div(errorCode, 10)
        let tenths := add(mod(errorCode, 10), 0x30)

        errorCode := div(errorCode, 10)
        let hundreds := add(mod(errorCode, 10), 0x30)

        // With the individual characters, we can now construct the full string.
        // We first append the '#' character (0x23) to the prefix. In the case of '0XEQ', it results in 0x584551 ('0XEQ#')
        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the
        // characters to it, each shifted by a multiple of 8.
        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits
        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte
        // array).
        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))

        let revertReason := shl(
            200,
            add(
                formattedPrefix,
                add(add(units, shl(8, tenths)), shl(16, hundreds))
            )
        )

        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded
        // message will have the following layout:
        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]

        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We
        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.
        mstore(
            0x0,
            0x08c379a000000000000000000000000000000000000000000000000000000000
        )
        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).
        mstore(
            0x04,
            0x0000000000000000000000000000000000000000000000000000000000000020
        )
        // The string length is fixed: 7 characters.
        mstore(0x24, 7)
        // Finally, the string itself is stored.
        mstore(0x44, revertReason)

        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of
        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.
        revert(0, 100)
    }
}

library Errors {
    // ACCESS CONTROL

    uint256 internal constant CALLER_NOT_ADMIN = 0;
    uint256 internal constant CALLER_NOT_MAINTAINER = 1;
    uint256 internal constant CALLER_NOT_MINTER = 2;
    uint256 internal constant CALLER_NOT_BURNER = 3;
    uint256 internal constant CALLER_NOT_MARKETPLACE = 4;
    uint256 internal constant CALLER_NOT_VAULT = 5;
    uint256 internal constant CALLER_NOT_MARKETPLACE_BORROWER = 6;

    // COMMON

    uint256 internal constant ARRAY_LENGTH_MISMATCH = 100;
    uint256 internal constant ZERO_ADDRESS = 101;
    uint256 internal constant ZERO_LENGTH_ARRAY = 102;
    uint256 internal constant ZERO_AMOUNT = 103;
    uint256 internal constant NON_ZERO_NUMBER_REQUIRED = 104;
    uint256 internal constant ERROR_IN_TRUST_FORWARDER_CALL = 105;
    uint256 internal constant SAFE_TRANSFER_FAILED = 106;
    uint256 internal constant SAFE_TRANSFER_FROM_FAILED = 107;
    uint256 internal constant SAFE_APPROVE_FAILED = 108;
    uint256 internal constant SAME_TOKENS = 109;
    uint256 internal constant NON_KYC = 110;
    uint256 internal constant INVALID_TOKEN = 111;
    uint256 internal constant RECEIVER_ON_BLACKLIST = 112;
    uint256 internal constant SENDER_ON_BLACKLIST = 113;

    // SBT

    uint256 internal constant CANT_MINT_TWICE = 200;
    uint256 internal constant WRONG_COMMUNITY_NAME = 201;
    uint256 internal constant TRANSFER_NOT_ALLOWED = 202;
    uint256 internal constant COMMUNITY_DOES_NOT_EXIST = 203;
    uint256 internal constant ALREADY_APPROVED_COMMUNITY = 204;
    uint256 internal constant INPUT_LENGTH_IS_GREATER_THAN_TOTAL = 205;

    // FINDER

    uint256 internal constant IMPLEMENTATION_NOT_FOUND = 300;
    uint256 internal constant EMPTY_BYTECODE = 301;

    // TOKENWHITELIST

    uint256 internal constant TOKEN_ALREADY_WHITELISTED = 400;
    uint256 internal constant TOKEN_NOT_WHITELISTED = 401;

    //MARKETPLACE

    uint256 internal constant ZERO_BALANCE = 500;
    uint256 internal constant PROPERTY_DOES_NOT_EXIST = 501;
    uint256 internal constant PROPERTY_ALREADY_EXIST = 502;
    uint256 internal constant EXCEED_TOTAL_LEGAL_SHARES = 503;
    uint256 internal constant WHOLE_NUMBER_REQUIRED = 504;
    uint256 internal constant BUY_PAUSED = 505;
    uint256 internal constant SELL_PAUSED = 506;
    uint256 internal constant INVALID_CURRENCY = 507;
    uint256 internal constant INVALID_BASE_CURRENCY = 508;
    uint256 internal constant INVALID_OUTPUT_CURRENCY = 509;
    uint256 internal constant INVALID_CASE = 510;
    uint256 internal constant INVALID_FEE_PERCENTAGE = 511;
    uint256 internal constant CALL_IDENTITY_FAILED = 512;
    uint256 internal constant LOCK_AMOUNT_LESS_THAN_TOTAL = 513;
    uint256 internal constant INSUFFICIENT_WLEGAL_LIQUIDITY = 514;
    uint256 internal constant INSUFFICIENT_WLEGAL_LIQUIDITY_MP = 515;

    // PRICEFEED

    uint256 internal constant INVALID_DECIMALS = 600;
    uint256 internal constant INVALID_PAIR_NAME = 601;

    // RENTSHARE

    uint256 internal constant CLAIMING_TWICE_A_WEEK = 700;
    uint256 internal constant SAME_SYMBOL = 701;

    // CUSTOMGAUGE

    uint256 internal constant RE_ENTRANCY = 800;
    uint256 internal constant CALLER_NOT_ACCOUNT = 801;
    uint256 internal constant TOO_MANY_REWARD_TOKENS = 802;
    uint256 internal constant REWARD_RATE_IS_ZERO = 803;
    uint256 internal constant PROVIDED_REWARD_TOO_HIGH = 804;

    // VAULTS
    uint256 internal constant WITHDRAWING_BEFORE_TIME = 900;
    uint256 internal constant ALREADY_INITIALIZED = 901;
    uint256 internal constant INVALID_CONTROLLER = 902;
    uint256 internal constant ZERO_SHARES = 903;
    uint256 internal constant ZERO_ASSETS = 904;
    uint256 internal constant ADDRESS_NOT_REGISTERED = 905;
}

// SPDX-License-Identifier: GPL-3.0
//
//                                             :+#####%%%%%%%%%%%%%%+
//                                         .-*@@@%+.:+%@@@@@%%#***%@@%=
//                                     :=*%@@@#=.      :#@@%       *@@@%=
//                       .-+*%@%*-.:+%@@@@@@+.     -*+:  .=#.       :%@@@%-
//                   :=*@@@@%%@@@@@@@@@%@@@-   .=#@@@%@%=             [email protected]@@@#.
//             -=+#%@@%#*=:.  :%@@@@%.   -*@@#*@@@@@@@#=:-              *@@@@+
//            [email protected]@%=:.     :=:   *@@@@@%#-   =%*%@@@@#+-.        =+       :%@@@%-
//           [email protected]@%.     [email protected]@@     =+=-.         @@#-           [email protected]@@%-       [email protected]@@@%:
//          :@@@.    [email protected]@#%:                   :    .=*=-::.-%@@@+*@@=       [email protected]@@@#.
//          %@@:    [email protected]%%*                         =%@@@@@@@@@@@#.  .*@%-       [email protected]@@@*.
//         #@@=                                [email protected]@@@%:=*@@@@@-      :%@%:      .*@@@@+
//        *@@*                                [email protected]@@#[email protected]@%-:%@@*          [email protected]@#.      :%@@@@-
//       [email protected]@%           .:-=++*##%%%@@@@@@@@@@@@*. :@[email protected]@@%:            .#@@+       [email protected]@@@#:
//      [email protected]@@*-+*#%%%@@@@@@@@@@@@@@@@%%#**@@%@@@.   *@=*@@#                :#@%=      .#@@@@#-
//      -%@@@@@@@@@@@@@@@*+==-:[email protected]@@=    *@# .#@*-=*@@@@%=                 -%@@@*       [email protected]@@@@%-
//         -+%@@@#.   %@%%=   [email protected]@:[email protected]: [email protected]@*    *@@*-::                   -%@@%=.         .*@@@@@#
//            *@@@*  [email protected]* *@@##@@-  #@*@@+    [email protected]@=          .         :[email protected]@@#:           [email protected]@@%+-
//             [email protected]@@%*@@:[email protected]@@@*   [email protected]@@*   .#@#.       .=+-       .=%@@@*.         :+#@@@@*=:
//              [email protected]@@@%@@@@@@@@@@@@@@@@@@@@@@%-      :+#*.       :*@@@%=.       .=#@@@@%+:
//               .%@@=                 .....    .=#@@+.       .#@@@*:       -*%@@@@%+.
//                 [email protected]@#+===---:::...         .=%@@*-         [email protected]@@+.      -*@@@@@%+.
//                  [email protected]@@@@@@@@@@@@@@@@@@@@@%@@@@=          [email protected]@@+      -#@@@@@#=.
//                    ..:::---===+++***###%%%@@@#-       .#@@+     -*@@@@@#=.
//                                           @@@@@@+.   [email protected]@*.   [email protected]@@@@%=.
//                                          [email protected]@@@@=   [email protected]@%:   -#@@@@%+.
//                                          [email protected]@@@@. [email protected]@@=  [email protected]@@@@*:
//                                          #@@@@#:%@@#. :*@@@@#-
//                                          @@@@@%@@@= :#@@@@+.
//                                         :@@@@@@@#.:#@@@%-
//                                         [email protected]@@@@@-.*@@@*:
//                                         #@@@@#[email protected]@@+.
//                                         @@@@+-%@%=
//                                        :@@@#%@%=
//                                        [email protected]@@@%-
//                                        :#%%=
//
/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2022, Tokeny sàrl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.8.9;

interface IModularCompliance {
    /// events

    /// @dev Event emitted for each executed interaction with a module contract.
    ///
    /// For gas efficiency, only the interaction calldata selector (first 4
    /// bytes) is included in the event. For interactions without calldata or
    /// whose calldata is shorter than 4 bytes, the selector will be `0`.
    event ModuleInteraction(address indexed target, bytes4 selector);

    /**
     *  this event is emitted when a token has been bound to the compliance contract
     *  the event is emitted by the bindToken function
     *  `_token` is the address of the token to bind
     */
    event TokenBound(address _token);

    /**
     *  this event is emitted when a token has been unbound from the compliance contract
     *  the event is emitted by the unbindToken function
     *  `_token` is the address of the token to unbind
     */
    event TokenUnbound(address _token);

    /**
     *  this event is emitted when a module has been added to the list of modules bound to the compliance contract
     *  the event is emitted by the addModule function
     *  `_module` is the address of the compliance module
     */
    event ModuleAdded(address _module);

    /**
     *  this event is emitted when a module has been removed from the list of modules bound to the compliance contract
     *  the event is emitted by the removeModule function
     *  `_module` is the address of the compliance module
     */
    event ModuleRemoved(address _module);

    /// functions

    /**
     *  @dev getter for the address of the token bound
     *  returns the address of the token
     */
    function getTokenBound() external view returns (address);

    /**
     *  @dev checks if a module is bound to the compliance contract
     *  returns true if module is bound, false otherwise
     */
    function isModuleBound(address _module) external view returns (bool);

    /**
     *  @dev binds a token to the compliance contract
     *  @param _token address of the token to bind
     *  This function can be called ONLY by the owner of the compliance contract
     *  Emits a TokenBound event
     */
    function bindToken(address _token) external;

    /**
     *  @dev unbinds a token from the compliance contract
     *  @param _token address of the token to unbind
     *  This function can be called ONLY by the owner of the compliance contract
     *  Emits a TokenUnbound event
     */
    function unbindToken(address _token) external;

    /**
     *  @dev adds a module to the list of compliance modules
     *  @param _module address of the module to add
     *  This function can be called ONLY by the owner of the compliance contract
     *  Emits a ModuleAdded event
     */
    function addModule(address _module) external;

    /**
     *  @dev removes a module from the list of compliance modules
     *  @param _module address of the module to remove
     *  This function can be called ONLY by the owner of the compliance contract
     *  Emits a ModuleRemoved event
     */
    function removeModule(address _module) external;

    /**
     *  @dev getter for the modules bound to the compliance contract
     *  returns address array of module contracts bound to the compliance
     */
    function getModules() external view returns (address[] memory);

    function callModuleFunction(
        bytes calldata callData,
        address _module
    ) external;

    /**
     *  @dev checks that the transfer is compliant.
     *  default compliance always returns true
     *  READ ONLY FUNCTION, this function cannot be used to increment
     *  counters, emit events, ...
     *  @param _from The address of the sender
     *  @param _to The address of the receiver
     *  @param _amount The amount of tokens involved in the transfe
     *  This function will call moduleCheck() on every module bound to the compliance
     *  If each of the module checks return TRUE, this function will return TRUE as well
     *  returns FALSE otherwise
     */
    function canTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) external view returns (bool);

    /**
     *  @dev function called whenever tokens are transferred
     *  from one wallet to another
     *  this function can update state variables in the modules bound to the compliance
     *  these state variables being used by the module checks to decide if a transfer
     *  is compliant or not depending on the values stored in these state variables and on
     *  the parameters of the modules
     *  This function can be called ONLY by the token contract bound to the compliance
     *  @param _from The address of the sender
     *  @param _to The address of the receiver
     *  @param _amount The amount of tokens involved in the transfer
     *  This function calls moduleTransferAction() on each module bound to the compliance contract
     */
    function transferred(address _from, address _to, uint256 _amount) external;

    /**
     *  @dev function called whenever tokens are created on a wallet
     *  this function can update state variables in the modules bound to the compliance
     *  these state variables being used by the module checks to decide if a transfer
     *  is compliant or not depending on the values stored in these state variables and on
     *  the parameters of the modules
     *  This function can be called ONLY by the token contract bound to the compliance
     *  @param _to The address of the receiver
     *  @param _amount The amount of tokens involved in the minting
     *  This function calls moduleMintAction() on each module bound to the compliance contract
     */
    function created(address _to, uint256 _amount) external;

    /**
     *  @dev function called whenever tokens are destroyed from a wallet
     *  this function can update state variables in the modules bound to the compliance
     *  these state variables being used by the module checks to decide if a transfer
     *  is compliant or not depending on the values stored in these state variables and on
     *  the parameters of the modules
     *  This function can be called ONLY by the token contract bound to the compliance
     *  @param _from The address on which tokens are burnt
     *  @param _amount The amount of tokens involved in the burn
     *  This function calls moduleBurnAction() on each module bound to the compliance contract
     */
    function destroyed(address _from, uint256 _amount) external;
}

// SPDX-License-Identifier: GPL-3.0
//
//                                             :+#####%%%%%%%%%%%%%%+
//                                         .-*@@@%+.:+%@@@@@%%#***%@@%=
//                                     :=*%@@@#=.      :#@@%       *@@@%=
//                       .-+*%@%*-.:+%@@@@@@+.     -*+:  .=#.       :%@@@%-
//                   :=*@@@@%%@@@@@@@@@%@@@-   .=#@@@%@%=             [email protected]@@@#.
//             -=+#%@@%#*=:.  :%@@@@%.   -*@@#*@@@@@@@#=:-              *@@@@+
//            [email protected]@%=:.     :=:   *@@@@@%#-   =%*%@@@@#+-.        =+       :%@@@%-
//           [email protected]@%.     [email protected]@@     =+=-.         @@#-           [email protected]@@%-       [email protected]@@@%:
//          :@@@.    [email protected]@#%:                   :    .=*=-::.-%@@@+*@@=       [email protected]@@@#.
//          %@@:    [email protected]%%*                         =%@@@@@@@@@@@#.  .*@%-       [email protected]@@@*.
//         #@@=                                [email protected]@@@%:=*@@@@@-      :%@%:      .*@@@@+
//        *@@*                                [email protected]@@#[email protected]@%-:%@@*          [email protected]@#.      :%@@@@-
//       [email protected]@%           .:-=++*##%%%@@@@@@@@@@@@*. :@[email protected]@@%:            .#@@+       [email protected]@@@#:
//      [email protected]@@*-+*#%%%@@@@@@@@@@@@@@@@%%#**@@%@@@.   *@=*@@#                :#@%=      .#@@@@#-
//      -%@@@@@@@@@@@@@@@*+==-:[email protected]@@=    *@# .#@*-=*@@@@%=                 -%@@@*       [email protected]@@@@%-
//         -+%@@@#.   %@%%=   [email protected]@:[email protected]: [email protected]@*    *@@*-::                   -%@@%=.         .*@@@@@#
//            *@@@*  [email protected]* *@@##@@-  #@*@@+    [email protected]@=          .         :[email protected]@@#:           [email protected]@@%+-
//             [email protected]@@%*@@:[email protected]@@@*   [email protected]@@*   .#@#.       .=+-       .=%@@@*.         :+#@@@@*=:
//              [email protected]@@@%@@@@@@@@@@@@@@@@@@@@@@%-      :+#*.       :*@@@%=.       .=#@@@@%+:
//               .%@@=                 .....    .=#@@+.       .#@@@*:       -*%@@@@%+.
//                 [email protected]@#+===---:::...         .=%@@*-         [email protected]@@+.      -*@@@@@%+.
//                  [email protected]@@@@@@@@@@@@@@@@@@@@@%@@@@=          [email protected]@@+      -#@@@@@#=.
//                    ..:::---===+++***###%%%@@@#-       .#@@+     -*@@@@@#=.
//                                           @@@@@@+.   [email protected]@*.   [email protected]@@@@%=.
//                                          [email protected]@@@@=   [email protected]@%:   -#@@@@%+.
//                                          [email protected]@@@@. [email protected]@@=  [email protected]@@@@*:
//                                          #@@@@#:%@@#. :*@@@@#-
//                                          @@@@@%@@@= :#@@@@+.
//                                         :@@@@@@@#.:#@@@%-
//                                         [email protected]@@@@@-.*@@@*:
//                                         #@@@@#[email protected]@@+.
//                                         @@@@+-%@%=
//                                        :@@@#%@%=
//                                        [email protected]@@@%-
//                                        :#%%=
//
/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2022, Tokeny sàrl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.8.9;

interface IClaimTopicsRegistry {
    /**
     *  this event is emitted when a claim topic has been added to the ClaimTopicsRegistry
     *  the event is emitted by the 'addClaimTopic' function
     *  `claimTopic` is the required claim added to the Claim Topics Registry
     */
    event ClaimTopicAdded(uint256 indexed claimTopic);

    /**
     *  this event is emitted when a claim topic has been removed from the ClaimTopicsRegistry
     *  the event is emitted by the 'removeClaimTopic' function
     *  `claimTopic` is the required claim removed from the Claim Topics Registry
     */
    event ClaimTopicRemoved(uint256 indexed claimTopic);

    /**
     * @dev Add a trusted claim topic (For example: KYC=1, AML=2).
     * Only owner can call.
     * emits `ClaimTopicAdded` event
     * @param _claimTopic The claim topic index
     */
    function addClaimTopic(uint256 _claimTopic) external;

    /**
     *  @dev Remove a trusted claim topic (For example: KYC=1, AML=2).
     *  Only owner can call.
     *  emits `ClaimTopicRemoved` event
     *  @param _claimTopic The claim topic index
     */
    function removeClaimTopic(uint256 _claimTopic) external;

    /**
     *  @dev Get the trusted claim topics for the security token
     *  @return Array of trusted claim topics
     */
    function getClaimTopics() external view returns (uint256[] memory);
}

// SPDX-License-Identifier: GPL-3.0
//
//                                             :+#####%%%%%%%%%%%%%%+
//                                         .-*@@@%+.:+%@@@@@%%#***%@@%=
//                                     :=*%@@@#=.      :#@@%       *@@@%=
//                       .-+*%@%*-.:+%@@@@@@+.     -*+:  .=#.       :%@@@%-
//                   :=*@@@@%%@@@@@@@@@%@@@-   .=#@@@%@%=             [email protected]@@@#.
//             -=+#%@@%#*=:.  :%@@@@%.   -*@@#*@@@@@@@#=:-              *@@@@+
//            [email protected]@%=:.     :=:   *@@@@@%#-   =%*%@@@@#+-.        =+       :%@@@%-
//           [email protected]@%.     [email protected]@@     =+=-.         @@#-           [email protected]@@%-       [email protected]@@@%:
//          :@@@.    [email protected]@#%:                   :    .=*=-::.-%@@@+*@@=       [email protected]@@@#.
//          %@@:    [email protected]%%*                         =%@@@@@@@@@@@#.  .*@%-       [email protected]@@@*.
//         #@@=                                [email protected]@@@%:=*@@@@@-      :%@%:      .*@@@@+
//        *@@*                                [email protected]@@#[email protected]@%-:%@@*          [email protected]@#.      :%@@@@-
//       [email protected]@%           .:-=++*##%%%@@@@@@@@@@@@*. :@[email protected]@@%:            .#@@+       [email protected]@@@#:
//      [email protected]@@*-+*#%%%@@@@@@@@@@@@@@@@%%#**@@%@@@.   *@=*@@#                :#@%=      .#@@@@#-
//      -%@@@@@@@@@@@@@@@*+==-:[email protected]@@=    *@# .#@*-=*@@@@%=                 -%@@@*       [email protected]@@@@%-
//         -+%@@@#.   %@%%=   [email protected]@:[email protected]: [email protected]@*    *@@*-::                   -%@@%=.         .*@@@@@#
//            *@@@*  [email protected]* *@@##@@-  #@*@@+    [email protected]@=          .         :[email protected]@@#:           [email protected]@@%+-
//             [email protected]@@%*@@:[email protected]@@@*   [email protected]@@*   .#@#.       .=+-       .=%@@@*.         :+#@@@@*=:
//              [email protected]@@@%@@@@@@@@@@@@@@@@@@@@@@%-      :+#*.       :*@@@%=.       .=#@@@@%+:
//               .%@@=                 .....    .=#@@+.       .#@@@*:       -*%@@@@%+.
//                 [email protected]@#+===---:::...         .=%@@*-         [email protected]@@+.      -*@@@@@%+.
//                  [email protected]@@@@@@@@@@@@@@@@@@@@@%@@@@=          [email protected]@@+      -#@@@@@#=.
//                    ..:::---===+++***###%%%@@@#-       .#@@+     -*@@@@@#=.
//                                           @@@@@@+.   [email protected]@*.   [email protected]@@@@%=.
//                                          [email protected]@@@@=   [email protected]@%:   -#@@@@%+.
//                                          [email protected]@@@@. [email protected]@@=  [email protected]@@@@*:
//                                          #@@@@#:%@@#. :*@@@@#-
//                                          @@@@@%@@@= :#@@@@+.
//                                         :@@@@@@@#.:#@@@%-
//                                         [email protected]@@@@@-.*@@@*:
//                                         #@@@@#[email protected]@@+.
//                                         @@@@+-%@%=
//                                        :@@@#%@%=
//                                        [email protected]@@@%-
//                                        :#%%=
//
/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2022, Tokeny sàrl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.8.9;

import "./ITrustedIssuersRegistry.sol";
import "./IClaimTopicsRegistry.sol";
import "./IIdentityRegistryStorage.sol";

import "@onchain-id/solidity/contracts/interface/IClaimIssuer.sol";
import "@onchain-id/solidity/contracts/interface/IIdentity.sol";

interface IIdentityRegistry {
    /**
     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry
     *  the event is emitted by the IdentityRegistry constructor
     *  `claimTopicsRegistry` is the address of the Claim Topics Registry contract
     */
    event ClaimTopicsRegistrySet(address indexed claimTopicsRegistry);

    /**
     *  this event is emitted when the IdentityRegistryStorage has been set for the IdentityRegistry
     *  the event is emitted by the IdentityRegistry constructor
     *  `identityStorage` is the address of the Identity Registry Storage contract
     */
    event IdentityStorageSet(address indexed identityStorage);

    /**
     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry
     *  the event is emitted by the IdentityRegistry constructor
     *  `trustedIssuersRegistry` is the address of the Trusted Issuers Registry contract
     */
    event TrustedIssuersRegistrySet(address indexed trustedIssuersRegistry);

    /**
     *  this event is emitted when an Identity is registered into the Identity Registry.
     *  the event is emitted by the 'registerIdentity' function
     *  `investorAddress` is the address of the investor's wallet
     *  `identity` is the address of the Identity smart contract (onchainID)
     */
    event IdentityRegistered(
        address indexed investorAddress,
        IIdentity indexed identity
    );

    /**
     *  this event is emitted when an Identity is removed from the Identity Registry.
     *  the event is emitted by the 'deleteIdentity' function
     *  `investorAddress` is the address of the investor's wallet
     *  `identity` is the address of the Identity smart contract (onchainID)
     */
    event IdentityRemoved(
        address indexed investorAddress,
        IIdentity indexed identity
    );

    /**
     *  this event is emitted when an Identity has been updated
     *  the event is emitted by the 'updateIdentity' function
     *  `oldIdentity` is the old Identity contract's address to update
     *  `newIdentity` is the new Identity contract's
     */
    event IdentityUpdated(
        IIdentity indexed oldIdentity,
        IIdentity indexed newIdentity
    );

    /**
     *  this event is emitted when an Identity's country has been updated
     *  the event is emitted by the 'updateCountry' function
     *  `investorAddress` is the address on which the country has been updated
     *  `country` is the numeric code (ISO 3166-1) of the new country
     */
    event CountryUpdated(
        address indexed investorAddress,
        uint16 indexed country
    );

    /**
     *  @dev Register an identity contract corresponding to a user address.
     *  Requires that the user doesn't have an identity contract already registered.
     *  This function can only be called by a wallet set as agent of the smart contract
     *  @param _userAddress The address of the user
     *  @param _identity The address of the user's identity contract
     *  @param _country The country of the investor
     *  emits `IdentityRegistered` event
     */
    function registerIdentity(
        address _userAddress,
        IIdentity _identity,
        uint16 _country
    ) external;

    /**
     *  @dev Removes an user from the identity registry.
     *  Requires that the user have an identity contract already deployed that will be deleted.
     *  This function can only be called by a wallet set as agent of the smart contract
     *  @param _userAddress The address of the user to be removed
     *  emits `IdentityRemoved` event
     */
    function deleteIdentity(address _userAddress) external;

    /**
     *  @dev Replace the actual identityRegistryStorage contract with a new one.
     *  This function can only be called by the wallet set as owner of the smart contract
     *  @param _identityRegistryStorage The address of the new Identity Registry Storage
     *  emits `IdentityStorageSet` event
     */
    function setIdentityRegistryStorage(
        address _identityRegistryStorage
    ) external;

    /**
     *  @dev Replace the actual claimTopicsRegistry contract with a new one.
     *  This function can only be called by the wallet set as owner of the smart contract
     *  @param _claimTopicsRegistry The address of the new claim Topics Registry
     *  emits `ClaimTopicsRegistrySet` event
     */
    function setClaimTopicsRegistry(address _claimTopicsRegistry) external;

    /**
     *  @dev Replace the actual trustedIssuersRegistry contract with a new one.
     *  This function can only be called by the wallet set as owner of the smart contract
     *  @param _trustedIssuersRegistry The address of the new Trusted Issuers Registry
     *  emits `TrustedIssuersRegistrySet` event
     */
    function setTrustedIssuersRegistry(
        address _trustedIssuersRegistry
    ) external;

    /**
     *  @dev Updates the country corresponding to a user address.
     *  Requires that the user should have an identity contract already deployed that will be replaced.
     *  This function can only be called by a wallet set as agent of the smart contract
     *  @param _userAddress The address of the user
     *  @param _country The new country of the user
     *  emits `CountryUpdated` event
     */
    function updateCountry(address _userAddress, uint16 _country) external;

    /**
     *  @dev Updates an identity contract corresponding to a user address.
     *  Requires that the user address should be the owner of the identity contract.
     *  Requires that the user should have an identity contract already deployed that will be replaced.
     *  This function can only be called by a wallet set as agent of the smart contract
     *  @param _userAddress The address of the user
     *  @param _identity The address of the user's new identity contract
     *  emits `IdentityUpdated` event
     */
    function updateIdentity(address _userAddress, IIdentity _identity) external;

    /**
     *  @dev function allowing to register identities in batch
     *  This function can only be called by a wallet set as agent of the smart contract
     *  Requires that none of the users has an identity contract already registered.
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _userAddresses The addresses of the users
     *  @param _identities The addresses of the corresponding identity contracts
     *  @param _countries The countries of the corresponding investors
     *  emits _userAddresses.length `IdentityRegistered` events
     */
    function batchRegisterIdentity(
        address[] calldata _userAddresses,
        IIdentity[] calldata _identities,
        uint16[] calldata _countries
    ) external;

    /**
     *  @dev This functions checks whether a wallet has its Identity registered or not
     *  in the Identity Registry.
     *  @param _userAddress The address of the user to be checked.
     *  @return 'True' if the address is contained in the Identity Registry, 'false' if not.
     */
    function contains(address _userAddress) external view returns (bool);

    /**
     *  @dev This functions checks whether an identity contract
     *  corresponding to the provided user address has the required claims or not based
     *  on the data fetched from trusted issuers registry and from the claim topics registry
     *  @param _userAddress The address of the user to be verified.
     *  @return 'True' if the address is verified, 'false' if not.
     */
    function isVerified(address _userAddress) external view returns (bool);

    /**
     *  @dev Returns the onchainID of an investor.
     *  @param _userAddress The wallet of the investor
     */
    function identity(address _userAddress) external view returns (IIdentity);

    /**
     *  @dev Returns the country code of an investor.
     *  @param _userAddress The wallet of the investor
     */
    function investorCountry(
        address _userAddress
    ) external view returns (uint16);

    /**
     *  @dev Returns the IdentityRegistryStorage linked to the current IdentityRegistry.
     */
    function identityStorage() external view returns (IIdentityRegistryStorage);

    /**
     *  @dev Returns the TrustedIssuersRegistry linked to the current IdentityRegistry.
     */
    function issuersRegistry() external view returns (ITrustedIssuersRegistry);

    /**
     *  @dev Returns the ClaimTopicsRegistry linked to the current IdentityRegistry.
     */
    function topicsRegistry() external view returns (IClaimTopicsRegistry);
}

// SPDX-License-Identifier: GPL-3.0
//
//                                             :+#####%%%%%%%%%%%%%%+
//                                         .-*@@@%+.:+%@@@@@%%#***%@@%=
//                                     :=*%@@@#=.      :#@@%       *@@@%=
//                       .-+*%@%*-.:+%@@@@@@+.     -*+:  .=#.       :%@@@%-
//                   :=*@@@@%%@@@@@@@@@%@@@-   .=#@@@%@%=             [email protected]@@@#.
//             -=+#%@@%#*=:.  :%@@@@%.   -*@@#*@@@@@@@#=:-              *@@@@+
//            [email protected]@%=:.     :=:   *@@@@@%#-   =%*%@@@@#+-.        =+       :%@@@%-
//           [email protected]@%.     [email protected]@@     =+=-.         @@#-           [email protected]@@%-       [email protected]@@@%:
//          :@@@.    [email protected]@#%:                   :    .=*=-::.-%@@@+*@@=       [email protected]@@@#.
//          %@@:    [email protected]%%*                         =%@@@@@@@@@@@#.  .*@%-       [email protected]@@@*.
//         #@@=                                [email protected]@@@%:=*@@@@@-      :%@%:      .*@@@@+
//        *@@*                                [email protected]@@#[email protected]@%-:%@@*          [email protected]@#.      :%@@@@-
//       [email protected]@%           .:-=++*##%%%@@@@@@@@@@@@*. :@[email protected]@@%:            .#@@+       [email protected]@@@#:
//      [email protected]@@*-+*#%%%@@@@@@@@@@@@@@@@%%#**@@%@@@.   *@=*@@#                :#@%=      .#@@@@#-
//      -%@@@@@@@@@@@@@@@*+==-:[email protected]@@=    *@# .#@*-=*@@@@%=                 -%@@@*       [email protected]@@@@%-
//         -+%@@@#.   %@%%=   [email protected]@:[email protected]: [email protected]@*    *@@*-::                   -%@@%=.         .*@@@@@#
//            *@@@*  [email protected]* *@@##@@-  #@*@@+    [email protected]@=          .         :[email protected]@@#:           [email protected]@@%+-
//             [email protected]@@%*@@:[email protected]@@@*   [email protected]@@*   .#@#.       .=+-       .=%@@@*.         :+#@@@@*=:
//              [email protected]@@@%@@@@@@@@@@@@@@@@@@@@@@%-      :+#*.       :*@@@%=.       .=#@@@@%+:
//               .%@@=                 .....    .=#@@+.       .#@@@*:       -*%@@@@%+.
//                 [email protected]@#+===---:::...         .=%@@*-         [email protected]@@+.      -*@@@@@%+.
//                  [email protected]@@@@@@@@@@@@@@@@@@@@@%@@@@=          [email protected]@@+      -#@@@@@#=.
//                    ..:::---===+++***###%%%@@@#-       .#@@+     -*@@@@@#=.
//                                           @@@@@@+.   [email protected]@*.   [email protected]@@@@%=.
//                                          [email protected]@@@@=   [email protected]@%:   -#@@@@%+.
//                                          [email protected]@@@@. [email protected]@@=  [email protected]@@@@*:
//                                          #@@@@#:%@@#. :*@@@@#-
//                                          @@@@@%@@@= :#@@@@+.
//                                         :@@@@@@@#.:#@@@%-
//                                         [email protected]@@@@@-.*@@@*:
//                                         #@@@@#[email protected]@@+.
//                                         @@@@+-%@%=
//                                        :@@@#%@%=
//                                        [email protected]@@@%-
//                                        :#%%=
//
/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2022, Tokeny sàrl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.8.9;

import "@onchain-id/solidity/contracts/interface/IIdentity.sol";

interface IIdentityRegistryStorage {
    /**
     *  this event is emitted when an Identity is registered into the storage contract.
     *  the event is emitted by the 'registerIdentity' function
     *  `investorAddress` is the address of the investor's wallet
     *  `identity` is the address of the Identity smart contract (onchainID)
     */
    event IdentityStored(
        address indexed investorAddress,
        IIdentity indexed identity
    );

    /**
     *  this event is emitted when an Identity is removed from the storage contract.
     *  the event is emitted by the 'deleteIdentity' function
     *  `investorAddress` is the address of the investor's wallet
     *  `identity` is the address of the Identity smart contract (onchainID)
     */
    event IdentityUnstored(
        address indexed investorAddress,
        IIdentity indexed identity
    );

    /**
     *  this event is emitted when an Identity has been updated
     *  the event is emitted by the 'updateIdentity' function
     *  `oldIdentity` is the old Identity contract's address to update
     *  `newIdentity` is the new Identity contract's
     */
    event IdentityModified(
        IIdentity indexed oldIdentity,
        IIdentity indexed newIdentity
    );

    /**
     *  this event is emitted when an Identity's country has been updated
     *  the event is emitted by the 'updateCountry' function
     *  `investorAddress` is the address on which the country has been updated
     *  `country` is the numeric code (ISO 3166-1) of the new country
     */
    event CountryModified(
        address indexed investorAddress,
        uint16 indexed country
    );

    /**
     *  this event is emitted when an Identity Registry is bound to the storage contract
     *  the event is emitted by the 'addIdentityRegistry' function
     *  `identityRegistry` is the address of the identity registry added
     */
    event IdentityRegistryBound(address indexed identityRegistry);

    /**
     *  this event is emitted when an Identity Registry is unbound from the storage contract
     *  the event is emitted by the 'removeIdentityRegistry' function
     *  `identityRegistry` is the address of the identity registry removed
     */
    event IdentityRegistryUnbound(address indexed identityRegistry);

    /**
     *  @dev Returns the identity registries linked to the storage contract
     */
    function linkedIdentityRegistries()
        external
        view
        returns (address[] memory);

    /**
     *  @dev Returns the onchainID of an investor.
     *  @param _userAddress The wallet of the investor
     */
    function storedIdentity(
        address _userAddress
    ) external view returns (IIdentity);

    /**
     *  @dev Returns the country code of an investor.
     *  @param _userAddress The wallet of the investor
     */
    function storedInvestorCountry(
        address _userAddress
    ) external view returns (uint16);

    /**
     *  @dev adds an identity contract corresponding to a user address in the storage.
     *  Requires that the user doesn't have an identity contract already registered.
     *  This function can only be called by an address set as agent of the smart contract
     *  @param _userAddress The address of the user
     *  @param _identity The address of the user's identity contract
     *  @param _country The country of the investor
     *  emits `IdentityStored` event
     */
    function addIdentityToStorage(
        address _userAddress,
        IIdentity _identity,
        uint16 _country
    ) external;

    /**
     *  @dev Removes an user from the storage.
     *  Requires that the user have an identity contract already deployed that will be deleted.
     *  This function can only be called by an address set as agent of the smart contract
     *  @param _userAddress The address of the user to be removed
     *  emits `IdentityUnstored` event
     */
    function removeIdentityFromStorage(address _userAddress) external;

    /**
     *  @dev Updates the country corresponding to a user address.
     *  Requires that the user should have an identity contract already deployed that will be replaced.
     *  This function can only be called by an address set as agent of the smart contract
     *  @param _userAddress The address of the user
     *  @param _country The new country of the user
     *  emits `CountryModified` event
     */
    function modifyStoredInvestorCountry(
        address _userAddress,
        uint16 _country
    ) external;

    /**
     *  @dev Updates an identity contract corresponding to a user address.
     *  Requires that the user address should be the owner of the identity contract.
     *  Requires that the user should have an identity contract already deployed that will be replaced.
     *  This function can only be called by an address set as agent of the smart contract
     *  @param _userAddress The address of the user
     *  @param _identity The address of the user's new identity contract
     *  emits `IdentityModified` event
     */
    function modifyStoredIdentity(
        address _userAddress,
        IIdentity _identity
    ) external;

    /**
     *  @notice Adds an identity registry as agent of the Identity Registry Storage Contract.
     *  This function can only be called by the wallet set as owner of the smart contract
     *  This function adds the identity registry to the list of identityRegistries linked to the storage contract
     *  @param _identityRegistry The identity registry address to add.
     */
    function bindIdentityRegistry(address _identityRegistry) external;

    /**
     *  @notice Removes an identity registry from being agent of the Identity Registry Storage Contract.
     *  This function can only be called by the wallet set as owner of the smart contract
     *  This function removes the identity registry from the list of identityRegistries linked to the storage contract
     *  @param _identityRegistry The identity registry address to remove.
     */
    function unbindIdentityRegistry(address _identityRegistry) external;
}

// SPDX-License-Identifier: GPL-3.0
//
//                                             :+#####%%%%%%%%%%%%%%+
//                                         .-*@@@%+.:+%@@@@@%%#***%@@%=
//                                     :=*%@@@#=.      :#@@%       *@@@%=
//                       .-+*%@%*-.:+%@@@@@@+.     -*+:  .=#.       :%@@@%-
//                   :=*@@@@%%@@@@@@@@@%@@@-   .=#@@@%@%=             [email protected]@@@#.
//             -=+#%@@%#*=:.  :%@@@@%.   -*@@#*@@@@@@@#=:-              *@@@@+
//            [email protected]@%=:.     :=:   *@@@@@%#-   =%*%@@@@#+-.        =+       :%@@@%-
//           [email protected]@%.     [email protected]@@     =+=-.         @@#-           [email protected]@@%-       [email protected]@@@%:
//          :@@@.    [email protected]@#%:                   :    .=*=-::.-%@@@+*@@=       [email protected]@@@#.
//          %@@:    [email protected]%%*                         =%@@@@@@@@@@@#.  .*@%-       [email protected]@@@*.
//         #@@=                                [email protected]@@@%:=*@@@@@-      :%@%:      .*@@@@+
//        *@@*                                [email protected]@@#[email protected]@%-:%@@*          [email protected]@#.      :%@@@@-
//       [email protected]@%           .:-=++*##%%%@@@@@@@@@@@@*. :@[email protected]@@%:            .#@@+       [email protected]@@@#:
//      [email protected]@@*-+*#%%%@@@@@@@@@@@@@@@@%%#**@@%@@@.   *@=*@@#                :#@%=      .#@@@@#-
//      -%@@@@@@@@@@@@@@@*+==-:[email protected]@@=    *@# .#@*-=*@@@@%=                 -%@@@*       [email protected]@@@@%-
//         -+%@@@#.   %@%%=   [email protected]@:[email protected]: [email protected]@*    *@@*-::                   -%@@%=.         .*@@@@@#
//            *@@@*  [email protected]* *@@##@@-  #@*@@+    [email protected]@=          .         :[email protected]@@#:           [email protected]@@%+-
//             [email protected]@@%*@@:[email protected]@@@*   [email protected]@@*   .#@#.       .=+-       .=%@@@*.         :+#@@@@*=:
//              [email protected]@@@%@@@@@@@@@@@@@@@@@@@@@@%-      :+#*.       :*@@@%=.       .=#@@@@%+:
//               .%@@=                 .....    .=#@@+.       .#@@@*:       -*%@@@@%+.
//                 [email protected]@#+===---:::...         .=%@@*-         [email protected]@@+.      -*@@@@@%+.
//                  [email protected]@@@@@@@@@@@@@@@@@@@@@%@@@@=          [email protected]@@+      -#@@@@@#=.
//                    ..:::---===+++***###%%%@@@#-       .#@@+     -*@@@@@#=.
//                                           @@@@@@+.   [email protected]@*.   [email protected]@@@@%=.
//                                          [email protected]@@@@=   [email protected]@%:   -#@@@@%+.
//                                          [email protected]@@@@. [email protected]@@=  [email protected]@@@@*:
//                                          #@@@@#:%@@#. :*@@@@#-
//                                          @@@@@%@@@= :#@@@@+.
//                                         :@@@@@@@#.:#@@@%-
//                                         [email protected]@@@@@-.*@@@*:
//                                         #@@@@#[email protected]@@+.
//                                         @@@@+-%@%=
//                                        :@@@#%@%=
//                                        [email protected]@@@%-
//                                        :#%%=
//

/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2022, Tokeny sàrl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.8.9;

import "@onchain-id/solidity/contracts/interface/IClaimIssuer.sol";

interface ITrustedIssuersRegistry {
    /**
     *  this event is emitted when a trusted issuer is added in the registry.
     *  the event is emitted by the addTrustedIssuer function
     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract
     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit
     */
    event TrustedIssuerAdded(
        IClaimIssuer indexed trustedIssuer,
        uint256[] claimTopics
    );

    /**
     *  this event is emitted when a trusted issuer is removed from the registry.
     *  the event is emitted by the removeTrustedIssuer function
     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract
     */
    event TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);

    /**
     *  this event is emitted when the set of claim topics is changed for a given trusted issuer.
     *  the event is emitted by the updateIssuerClaimTopics function
     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract
     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit
     */
    event ClaimTopicsUpdated(
        IClaimIssuer indexed trustedIssuer,
        uint256[] claimTopics
    );

    /**
     *  @dev registers a ClaimIssuer contract as trusted claim issuer.
     *  Requires that a ClaimIssuer contract doesn't already exist
     *  Requires that the claimTopics set is not empty
     *  @param _trustedIssuer The ClaimIssuer contract address of the trusted claim issuer.
     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit
     *  This function can only be called by the owner of the Trusted Issuers Registry contract
     *  emits a `TrustedIssuerAdded` event
     */
    function addTrustedIssuer(
        IClaimIssuer _trustedIssuer,
        uint256[] calldata _claimTopics
    ) external;

    /**
     *  @dev Removes the ClaimIssuer contract of a trusted claim issuer.
     *  Requires that the claim issuer contract to be registered first
     *  @param _trustedIssuer the claim issuer to remove.
     *  This function can only be called by the owner of the Trusted Issuers Registry contract
     *  emits a `TrustedIssuerRemoved` event
     */
    function removeTrustedIssuer(IClaimIssuer _trustedIssuer) external;

    /**
     *  @dev Updates the set of claim topics that a trusted issuer is allowed to emit.
     *  Requires that this ClaimIssuer contract already exists in the registry
     *  Requires that the provided claimTopics set is not empty
     *  @param _trustedIssuer the claim issuer to update.
     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit
     *  This function can only be called by the owner of the Trusted Issuers Registry contract
     *  emits a `ClaimTopicsUpdated` event
     */
    function updateIssuerClaimTopics(
        IClaimIssuer _trustedIssuer,
        uint256[] calldata _claimTopics
    ) external;

    /**
     *  @dev Function for getting all the trusted claim issuers stored.
     *  @return array of all claim issuers registered.
     */
    function getTrustedIssuers() external view returns (IClaimIssuer[] memory);

    /**
     *  @dev Checks if the ClaimIssuer contract is trusted
     *  @param _issuer the address of the ClaimIssuer contract
     *  @return true if the issuer is trusted, false otherwise.
     */
    function isTrustedIssuer(address _issuer) external view returns (bool);

    /**
     *  @dev Function for getting all the claim topic of trusted claim issuer
     *  Requires the provided ClaimIssuer contract to be registered in the trusted issuers registry.
     *  @param _trustedIssuer the trusted issuer concerned.
     *  @return The set of claim topics that the trusted issuer is allowed to emit
     */
    function getTrustedIssuerClaimTopics(
        IClaimIssuer _trustedIssuer
    ) external view returns (uint256[] memory);

    /**
     *  @dev Function for checking if the trusted claim issuer is allowed
     *  to emit a certain claim topic
     *  @param _issuer the address of the trusted issuer's ClaimIssuer contract
     *  @param _claimTopic the Claim Topic that has to be checked to know if the `issuer` is allowed to emit it
     *  @return true if the issuer is trusted for this claim topic.
     */
    function hasClaimTopic(
        address _issuer,
        uint256 _claimTopic
    ) external view returns (bool);
}

// SPDX-License-Identifier: GPL-3.0
//
//                                             :+#####%%%%%%%%%%%%%%+
//                                         .-*@@@%+.:+%@@@@@%%#***%@@%=
//                                     :=*%@@@#=.      :#@@%       *@@@%=
//                       .-+*%@%*-.:+%@@@@@@+.     -*+:  .=#.       :%@@@%-
//                   :=*@@@@%%@@@@@@@@@%@@@-   .=#@@@%@%=             [email protected]@@@#.
//             -=+#%@@%#*=:.  :%@@@@%.   -*@@#*@@@@@@@#=:-              *@@@@+
//            [email protected]@%=:.     :=:   *@@@@@%#-   =%*%@@@@#+-.        =+       :%@@@%-
//           [email protected]@%.     [email protected]@@     =+=-.         @@#-           [email protected]@@%-       [email protected]@@@%:
//          :@@@.    [email protected]@#%:                   :    .=*=-::.-%@@@+*@@=       [email protected]@@@#.
//          %@@:    [email protected]%%*                         =%@@@@@@@@@@@#.  .*@%-       [email protected]@@@*.
//         #@@=                                [email protected]@@@%:=*@@@@@-      :%@%:      .*@@@@+
//        *@@*                                [email protected]@@#[email protected]@%-:%@@*          [email protected]@#.      :%@@@@-
//       [email protected]@%           .:-=++*##%%%@@@@@@@@@@@@*. :@[email protected]@@%:            .#@@+       [email protected]@@@#:
//      [email protected]@@*-+*#%%%@@@@@@@@@@@@@@@@%%#**@@%@@@.   *@=*@@#                :#@%=      .#@@@@#-
//      -%@@@@@@@@@@@@@@@*+==-:[email protected]@@=    *@# .#@*-=*@@@@%=                 -%@@@*       [email protected]@@@@%-
//         -+%@@@#.   %@%%=   [email protected]@:[email protected]: [email protected]@*    *@@*-::                   -%@@%=.         .*@@@@@#
//            *@@@*  [email protected]* *@@##@@-  #@*@@+    [email protected]@=          .         :[email protected]@@#:           [email protected]@@%+-
//             [email protected]@@%*@@:[email protected]@@@*   [email protected]@@*   .#@#.       .=+-       .=%@@@*.         :+#@@@@*=:
//              [email protected]@@@%@@@@@@@@@@@@@@@@@@@@@@%-      :+#*.       :*@@@%=.       .=#@@@@%+:
//               .%@@=                 .....    .=#@@+.       .#@@@*:       -*%@@@@%+.
//                 [email protected]@#+===---:::...         .=%@@*-         [email protected]@@+.      -*@@@@@%+.
//                  [email protected]@@@@@@@@@@@@@@@@@@@@@%@@@@=          [email protected]@@+      -#@@@@@#=.
//                    ..:::---===+++***###%%%@@@#-       .#@@+     -*@@@@@#=.
//                                           @@@@@@+.   [email protected]@*.   [email protected]@@@@%=.
//                                          [email protected]@@@@=   [email protected]@%:   -#@@@@%+.
//                                          [email protected]@@@@. [email protected]@@=  [email protected]@@@@*:
//                                          #@@@@#:%@@#. :*@@@@#-
//                                          @@@@@%@@@= :#@@@@+.
//                                         :@@@@@@@#.:#@@@%-
//                                         [email protected]@@@@@-.*@@@*:
//                                         #@@@@#[email protected]@@+.
//                                         @@@@+-%@%=
//                                        :@@@#%@%=
//                                        [email protected]@@@%-
//                                        :#%%=
//

/**
 *     NOTICE
 *
 *     The T-REX software is licensed under a proprietary license or the GPL v.3.
 *     If you choose to receive it under the GPL v.3 license, the following applies:
 *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain
 *
 *     Copyright (C) 2022, Tokeny sàrl.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

pragma solidity 0.8.9;

import "../registry/interface/IIdentityRegistry.sol";
import "../compliance/modular/IModularCompliance.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @dev interface
interface IToken is IERC20 {
    /**
     *  this event is emitted when the token information is updated.
     *  the event is emitted by the token constructor and by the setTokenInformation function
     *  `_newName` is the name of the token
     *  `_newSymbol` is the symbol of the token
     *  `_newDecimals` is the decimals of the token
     *  `_newVersion` is the version of the token, current version is 3.0
     *  `_newOnchainID` is the address of the onchainID of the token
     */
    event UpdatedTokenInformation(
        string _newName,
        string _newSymbol,
        uint8 _newDecimals,
        string _newVersion,
        address _newOnchainID
    );

    /**
     *  this event is emitted when the IdentityRegistry has been set for the token
     *  the event is emitted by the token constructor and by the setIdentityRegistry function
     *  `_identityRegistry` is the address of the Identity Registry of the token
     */
    event IdentityRegistryAdded(address indexed _identityRegistry);

    /**
     *  this event is emitted when the Compliance has been set for the token
     *  the event is emitted by the token constructor and by the setCompliance function
     *  `_compliance` is the address of the Compliance contract of the token
     */
    event ComplianceAdded(address indexed _compliance);

    /**
     *  this event is emitted when an investor successfully recovers his tokens
     *  the event is emitted by the recoveryAddress function
     *  `_lostWallet` is the address of the wallet that the investor lost access to
     *  `_newWallet` is the address of the wallet that the investor provided for the recovery
     *  `_investorOnchainID` is the address of the onchainID of the investor who asked for a recovery
     */
    event RecoverySuccess(
        address _lostWallet,
        address _newWallet,
        address _investorOnchainID
    );

    /**
     *  this event is emitted when the wallet of an investor is frozen or unfrozen
     *  the event is emitted by setAddressFrozen and batchSetAddressFrozen functions
     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status
     *  `_isFrozen` is the freezing status of the wallet
     *  if `_isFrozen` equals `true` the wallet is frozen after emission of the event
     *  if `_isFrozen` equals `false` the wallet is unfrozen after emission of the event
     *  `_owner` is the address of the agent who called the function to freeze the wallet
     */
    event AddressFrozen(
        address indexed _userAddress,
        bool indexed _isFrozen,
        address indexed _owner
    );

    /**
     *  this event is emitted when a certain amount of tokens is frozen on a wallet
     *  the event is emitted by freezePartialTokens and batchFreezePartialTokens functions
     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status
     *  `_amount` is the amount of tokens that are frozen
     */
    event TokensFrozen(address indexed _userAddress, uint256 _amount);

    /**
     *  this event is emitted when a certain amount of tokens is unfrozen on a wallet
     *  the event is emitted by unfreezePartialTokens and batchUnfreezePartialTokens functions
     *  `_userAddress` is the wallet of the investor that is concerned by the freezing status
     *  `_amount` is the amount of tokens that are unfrozen
     */
    event TokensUnfrozen(address indexed _userAddress, uint256 _amount);

    /**
     *  this event is emitted when the token is paused
     *  the event is emitted by the pause function
     *  `_userAddress` is the address of the wallet that called the pause function
     */
    event Paused(address _userAddress);

    /**
     *  this event is emitted when the token is unpaused
     *  the event is emitted by the unpause function
     *  `_userAddress` is the address of the wallet that called the unpause function
     */
    event Unpaused(address _userAddress);

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 1 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * balanceOf() and transfer().
     */
    function decimals() external view returns (uint8);

    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the address of the onchainID of the token.
     * the onchainID of the token gives all the information available
     * about the token and is managed by the token issuer or his agent.
     */
    function onchainID() external view returns (address);

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the TREX version of the token.
     * current version is 3.0.0
     */
    function version() external view returns (string memory);

    /**
     *  @dev Returns the Identity Registry linked to the token
     */
    function identityRegistry() external view returns (IIdentityRegistry);

    /**
     *  @dev Returns the Compliance contract linked to the token
     */
    function compliance() external view returns (IModularCompliance);

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() external view returns (bool);

    /**
     *  @dev Returns the freezing status of a wallet
     *  if isFrozen returns `true` the wallet is frozen
     *  if isFrozen returns `false` the wallet is not frozen
     *  isFrozen returning `true` doesn't mean that the balance is free, tokens could be blocked by
     *  a partial freeze or the whole token could be blocked by pause
     *  @param _userAddress the address of the wallet on which isFrozen is called
     */
    function isFrozen(address _userAddress) external view returns (bool);

    /**
     *  @dev Returns the amount of tokens that are partially frozen on a wallet
     *  the amount of frozen tokens is always <= to the total balance of the wallet
     *  @param _userAddress the address of the wallet on which getFrozenTokens is called
     */
    function getFrozenTokens(
        address _userAddress
    ) external view returns (uint256);

    /**
     *  @dev sets the token name
     *  @param _name the name of token to set
     *  Only the owner of the token smart contract can call this function
     *  emits a `UpdatedTokenInformation` event
     */
    function setName(string calldata _name) external;

    /**
     *  @dev sets the token symbol
     *  @param _symbol the token symbol to set
     *  Only the owner of the token smart contract can call this function
     *  emits a `UpdatedTokenInformation` event
     */
    function setSymbol(string calldata _symbol) external;

    /**
     *  @dev sets the onchain ID of the token
     *  @param _onchainID the address of the onchain ID to set
     *  Only the owner of the token smart contract can call this function
     *  emits a `UpdatedTokenInformation` event
     */
    function setOnchainID(address _onchainID) external;

    /**
     *  @dev pauses the token contract, when contract is paused investors cannot transfer tokens anymore
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `Paused` event
     */
    function pause() external;

    /**
     *  @dev unpauses the token contract, when contract is unpaused investors can transfer tokens
     *  if their wallet is not blocked & if the amount to transfer is <= to the amount of free tokens
     *  This function can only be called by a wallet set as agent of the token
     *  emits an `Unpaused` event
     */
    function unpause() external;

    /**
     *  @dev sets an address frozen status for this token.
     *  @param _userAddress The address for which to update frozen status
     *  @param _freeze Frozen status of the address
     *  This function can only be called by a wallet set as agent of the token
     *  emits an `AddressFrozen` event
     */
    function setAddressFrozen(address _userAddress, bool _freeze) external;

    /**
     *  @dev freezes token amount specified for given address.
     *  @param _userAddress The address for which to update frozen tokens
     *  @param _amount Amount of Tokens to be frozen
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `TokensFrozen` event
     */
    function freezePartialTokens(
        address _userAddress,
        uint256 _amount
    ) external;

    /**
     *  @dev unfreezes token amount specified for given address
     *  @param _userAddress The address for which to update frozen tokens
     *  @param _amount Amount of Tokens to be unfrozen
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `TokensUnfrozen` event
     */
    function unfreezePartialTokens(
        address _userAddress,
        uint256 _amount
    ) external;

    /**
     *  @dev sets the Identity Registry for the token
     *  @param _identityRegistry the address of the Identity Registry to set
     *  Only the owner of the token smart contract can call this function
     *  emits an `IdentityRegistryAdded` event
     */
    function setIdentityRegistry(address _identityRegistry) external;

    /**
     *  @dev sets the compliance contract of the token
     *  @param _compliance the address of the compliance contract to set
     *  Only the owner of the token smart contract can call this function
     *  calls bindToken on the compliance contract
     *  emits a `ComplianceAdded` event
     */
    function setCompliance(address _compliance) external;

    /**
     *  @dev force a transfer of tokens between 2 whitelisted wallets
     *  In case the `from` address has not enough free tokens (unfrozen tokens)
     *  but has a total balance higher or equal to the `amount`
     *  the amount of frozen tokens is reduced in order to have enough free tokens
     *  to proceed the transfer, in such a case, the remaining balance on the `from`
     *  account is 100% composed of frozen tokens post-transfer.
     *  Require that the `to` address is a verified address,
     *  @param _from The address of the sender
     *  @param _to The address of the receiver
     *  @param _amount The number of tokens to transfer
     *  @return `true` if successful and revert if unsuccessful
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_from`
     *  emits a `Transfer` event
     */
    function forcedTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) external returns (bool);

    /**
     *  @dev mint tokens on a wallet
     *  Improved version of default mint method. Tokens can be minted
     *  to an address if only it is a verified address as per the security token.
     *  @param _to Address to mint the tokens to.
     *  @param _amount Amount of tokens to mint.
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `Transfer` event
     */
    function mint(address _to, uint256 _amount) external;

    /**
     *  @dev burn tokens on a wallet
     *  In case the `account` address has not enough free tokens (unfrozen tokens)
     *  but has a total balance higher or equal to the `value` amount
     *  the amount of frozen tokens is reduced in order to have enough free tokens
     *  to proceed the burn, in such a case, the remaining balance on the `account`
     *  is 100% composed of frozen tokens post-transaction.
     *  @param _userAddress Address to burn the tokens from.
     *  @param _amount Amount of tokens to burn.
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `TokensUnfrozen` event if `_amount` is higher than the free balance of `_userAddress`
     *  emits a `Transfer` event
     */
    function burn(address _userAddress, uint256 _amount) external;

    /**
     *  @dev recovery function used to force transfer tokens from a
     *  lost wallet to a new wallet for an investor.
     *  @param _lostWallet the wallet that the investor lost
     *  @param _newWallet the newly provided wallet on which tokens have to be transferred
     *  @param _investorOnchainID the onchainID of the investor asking for a recovery
     *  This function can only be called by a wallet set as agent of the token
     *  emits a `TokensUnfrozen` event if there is some frozen tokens on the lost wallet if the recovery process is successful
     *  emits a `Transfer` event if the recovery process is successful
     *  emits a `RecoverySuccess` event if the recovery process is successful
     *  emits a `RecoveryFails` event if the recovery process fails
     */
    function recoveryAddress(
        address _lostWallet,
        address _newWallet,
        address _investorOnchainID
    ) external returns (bool);

    /**
     *  @dev function allowing to issue transfers in batch
     *  Require that the msg.sender and `to` addresses are not frozen.
     *  Require that the total value should not exceed available balance.
     *  Require that the `to` addresses are all verified addresses,
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _toList The addresses of the receivers
     *  @param _amounts The number of tokens to transfer to the corresponding receiver
     *  emits _toList.length `Transfer` events
     */
    function batchTransfer(
        address[] calldata _toList,
        uint256[] calldata _amounts
    ) external;

    /**
     *  @dev function allowing to issue forced transfers in batch
     *  Require that `_amounts[i]` should not exceed available balance of `_fromList[i]`.
     *  Require that the `_toList` addresses are all verified addresses
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_fromList.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _fromList The addresses of the senders
     *  @param _toList The addresses of the receivers
     *  @param _amounts The number of tokens to transfer to the corresponding receiver
     *  This function can only be called by a wallet set as agent of the token
     *  emits `TokensUnfrozen` events if `_amounts[i]` is higher than the free balance of `_fromList[i]`
     *  emits _fromList.length `Transfer` events
     */
    function batchForcedTransfer(
        address[] calldata _fromList,
        address[] calldata _toList,
        uint256[] calldata _amounts
    ) external;

    /**
     *  @dev function allowing to mint tokens in batch
     *  Require that the `_toList` addresses are all verified addresses
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_toList.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _toList The addresses of the receivers
     *  @param _amounts The number of tokens to mint to the corresponding receiver
     *  This function can only be called by a wallet set as agent of the token
     *  emits _toList.length `Transfer` events
     */
    function batchMint(
        address[] calldata _toList,
        uint256[] calldata _amounts
    ) external;

    /**
     *  @dev function allowing to burn tokens in batch
     *  Require that the `_userAddresses` addresses are all verified addresses
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _userAddresses The addresses of the wallets concerned by the burn
     *  @param _amounts The number of tokens to burn from the corresponding wallets
     *  This function can only be called by a wallet set as agent of the token
     *  emits _userAddresses.length `Transfer` events
     */
    function batchBurn(
        address[] calldata _userAddresses,
        uint256[] calldata _amounts
    ) external;

    /**
     *  @dev function allowing to set frozen addresses in batch
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _userAddresses The addresses for which to update frozen status
     *  @param _freeze Frozen status of the corresponding address
     *  This function can only be called by a wallet set as agent of the token
     *  emits _userAddresses.length `AddressFrozen` events
     */
    function batchSetAddressFrozen(
        address[] calldata _userAddresses,
        bool[] calldata _freeze
    ) external;

    /**
     *  @dev function allowing to freeze tokens partially in batch
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _userAddresses The addresses on which tokens need to be frozen
     *  @param _amounts the amount of tokens to freeze on the corresponding address
     *  This function can only be called by a wallet set as agent of the token
     *  emits _userAddresses.length `TokensFrozen` events
     */
    function batchFreezePartialTokens(
        address[] calldata _userAddresses,
        uint256[] calldata _amounts
    ) external;

    /**
     *  @dev function allowing to unfreeze tokens partially in batch
     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,
     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN "OUT OF GAS" TRANSACTION
     *  @param _userAddresses The addresses on which tokens need to be unfrozen
     *  @param _amounts the amount of tokens to unfreeze on the corresponding address
     *  This function can only be called by a wallet set as agent of the token
     *  emits _userAddresses.length `TokensUnfrozen` events
     */
    function batchUnfreezePartialTokens(
        address[] calldata _userAddresses,
        uint256[] calldata _amounts
    ) external;
}

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.9;

interface IERC4626StakingPool {
    function borrow(
        uint256 _amount
    ) external returns (uint256);

    function buyPropertyTokens(
        address _propertyToken,
        uint256 _amountOfTokens,
        address _marketPlace,
        uint _repayAmount,
        address _propertyBasecurrency
    ) external;

    function afterRepay(uint256 amount, address marketplace) external;

    function decreaseAssetTotalSupply(uint256 _amount) external;

    function notiftyRewardToGauge(
        uint256 _rewardAmount
    ) external returns (uint256);

    function fees() external view returns (uint256);

    function swapStakeTokenWithCToken(
        address recipient,
        uint256 amountIn,
        address cToken
    ) external;

    function stake(uint256 assets) external returns (uint256 shares);

    function stake(
        uint256 assets,
        address sender
    ) external returns (uint256 shares);

    function stake(
        uint256 assets,
        address cTokensReceiver,
        address passOnPool,
        address sender,
        bool skipPassOnPoolTransfer,
        bool depositToPassOnPoolGauge
    ) external returns (uint256 shares);

    function withdraw(
        uint256 assets,
        address receiver,
        address owner_
    ) external returns (uint256 shares);

    function withdraw(
        uint256 assets,
        address receiver
    ) external returns (uint256 shares);

    function getAllowedCTokenAddresses()
        external
        view
        returns (address[] memory);

    function withdrawFromVaultRouter(
        uint256 _totalAmount,
        uint256 _reservePoolAmount,
        address _receiver,
        address _owner
    ) external;

    function decimals() external view returns (uint8);

    function normalStake(
        uint256 assets,
        address sender
    ) external returns (uint256);

    function stakeToken() external view returns (address);

    function xToken() external view returns (address);

    function gaugeAddress() external view returns (address);
}

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.9;

interface IFeeManager {
    function calculateXEQForBuy(
        address _token,
        uint256 _amountOfTokens
    ) external pure returns (uint256);

    function calculateXEQForSell(
        address _token,
        uint256 _amountOfTokens
    ) external pure returns (uint256);
}

// SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

import {IPriceFeed} from "./IPriceFeed.sol";

/// @dev interface
interface IMarketplace {
    event NewPropertyAdded(address legalToken, address wLegalToken);
    event PriceUpdated(address token, uint256 price);
    event NewIdentity(address Identity);
    event Swaped(address from, address to, uint256 amountIn, uint256 amountOut);
    event NewBid(
        address token,
        address bidder,
        uint256 amount,
        uint256 amountPerToken
    );
    event BuyFeesUpdated(uint newPercentage);
    event SellFeesUpdated(uint newPercentage);
    event FeeReceiverUpdated(address feeReceiver);
    event LiquidityWithdrawed(
        address to,
        address wLegalToken,
        uint amountToSend
    );

    event MarketplaceBorrowerUpdated(address _mpBorrower);

    event PropertyMigrated(address legalToken, address WLegalShares);

    enum State {
        Active,
        Paused
    }

    event BuyStateChanged(State);
    event SellStateChanged(State);
    event newAsk(
        address token,
        address offerer,
        uint256 amount,
        uint256 amountPerToken
    );
    struct property {
        address WLegalShares;
        uint256 totalLegalShares;
        uint256 lockedLegalShares;
        uint256 tokensPerLegalShares;
    }
    struct offer {
        uint256 amount;
        uint256 amountPerToken;
    }
    struct swapArgs {
        address from;
        address to;
        uint256 amountOfShares;
        address recipient;
    }

    struct Storage {
        uint256 PERCENTAGE_BASED_POINT;
        State buyState;
        State sellState;
        uint256 identityCount;
        uint256 poolId;
        address finder;
        address identity;
        address IAuthority;
        uint256 buyFeePercentage;
        uint256 sellFeePercentage;
        address feeReceiver;
        mapping(address => property) legalToProperty;
        mapping(bytes => bool) salts;
        mapping(address => uint256) tokenPrice;
        mapping(address => bool) tokenExisits;
        mapping(address => uint256) wLegalToPoolId;
        address[] legalProperties;
        mapping(address => mapping(address => uint256)) wLegalToTokens;
        address marketPlaceBorrower;
        address baseCurrency;
        address tokenWhitelist;
        mapping(address => mapping(BuySellState => State)) propertyToBuySellState;
        uint maxFeePercentage;
        uint pendingWithdrawalRequestTimestamp;
    }

    enum BuySellState {
        BuyState,
        SellState
    }

    struct ConstructorParams {
        address finder;
        uint256 buyFeePercentage;
        uint256 sellFeePercentage;
        address feeReceiver;
        address baseCurrency;
    }

    struct InitializationParams {
        uint256 PERCENTAGE_BASED_POINT;
        State buyState;
        State sellState;
        address finder;
        uint256 buyFeePercentage;
        uint256 sellFeePercentage;
        address feeReceiver;
        address baseCurrency;
    }

    struct AddPropertyParams {
        address legalToken;
        uint256 legalSharesToLock;
        uint256 tokensPerLegalShares;
        uint256 totalLegalShares;
        IPriceFeed.Property propertyDetails;
    }

    struct AddPropertyParams2 {
        address legalToken;
        uint256 legalSharesToLock;
        uint256 tokensPerLegalShares;
        uint256 totalLegalShares;
        IPriceFeed.Property propertyDetails;
        address WLegalShares;
    }

    struct QuotePriceParams {
        uint256 amountOfShares;
        address propertyCurrency;
        address quoteCurrency;
        address propertyPriceFeed;
        address quotePriceFeed;
        uint256 propertyPrice;
        address priceFeed;
    }

    struct TransferPropertyParams {
        uint256 amountOfShares;
        address to;
        address from;
        bool isBuying;
        uint256 quotePrice;
    }

    function swap(
        swapArgs memory args,
        bool isFeeInXEQ
    ) external returns (uint256);

    function getPropertyPrice(
        address from,
        address to
    )
        external
        view
        returns (
            IPriceFeed.Property memory,
            address _priceFeed,
            address _currencyToFeed
        );

    function getBuyFeePercentage() external view returns (uint256);

    function getSellFeePercentage() external view returns (uint256);

    function propertyQuotePrice(
        IMarketplace.QuotePriceParams memory _quoteParams
    ) external view returns (uint256 quotePrice);

    // function getLegalProperties()
    //     external
    //     view
    //     returns (address[] memory properties);
}

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.9;

/**
 * @title interface for storage struct and functions for PoolBorrower.sol
 */
interface IMarketPlaceBorrower {
    struct Storage {
        address poolToBorrowFrom;
        address allowedMarketPlace;
        uint256 amountBorrowed;
        address customVault;
    }

    function borrowTokens(
        uint256 _tokensToBorrowWithoutFees,
        address _propertyToken,
        uint256 _noOfTokens
    ) external;

    function buyPropertyTokens(
        address _propertyToken,
        uint256 _repayAmount,
        uint256 _currentPertokenPrice,
        address _propertyBasecurrency
    ) external;

    function getPoolToBorrowFromAddress() external view returns (address);
}

// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IPriceFeed {
    struct Property {
        uint256 price;
        address currency;
        address priceFeed;
    }

    struct ScalePriceParams {
        int256 price;
        uint8 priceDecimals;
        uint8 decimals;
    }

    struct Storage {
        mapping(string => IPriceFeed.Property) propertyDetails;
        mapping(address => address) currencyToFeed;
        mapping(string => address) nameToFeed;
    }

    function feedPriceChainlink(
        address _of
    ) external view returns (uint256 latestPrice);


    function getSharePriceInBaseCurrency(
        string memory _propertySymbol,
        address currency
    ) external view returns (uint256);

    //---------------------------------------------------------------------
    function setPropertyDetails(
        string memory _propertySymbol,
        Property calldata _propertyDetails
    ) external;

    function getPropertyDetail(
        string memory _propertySymbol
    ) external view returns (Property memory property);

    //---------------------------------------------------------------------

    // function setCurrencyToFeed(address _currency, address _feed) external;

    function getCurrencyToFeed(
        address _currency
    ) external view returns (address);
    //---------------------------------------------------------------------
}

//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

contract IPropertyToken {
    function addMinter(address account) external {}

    function mint(address _to, uint256 _amount) external {}

    function unlock(uint256 _amount) external {}
}

//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IRentShare {
    //----------------------------------------
    // Events
    //----------------------------------------

    event Deposit(address indexed user, uint256 indexed poolId, uint256 amount);
    event Withdraw(
        address indexed user,
        uint256 indexed poolId,
        uint256 amount
    );
    event HarvestRewards(
        uint256 indexed poolId,
        address indexed user,
        uint256 amount
    );
    event PoolCreated(uint256 indexed poolId);
    event RewardsPaused(uint256 indexed poolId);
    event RewardsUnpaused(uint256 indexed poolId);
    event PoolRewardUpdated(uint256 indexed poolId, uint256 indexed amount);
    event VaultRewardsHarvested(
        uint indexed poolId,
        address indexed sender,
        uint amount
    );
    //----------------------------------------
    // Structs
    //----------------------------------------

    // Staking user for a pool
    struct PoolStaker {
        uint256 amount; // The tokens quantity the user has staked.
        uint256 rewards; // The reward tokens quantity the user can harvest
        uint256 rewardDebt; // The amount relative to accumulatedRewardsPerShare the user can't get as reward
    }

    // Staking pool
    struct Pool {
        IERC20 stakeToken; // Token to be staked
        uint256 tokensStaked; // Total tokens staked
        uint256 lastRewardedTimestamp; // Last block number the user had their rewards calculated
        uint256 accumulatedRewardsPerShare; // Accumulated rewards per share times REWARDS_PRECISION
        uint256 rewardTokensPerSecond; // Number of reward tokens minted per block for this pool
    }

    struct Storage {
        Pool[] pools; // Staking pools
        address rewardToken; // Token to be payed as reward
        address finder; //finder address
        uint256 REWARDS_PRECISION; // A big number to perform mul and div operations
        // Mapping poolId => staker address => PoolStaker
        mapping(uint256 => mapping(address => PoolStaker)) poolStakers;
        mapping(string => uint256) symbolToPoolId;
        mapping(string => bool) symbolExisit;
        mapping(uint256 => bool) rewardsPaused;
        mapping(address => mapping(string => uint)) userToPropertyRentClaimTimestamp;
        mapping(uint => string) poolIdToSymbol;
        uint harvestDelay; // delay in seconds to harvest rewards
        uint maxHarvestDelay; // max delay to harvest rewards possible
        mapping(address => uint) pendingHarvestRewardsTimestamps; // keep track of user to harvestRewards timestamp
    }

    //----------------------------------------
    // Function Sig
    //----------------------------------------

    function createPool(
        IERC20 _stakeToken,
        address maintainer,
        string memory symbol,
        uint256 _poolId
    ) external returns (uint256 poolId);

    function deposit(
        uint256 _poolId,
        address _sender,
        uint256 _amount
    ) external;

    function withdraw(
        uint256 _poolId,
        address _sender,
        uint256 _amount
    ) external;

    function harvestRewards(
        string memory symbol
    ) external returns (uint rewardsHarvested);

    function harvestRewardsForVault(
        string memory symbol
    ) external returns (uint rewardsHarvested);

    function isPropertyTokenWhitelisted(
        string memory propertySymbol
    ) external view returns (uint);

    function getPoolIdToSymbol(
        uint poolId
    ) external view returns (string memory);

    function requestHarvestReward() external;

    function getRewardToken() external view returns (address);
}

// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.9;
import {IMarketplace} from "../Interfaces/IMarketplace.sol";
import {ZeroXInterfaces} from "../core/Constants.sol";
import {IFinder} from "../core/interfaces/IFinder.sol";
import {IMarketPlaceBorrower} from "../Interfaces/IMarketPlaceBorrower.sol";
import {IFeeManager} from "../Interfaces/IFeeManager.sol";
import {IToken} from "../ERC3643/contracts/token/IToken.sol";
import {IPriceFeed} from "../Interfaces/IPriceFeed.sol";
import {IRentShare} from "../Interfaces/IRentShare.sol";
import {IERC20, SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IPropertyToken} from "../Interfaces/IPropertyToken.sol";
import {WadRayMath} from "./WadRayMath.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

import {IERC4626StakingPool} from "./../Interfaces/IERC4626StakingPool.sol";
import "./../core/libs/Errors.sol";

/**
 * @title Multi LP Synthereum pool lib with main functions
 */

library MarketplaceLib {
    using SafeERC20 for IERC20;
    using WadRayMath for uint256;

    event NewPropertyAdded(address legalToken, address wLegalToken);
    event Swapped(
        address from,
        address to,
        uint256 amountIn,
        uint256 amountOut
    );
    enum State {
        Active,
        Paused
    }

    function initialize(
        IMarketplace.Storage storage _storageParams,
        IMarketplace.InitializationParams calldata _params,
        address sender
    ) external {
        _storageParams.PERCENTAGE_BASED_POINT = 10000;
        _storageParams.buyState = _params.buyState;
        _storageParams.sellState = _params.sellState;

        _require(
            _params.buyFeePercentage > 0 &&
                _params.buyFeePercentage <=
                _storageParams.PERCENTAGE_BASED_POINT,
            Errors.INVALID_FEE_PERCENTAGE
        );
        _require(_params.feeReceiver != address(0), Errors.ZERO_ADDRESS);
        if (_params.finder == address(0)) {
            _revert(Errors.ZERO_ADDRESS);
        }
        if (_params.baseCurrency == address(0)) {
            _revert(Errors.ZERO_ADDRESS);
        }
        _storageParams.finder = _params.finder;
        _storageParams.buyFeePercentage = _params.buyFeePercentage;
        _storageParams.sellFeePercentage = _params.sellFeePercentage;
        _storageParams.feeReceiver = _params.feeReceiver;
        _storageParams.baseCurrency = _params.baseCurrency;

        bytes32 salt = keccak256(abi.encodePacked(sender));
        bytes memory Identitybytecode = abi.encodePacked(
            IFinder(_storageParams.finder).getImplementationBytecode(
                ZeroXInterfaces.IDENTITY
            ),
            abi.encode(address(this), true)
        );
        _storageParams.identity = _createContract(salt, Identitybytecode);

        bytes memory impAuthbytecode = abi.encodePacked(
            IFinder(_storageParams.finder).getImplementationBytecode(
                ZeroXInterfaces.IMPLEMENTATION_AUTHORITY
            ),
            abi.encode(_storageParams.identity)
        );
        _storageParams.IAuthority = _createContract(salt, impAuthbytecode);
        _storageParams.maxFeePercentage = 1000; // 10%
    }

    function addProperty(
        IMarketplace.Storage storage _storageParams,
        IMarketplace.AddPropertyParams calldata _propertyParams
    ) external returns (address) {
        if (
            _storageParams
                .legalToProperty[_propertyParams.legalToken]
                .WLegalShares != address(0x00)
        ) {
            _revert(Errors.PROPERTY_ALREADY_EXIST);
        }
        if (_propertyParams.legalToken == address(0x00)) {
            _revert(Errors.ZERO_ADDRESS);
        }
        if (
            _propertyParams.legalSharesToLock == 0 ||
            _propertyParams.tokensPerLegalShares == 0
        ) {
            _revert(Errors.NON_ZERO_NUMBER_REQUIRED);
        }
        if (
            _propertyParams.totalLegalShares < _propertyParams.legalSharesToLock
        ) {
            _revert(Errors.LOCK_AMOUNT_LESS_THAN_TOTAL);
        }
        if (_propertyParams.propertyDetails.price == 0) {
            _revert(Errors.NON_ZERO_NUMBER_REQUIRED);
        }

        bytes32 salt = keccak256(abi.encodePacked(_propertyParams.legalToken));
        //bytes memory creationCode = type(PropertyToken).creationCode;
        address rentShare = IFinder(_storageParams.finder)
            .getImplementationAddress(ZeroXInterfaces.RENT_SHARE);
        bytes memory bytecode = abi.encodePacked(
            IFinder(_storageParams.finder).getImplementationBytecode(
                ZeroXInterfaces.PROPERTY_TOKEN
            ),
            abi.encode(
                _storageParams.finder,
                msg.sender,
                _storageParams.poolId,
                string.concat(
                    "W",
                    bytes(IToken(_propertyParams.legalToken).name())
                ),
                string.concat(
                    "W",
                    bytes(IToken(_propertyParams.legalToken).symbol())
                ),
                0
            )
        );

        address WLegalShares = _createContract(salt, bytecode);
        _storageParams.propertyToBuySellState[WLegalShares][
            IMarketplace.BuySellState.BuyState
        ] = IMarketplace.State.Active;
        _storageParams.propertyToBuySellState[WLegalShares][
            IMarketplace.BuySellState.SellState
        ] = IMarketplace.State.Active;
        _storageParams.wLegalToPoolId[WLegalShares] = IRentShare(rentShare)
            .createPool(
                IERC20(WLegalShares),
                WLegalShares,
                IERC20Metadata(WLegalShares).symbol(),
                _storageParams.poolId
            );
        return WLegalShares;
    }

    function _addProperty(
        IMarketplace.Storage storage _storageParams,
        IMarketplace.AddPropertyParams2 calldata _propertyParams
    ) external {
        // _storageParams
        //     .legalToProperty[_propertyParams.legalToken]
        //     .lockedLegalShares += _propertyParams.legalSharesToLock;

        _storageParams.legalToProperty[
            _propertyParams.legalToken
        ] = IMarketplace.property(
            _propertyParams.WLegalShares,
            _propertyParams.totalLegalShares,
            _propertyParams.legalSharesToLock,
            _propertyParams.tokensPerLegalShares
        );
        IPriceFeed(
            IFinder(_storageParams.finder).getImplementationAddress(
                ZeroXInterfaces.PRICE_FEED
            )
        ).setPropertyDetails(
                IERC20Metadata(_propertyParams.WLegalShares).symbol(),
                _propertyParams.propertyDetails
            );

        _storageParams.tokenExisits[_propertyParams.WLegalShares] = true;

        assert(
            _storageParams.wLegalToPoolId[_propertyParams.WLegalShares] ==
                _storageParams.poolId
        );
        _storageParams.poolId += 1;
        _storageParams.legalProperties.push(_propertyParams.legalToken);
        emit NewPropertyAdded(
            _propertyParams.legalToken,
            _propertyParams.WLegalShares
        );
    }

    function _propertyQuotePrice(
        IMarketplace.QuotePriceParams memory _quoteParams
    ) external view returns (uint256 quotePrice) {
        uint8 propertyCurrencyDecimals = IERC20Metadata(
            _quoteParams.propertyCurrency
        ).decimals();
        uint8 quoteCurrencyDecimals = IERC20Metadata(_quoteParams.quoteCurrency)
            .decimals();

        uint256 propetyCurrencyInUsd = IPriceFeed(_quoteParams.priceFeed)
            .feedPriceChainlink(_quoteParams.propertyPriceFeed);

        uint256 quotePriceInUsd = IPriceFeed(_quoteParams.priceFeed)
            .feedPriceChainlink(_quoteParams.quotePriceFeed);
        // coverting property price in 18 decimals
        _quoteParams.propertyPrice =
            _quoteParams.propertyPrice *
            (10 ** (18 - propertyCurrencyDecimals));

        // getting property price in usd Feed
        // converting _propertyPrice from 18 decimals to 27 decimals precision
        // converting propetyCurrencyInUsd from 18 decimals to 27 decimals precision
        // multiplying propertyPrice(Price in its own currency set by admin) with property
        // currency price in Usd and then dividing with RAY to get end result in RAY
        // propertyPriceInUsd result will be in USD form in RAY = 1e27 decimals

        uint256 propertyPriceInUsd = (_quoteParams.propertyPrice.wadToRay())
            .rayMul(propetyCurrencyInUsd.wadToRay())
            .rayDiv(WadRayMath.RAY);

        // getting property price in quote feed
        // dividing propertyPriceInUsd with quote price
        // output of propertyPrice will be in quote price

        uint256 propertyPriceInQuote = (propertyPriceInUsd).rayDiv(
            quotePriceInUsd.wadToRay()
        );

        // price of property in other feed's token decimals
        // getting the price of property in quote for all amount of shares
        // end result will be quoteCurrency decimals

        quotePrice = (
            ((_quoteParams.amountOfShares *
                (propertyPriceInQuote.rayToWad().wadDiv(WadRayMath.WAD))) /
                (10 ** (18 - quoteCurrencyDecimals)))
        );
    }

    function _transferProperty(
        IMarketplace.Storage storage _storageParams,
        IMarketplace.TransferPropertyParams memory _transferParams,
        address sender,
        bool isFeeInXEQ,
        address recipient
    ) external returns (uint256) {
        // buyProperty
        if (_transferParams.isBuying) {
            uint amountPaidToBuyProperty = _handleBuyProperty(
                _storageParams,
                _transferParams,
                sender,
                isFeeInXEQ,
                recipient
            );

            emit Swapped(
                _transferParams.from,
                _transferParams.to,
                _transferParams.quotePrice,
                _transferParams.amountOfShares
            );
            return amountPaidToBuyProperty;
        }
        // sell property
        else {
            (IPriceFeed.Property memory _property, , ) = _getPropertyPrice(
                _storageParams,
                _transferParams.from, // currency
                _transferParams.to // WLEGAL
            );
            _require(
                _property.currency == _transferParams.from,
                Errors.INVALID_OUTPUT_CURRENCY
            );
            IERC20(_transferParams.to).safeTransferFrom(
                sender,
                IMarketPlaceBorrower(_storageParams.marketPlaceBorrower)
                    .getPoolToBorrowFromAddress(), // transferring property tokens directly to the POOL from where this contract is borrowing funds from
                _transferParams.amountOfShares
            );

            // getting funds from staking Pool through MarketplaceBorrower
            _borrowTokens(
                _storageParams.marketPlaceBorrower,
                _transferParams.quotePrice, // tokens to borrow
                _transferParams.to,
                _transferParams.amountOfShares
            );

            // transfer fee to fee reciever
            _transferSellFee(
                _storageParams,
                _transferParams.from,
                _transferParams.to, // wlegaltoken
                _transferParams.quotePrice,
                sender,
                isFeeInXEQ
            );

            // transfer tokens to user
            uint256 tokensTranferredToUser = _transferTokensToUser(
                _storageParams,
                _transferParams.from, // currency tokens
                recipient,
                _transferParams.quotePrice,
                isFeeInXEQ
            );

            // IERC20(_transferParams.from).safeTransfer(
            //     sender,
            //     _transferParams.quotePrice
            // );
            emit Swapped(
                _transferParams.to,
                _transferParams.from,
                _transferParams.amountOfShares,
                _transferParams.quotePrice
            );
            return tokensTranferredToUser;
        }
    }

    function isTrustedForwarder(
        IMarketplace.Storage storage _storageParams,
        address _forwarder
    ) external view returns (bool) {
        try
            IFinder(_storageParams.finder).getImplementationAddress(
                ZeroXInterfaces.TRUSTED_FORWARDER
            )
        returns (address trustedForwarder) {
            if (_forwarder == trustedForwarder) {
                return true;
            } else {
                return false;
            }
        } catch {
            return false;
        }
    }

    //----------------------------------------
    // External view
    //----------------------------------------

    /**
     * @notice to get all legal Property addresses
     */
    function getLegalProperties(
        IMarketplace.Storage storage _storageParams
    ) external view returns (address[] memory) {
        uint256 len = _storageParams.legalProperties.length;
        address[] memory properties = new address[](len - 1);
        properties = _storageParams.legalProperties;
        return properties;
    }

    //----------------------------------------
    // Internal
    //----------------------------------------

    /**
     * @notice - create2 function, for deterministic address.
     * @param _salt - unique identifier
     * @param _contractCode - bytecode packed along with constructor params.
     */
    function _createContract(
        bytes32 _salt,
        bytes memory _contractCode
    ) internal returns (address payable _contract) {
        assembly {
            let p := add(_contractCode, 0x20)
            let n := mload(_contractCode)
            _contract := create2(0, p, n, _salt)
            if iszero(extcodesize(_contract)) {
                revert(0, 0)
            }
        }
    }

    /**
     * @notice - updates marketPlace borrower.
     * @param _address - new MarketplaceBorrower address
     */
    function _updateMarketplaceBorrower(
        IMarketplace.Storage storage _storageParams,
        address _address
    ) internal {
        if (_address == address(0x00)) {
            _revert(Errors.ZERO_ADDRESS);
        }
        _storageParams.marketPlaceBorrower = _address;
    }

    /**
     * @notice - borrows tokens from marketPlaceBorrower.
     * @param _mpBorrower marketplace borrower address
     * @param _tokensToBorrowWithoutFees amount of tokens to borrow
     */
    function _borrowTokens(
        address _mpBorrower,
        uint256 _tokensToBorrowWithoutFees,
        address _propertyToken,
        uint256 _noOfTokens
    ) internal {
        IMarketPlaceBorrower(_mpBorrower).borrowTokens(
            _tokensToBorrowWithoutFees,
            _propertyToken,
            _noOfTokens
        );
    }

    function _transferSellFee(
        IMarketplace.Storage storage _storageParams,
        address _token,
        address _wLegalToken,
        uint256 _quotePrice,
        address sender,
        bool _feeInXEQ
    ) internal {
        uint256 fee = (_quotePrice * _storageParams.sellFeePercentage) /
            _storageParams.PERCENTAGE_BASED_POINT;

        if (_feeInXEQ) {
            _transferFromXEQFromUser(
                _storageParams,
                _token,
                fee,
                sender,
                false // becaise of property sell
            );
            return;
        }
        address _priceFeed = IFinder(_storageParams.finder)
            .getImplementationAddress(ZeroXInterfaces.PRICE_FEED);
        IPriceFeed.Property memory _property = IPriceFeed(_priceFeed)
            .getPropertyDetail(IERC20Metadata(_wLegalToken).symbol());
        // transferring fees to fee receiver
        IERC20(_property.currency).safeTransfer(
            _storageParams.feeReceiver,
            fee
        );
    }

    function _transferTokensToUser(
        IMarketplace.Storage storage _storageParams,
        address _token,
        address sender,
        uint256 _quotePrice,
        bool isFeeInXEQ
    ) internal returns (uint256) {
        uint256 totalFeePercentage;
        if (isFeeInXEQ) {
            totalFeePercentage = IERC4626StakingPool(
                IMarketPlaceBorrower(_storageParams.marketPlaceBorrower)
                    .getPoolToBorrowFromAddress()
            ).fees(); // Pool fee i.e 3.75 %
        } else {
            totalFeePercentage =
                _storageParams.sellFeePercentage +
                IERC4626StakingPool(
                    IMarketPlaceBorrower(_storageParams.marketPlaceBorrower)
                        .getPoolToBorrowFromAddress()
                ).fees(); // protolcolfee + pool fee. e.g 1.25 % + 3.75
        }

        uint256 fee = (_quotePrice * totalFeePercentage) /
            _storageParams.PERCENTAGE_BASED_POINT;
        uint256 amountToTransferToUser = _quotePrice - fee;
        // transferring tokens to user
        IERC20(_token).safeTransfer(sender, amountToTransferToUser);
        return amountToTransferToUser;
    }

    function _buyProperty(
        IMarketplace.Storage storage _storageParams,
        IMarketplace.TransferPropertyParams memory _transferParams,
        address recipient,
        address propertyCurrency
    ) internal {
        address poolToBorrowFrom = IMarketPlaceBorrower(
            _storageParams.marketPlaceBorrower
        ).getPoolToBorrowFromAddress();

        (
            uint256 _mPLiquidity,
            uint256 _poolLiquidity
        ) = _getWLegalTokenInMPandPool(
                _storageParams,
                _transferParams.to,
                poolToBorrowFrom
            );
        uint256 askedTokens = _transferParams.amountOfShares;

        // when the from is equal to property's base currency
        if (_transferParams.from == propertyCurrency) {
            // cheking if pool + mp combined have enough liquidity
            if (_mPLiquidity + _poolLiquidity < askedTokens) {
                _revert(Errors.INSUFFICIENT_WLEGAL_LIQUIDITY);
            }

            uint256 currentPertokenPrice = _transferParams.quotePrice /
                askedTokens;

            // if poolLiq >= asked amount , just return after transferring
            if (_poolLiquidity >= askedTokens) {
                // transferring toknes to the pool for buying
                IERC20(_transferParams.from).safeTransfer(
                    poolToBorrowFrom,
                    _transferParams.quotePrice
                );
                IMarketPlaceBorrower(_storageParams.marketPlaceBorrower)
                    .buyPropertyTokens(
                        _transferParams.to,
                        _transferParams.quotePrice,
                        currentPertokenPrice,
                        propertyCurrency
                    );

                IERC20(_transferParams.to).safeTransfer(recipient, askedTokens);
                return;
            }
            // now saying Pool to send all available liq to MP
            if (_poolLiquidity != 0) {
                uint256 tokensTosendToPool = currentPertokenPrice *
                    _poolLiquidity;

                IERC20(_transferParams.from).safeTransfer(
                    poolToBorrowFrom,
                    tokensTosendToPool
                );
                _storageParams.wLegalToTokens[_transferParams.to][
                    _transferParams.from
                ] += (_transferParams.quotePrice - tokensTosendToPool);
                IMarketPlaceBorrower(_storageParams.marketPlaceBorrower)
                    .buyPropertyTokens(
                        _transferParams.to,
                        tokensTosendToPool,
                        currentPertokenPrice,
                        propertyCurrency
                    );
            } else {
                _storageParams.wLegalToTokens[_transferParams.to][
                    _transferParams.from
                ] += _transferParams.quotePrice;
            }
            IERC20(_transferParams.to).safeTransfer(recipient, askedTokens);
        } else {
            _require(
                _mPLiquidity >= askedTokens,
                Errors.INSUFFICIENT_WLEGAL_LIQUIDITY_MP
            );
            IERC20(_transferParams.to).safeTransfer(recipient, askedTokens);
        }
    }

    // function _scaleAmount(
    //     address _inputCurrency,
    //     address _baseCurrency,
    //     uint _amountInBaseCurrency
    // ) internal returns (uint) {
    //     uint8 _inputCurrencyDecimals = IERC20Metadata(_inputCurrency)
    //         .decimals();
    //     uint8 _baseCurrencyDecimals = IERC20Metadata(_baseCurrency).decimals();
    //     if (_inputCurrencyDecimals == _baseCurrencyDecimals)
    //         return _amountInBaseCurrency;

    //     if (_inputCurrencyDecimals > _baseCurrencyDecimals) {
    //         return
    //             _amountInBaseCurrency *
    //             (10 ** (_inputCurrencyDecimals - _baseCurrencyDecimals));
    //     }
    //     return
    //         _amountInBaseCurrency /
    //         (10 ** (_baseCurrencyDecimals - _inputCurrencyDecimals));
    // }

    function _getWLegalTokenInMPandPool(
        IMarketplace.Storage storage _storageParams,
        address _wLegal,
        address _poolToBorrowFrom
    ) internal view returns (uint256, uint256) {
        (_storageParams);
        return (
            IERC20(_wLegal).balanceOf(address(this)), // Marketplace liq
            IERC20(_wLegal).balanceOf(_poolToBorrowFrom) // Pool liq
        );
    }

    function _handleBuyProperty(
        IMarketplace.Storage storage _storageParams,
        IMarketplace.TransferPropertyParams memory _transferParams,
        address sender,
        bool isFeeInXEQ,
        address recipient
    ) internal returns (uint) {
        (IPriceFeed.Property memory _property, , ) = _getPropertyPrice(
            _storageParams,
            _transferParams.from, // from
            _transferParams.to // WLEGAL
        );
        uint amountPaidToBuyProperty;
        uint256 buyFeeAmount = ((_transferParams.quotePrice *
            _storageParams.buyFeePercentage) /
            _storageParams.PERCENTAGE_BASED_POINT);
        if (isFeeInXEQ) {
            _transferFromXEQFromUser(
                _storageParams,
                _transferParams.from,
                buyFeeAmount,
                sender,
                true
            );
            amountPaidToBuyProperty = _transferParams.quotePrice;
            IERC20(_transferParams.from).safeTransferFrom(
                sender,
                address(this),
                amountPaidToBuyProperty
            );
        } else {
            amountPaidToBuyProperty = _transferParams.quotePrice + buyFeeAmount;
            IERC20(_transferParams.from).safeTransferFrom(
                sender,
                address(this),
                amountPaidToBuyProperty
            );

            IERC20(_transferParams.from).safeTransfer(
                _storageParams.feeReceiver,
                buyFeeAmount
            );
        }
        _buyProperty(
            _storageParams,
            _transferParams,
            recipient,
            _property.currency
        );
        return amountPaidToBuyProperty;
    }

    // function _deductBuyFeesInXEQ(
    //     IMarketplace.Storage storage _storageParams,
    //     IMarketplace.TransferPropertyParams memory _transferParams
    // ) internal {

    // }

    function _transferFromXEQFromUser(
        IMarketplace.Storage storage _storageParams,
        address baseToken,
        uint256 amountOfBaseTokens, // amount of tokens(other then XEQ)
        address sender,
        bool isBuy
    ) internal {
        address feeManager = IFinder(_storageParams.finder)
            .getImplementationAddress(ZeroXInterfaces.FEEMANAGER);
        uint256 amountOfXEQToTransferFrom;
        if (isBuy) {
            amountOfXEQToTransferFrom = IFeeManager(feeManager)
                .calculateXEQForBuy(baseToken, amountOfBaseTokens);
        } else {
            amountOfXEQToTransferFrom = IFeeManager(feeManager)
                .calculateXEQForSell(baseToken, amountOfBaseTokens);
        }

        address xeq = IFinder(_storageParams.finder).getImplementationAddress(
            ZeroXInterfaces.XEQ
        );

        IERC20(xeq).safeTransferFrom(
            sender,
            _storageParams.feeReceiver,
            amountOfXEQToTransferFrom
        );
    }

    function _getPropertyPrice(
        IMarketplace.Storage storage _storageParams,
        address _from,
        address _to
    ) internal view returns (IPriceFeed.Property memory, address, address) {
        address _priceFeed = IFinder(_storageParams.finder)
            .getImplementationAddress(ZeroXInterfaces.PRICE_FEED);
        address _currencyToFeed = IPriceFeed(_priceFeed).getCurrencyToFeed(
            _from
        );

        if ((_currencyToFeed == address(0))) {
            _revert(Errors.INVALID_CURRENCY);
        }

        return (
            IPriceFeed(_priceFeed).getPropertyDetail(
                IERC20Metadata(_to).symbol()
            ),
            _priceFeed,
            _currencyToFeed
        );
        // return 1;
    }
}

// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

/**
 * @title WadRayMath library
 * @author Aave
 * @notice Provides functions to perform calculations with Wad and Ray units
 * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers
 * with 27 digits of precision)
 * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.
 */
library WadRayMath {
    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly
    uint256 internal constant WAD = 1e18;
    uint256 internal constant HALF_WAD = 0.5e18;

    uint256 internal constant RAY = 1e27;
    uint256 internal constant HALF_RAY = 0.5e27;

    uint256 internal constant WAD_RAY_RATIO = 1e9;

    /**
     * @dev Multiplies two wad, rounding half up to the nearest wad
     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
     * @param a Wad
     * @param b Wad
     * @return c = a*b, in wad
     */
    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b
        assembly {
            if iszero(
                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))
            ) {
                revert(0, 0)
            }

            c := div(add(mul(a, b), HALF_WAD), WAD)
        }
    }

    /**
     * @dev Divides two wad, rounding half up to the nearest wad
     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
     * @param a Wad
     * @param b Wad
     * @return c = a/b, in wad
     */
    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD
        assembly {
            if or(
                iszero(b),
                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))
            ) {
                revert(0, 0)
            }

            c := div(add(mul(a, WAD), div(b, 2)), b)
        }
    }

    /**
     * @notice Multiplies two ray, rounding half up to the nearest ray
     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
     * @param a Ray
     * @param b Ray
     * @return c = a raymul b
     */
    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
        assembly {
            if iszero(
                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))
            ) {
                revert(0, 0)
            }

            c := div(add(mul(a, b), HALF_RAY), RAY)
        }
    }

    /**
     * @notice Divides two ray, rounding half up to the nearest ray
     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
     * @param a Ray
     * @param b Ray
     * @return c = a raydiv b
     */
    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY
        assembly {
            if or(
                iszero(b),
                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))
            ) {
                revert(0, 0)
            }

            c := div(add(mul(a, RAY), div(b, 2)), b)
        }
    }

    /**
     * @dev Casts ray down to wad
     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
     * @param a Ray
     * @return b = a converted to wad, rounded half up to the nearest wad
     */
    function rayToWad(uint256 a) internal pure returns (uint256 b) {
        assembly {
            b := div(a, WAD_RAY_RATIO)
            let remainder := mod(a, WAD_RAY_RATIO)
            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {
                b := add(b, 1)
            }
        }
    }

    /**
     * @dev Converts wad up to ray
     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
     * @param a Wad
     * @return b = a converted in ray
     */
    function wadToRay(uint256 a) internal pure returns (uint256 b) {
        // to avoid overflow, b/WAD_RAY_RATIO == a
        assembly {
            b := mul(a, WAD_RAY_RATIO)

            if iszero(eq(div(b, WAD_RAY_RATIO), a)) {
                revert(0, 0)
            }
        }
    }
}