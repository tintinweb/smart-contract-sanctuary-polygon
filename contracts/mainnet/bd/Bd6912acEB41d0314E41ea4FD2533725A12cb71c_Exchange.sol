/**
 *Submitted for verification at polygonscan.com on 2023-07-11
*/

pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Exchange
*/

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract Exchange {

	address owner;
	struct referralRecord { bool hasDeposited; address referringAddress; uint256 unclaimedRewards1To2; uint256 referralsAmt1To2AtLevel0; uint256 referralsCount1To2AtLevel0; }
	mapping(address => referralRecord) public referralRecordMap;
	event ReferralAddressAdded (address indexed referredAddress);
	uint256 public from1To2AmtInBank = uint256(0);
	uint256 public totalUnclaimedRewards1To2 = uint256(0);
	uint256 public totalClaimedRewards1To2 = uint256(0);
	event Exchanged (address indexed tgt);

	constructor() {
		owner = 0xBDCBD23316AAA2aDecA774e107868adCE38cC69E;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

/**
 * Function exchange1To2
 * Minimum Exchange Amount : 1000000000 in terms of Coin WrappedUSDR. 1 Coin WrappedUSDR is represented by 10^9.
 * The function takes in 1 variable, (zero or a positive integer) v0. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that v0 is greater than or equals to 1000000000
 * calls addReferral1To2 with variable _amt as v0
 * calls ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as v0
 * updates from1To2AmtInBank as (from1To2AmtInBank) + (((v0) * (1000000) * (100)) / (100000000))
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((((v0) * ((1000000) - (1000000))) / (1000000)) * (220000000))
 * if ((((v0) * ((1000000) - (1000000))) / (1000000)) * (220000000)) is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as ((((v0) * ((1000000) - (1000000))) / (1000000)) * (220000000)))
 * emits event Exchanged with inputs the address that called this function
*/
	function exchange1To2(uint256 v0) public {
		require((v0 >= uint256(1000000000)), "Too little exchanged");
		addReferral1To2(v0);
		ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).transferFrom(msg.sender, address(this), v0);
		from1To2AmtInBank  = (from1To2AmtInBank + ((v0 * uint256(1000000) * uint256(100)) / uint256(100000000)));
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= (((v0 * (uint256(1000000) - uint256(1000000))) / uint256(1000000)) * uint256(220000000))), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if (((((v0 * (uint256(1000000) - uint256(1000000))) / uint256(1000000)) * uint256(220000000)) > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, (((v0 * (uint256(1000000) - uint256(1000000))) / uint256(1000000)) * uint256(220000000)));
		}
		emit Exchanged(msg.sender);
	}

/**
 * Function withdrawReferral1To2
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that (referralRecordMap with element the address that called this function with element unclaimedRewards1To2) is greater than or equals to _amt
 * updates referralRecordMap (Element the address that called this function) (Entity unclaimedRewards1To2) as (referralRecordMap with element the address that called this function with element unclaimedRewards1To2) - (_amt)
 * updates totalUnclaimedRewards1To2 as (totalUnclaimedRewards1To2) - (_amt)
 * updates totalClaimedRewards1To2 as (totalClaimedRewards1To2) + (_amt)
 * checks that (ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _amt
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawReferral1To2(uint256 _amt) public {
		require((referralRecordMap[msg.sender].unclaimedRewards1To2 >= _amt), "Insufficient referral rewards to withdraw");
		referralRecordMap[msg.sender].unclaimedRewards1To2  = (referralRecordMap[msg.sender].unclaimedRewards1To2 - _amt);
		totalUnclaimedRewards1To2  = (totalUnclaimedRewards1To2 - _amt);
		totalClaimedRewards1To2  = (totalClaimedRewards1To2 + _amt);
		require((ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).balanceOf(address(this)) >= _amt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function addReferral1To2
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can only be called by other functions in this contract. It does the following :
 * creates an internal variable referringAddress with initial value referralRecordMap with element the address that called this function with element referringAddress
 * creates an internal variable referralsAllocated with initial value 0
 * if not referralRecordMap with element the address that called this function with element hasDeposited then (updates referralRecordMap (Element the address that called this function) (Entity hasDeposited) as true)
 * if referringAddress is equals to Address 0 then (returns referralsAllocated as output)
 * updates referralRecordMap (Element referringAddress) (Entity referralsAmt1To2AtLevel0) as (referralRecordMap with element referringAddress with element referralsAmt1To2AtLevel0) + (_amt)
 * updates referralRecordMap (Element referringAddress) (Entity referralsCount1To2AtLevel0) as (referralRecordMap with element referringAddress with element referralsCount1To2AtLevel0) + (1)
 * updates referralRecordMap (Element referringAddress) (Entity unclaimedRewards1To2) as (referralRecordMap with element referringAddress with element unclaimedRewards1To2) + (((7) * (_amt)) / (100))
 * updates referralsAllocated as (referralsAllocated) + (((7) * (_amt)) / (100))
 * updates referringAddress as referralRecordMap with element referringAddress with element referringAddress
 * updates totalUnclaimedRewards1To2 as (totalUnclaimedRewards1To2) + (referralsAllocated)
 * returns referralsAllocated as output
*/
	function addReferral1To2(uint256 _amt) internal returns (uint256) {
		address referringAddress = referralRecordMap[msg.sender].referringAddress;
		uint256 referralsAllocated = uint256(0);
		if (!(referralRecordMap[msg.sender].hasDeposited)){
			referralRecordMap[msg.sender].hasDeposited  = true;
		}
		if ((referringAddress == address(0))){
			return referralsAllocated;
		}
		referralRecordMap[referringAddress].referralsAmt1To2AtLevel0  = (referralRecordMap[referringAddress].referralsAmt1To2AtLevel0 + _amt);
		referralRecordMap[referringAddress].referralsCount1To2AtLevel0  = (referralRecordMap[referringAddress].referralsCount1To2AtLevel0 + uint256(1));
		referralRecordMap[referringAddress].unclaimedRewards1To2  = (referralRecordMap[referringAddress].unclaimedRewards1To2 + ((uint256(7) * _amt) / uint256(100)));
		referralsAllocated  = (referralsAllocated + ((uint256(7) * _amt) / uint256(100)));
		referringAddress  = referralRecordMap[referringAddress].referringAddress;
		totalUnclaimedRewards1To2  = (totalUnclaimedRewards1To2 + referralsAllocated);
		return referralsAllocated;
	}

/**
 * Function from1To2TaxWithdrawAmt
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to from1To2AmtInBank
 * if from1To2AmtInBank is strictly greater than 0 then (calls ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at transfer function  with variable recipient as (the address that called this function), variable amount as from1To2AmtInBank)
 * updates from1To2AmtInBank as 0
*/
	function from1To2TaxWithdrawAmt() public onlyOwner {
		require((ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).balanceOf(address(this)) >= from1To2AmtInBank), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((from1To2AmtInBank > uint256(0))){
			ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).transfer(msg.sender, from1To2AmtInBank);
		}
		from1To2AmtInBank  = uint256(0);
	}

/**
 * Function withdrawToken1
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (totalUnclaimedRewards1To2) + (from1To2AmtInBank))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawToken1(uint256 _amt) public onlyOwner {
		require((ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).balanceOf(address(this)) >= (_amt + totalUnclaimedRewards1To2 + from1To2AmtInBank)), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xAF0D9D65fC54de245cdA37af3d18cbEc860A4D4b)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function withdrawToken2
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _amt
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xD289c01528921B5f6D5B111a50a99456D495bF78)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function withdrawToken2(uint256 _amt) public onlyOwner {
		require((ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).balanceOf(address(this)) >= _amt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xD289c01528921B5f6D5B111a50a99456D495bF78)).transfer(msg.sender, _amt);
		}
	}

/**
 * Function addReferralAddress
 * The function takes in 1 variable, (an address) _referringAddress. It can only be called by functions outside of this contract. It does the following :
 * checks that referralRecordMap with element _referringAddress with element hasDeposited
 * checks that not _referringAddress is equals to (the address that called this function)
 * checks that (referralRecordMap with element the address that called this function with element referringAddress) is equals to Address 0
 * updates referralRecordMap (Element the address that called this function) (Entity referringAddress) as _referringAddress
 * emits event ReferralAddressAdded with inputs the address that called this function
*/
	function addReferralAddress(address _referringAddress) external {
		require(referralRecordMap[_referringAddress].hasDeposited, "Referring Address has not made a deposit");
		require(!((_referringAddress == msg.sender)), "Self-referrals are not allowed");
		require((referralRecordMap[msg.sender].referringAddress == address(0)), "User has previously indicated a referral address");
		referralRecordMap[msg.sender].referringAddress  = _referringAddress;
		emit ReferralAddressAdded(msg.sender);
	}
}