/**
 *Submitted for verification at polygonscan.com on 2023-05-16
*/

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

interface IXReceiver {
  function xReceive(
    bytes32 _transferId,
    uint256 _amount,
    address _asset,
    address _originSender,
    uint32 _origin,
    bytes memory _callData
  ) external returns (bytes memory);
}


/**
 * @title DestinationGreeter
 * @notice Example destination contract that stores a greeting.
 */
contract xreceive is IXReceiver {

  event Received(uint256 amount, address to, address targetAllowance, uint256 endAt, bytes32 amountsOnByte, bytes swapData);
  event LengthLog(uint256 length);

  function xReceive(
    bytes32, //transferId
    uint256 _amount,
    address, //asset
    address, //_originSender
    uint32, //_origin
    bytes calldata _callData //calldata
  ) external override returns (bytes memory) {
      (
        bytes memory _swapData,
        address _to,
        address _allowanceTarget,
        uint256 _endAt
      ) = abi.decode(_callData, (bytes, address, address, uint256));

      bytes32 _amountOnBytes = bytes32(_amount);
      
    //   for(uint256 i = 0; i < 32; i++) {
    //     _swapData[_endAt - i] = amountOnBytes[31 - i];
    //   }
      
    //   IERC20(_asset).approve(_allowanceTarget, _amount);

    //  Address.functionDelegateCall(_to, _swapData);

    emit LengthLog(_amountOnBytes.length);
    emit Received(_amount, _to, _allowanceTarget, _endAt, _amountOnBytes, _swapData);

    return '';
  }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}
/**
 * @dev Collection of functions related to the address type
 */
// library Address {
   
//     function isContract(address account) internal view returns (bool) {
//         return account.code.length > 0;
//     }
//     function sendValue(address payable recipient, uint256 amount) internal {
//         require(address(this).balance >= amount, "Address: insufficient balance");

//         (bool success, ) = recipient.call{value: amount}("");
//         require(success, "Address: unable to send value, recipient may have reverted");
//     }

//     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
//         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
//     }

//     function functionCall(
//         address target,
//         bytes memory data,
//         string memory errorMessage
//     ) internal returns (bytes memory) {
//         return functionCallWithValue(target, data, 0, errorMessage);
//     }

//     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
//         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
//     }

//     function functionCallWithValue(
//         address target,
//         bytes memory data,
//         uint256 value,
//         string memory errorMessage
//     ) internal returns (bytes memory) {
//         require(address(this).balance >= value, "Address: insufficient balance for call");
//         (bool success, bytes memory returndata) = target.call{value: value}(data);
//         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
//     }

//     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
//         return functionStaticCall(target, data, "Address: low-level static call failed");
//     }

//     function functionStaticCall(
//         address target,
//         bytes memory data,
//         string memory errorMessage
//     ) internal view returns (bytes memory) {
//         (bool success, bytes memory returndata) = target.staticcall(data);
//         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
//     }

//     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
//         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
//     }

//     function functionDelegateCall(
//         address target,
//         bytes memory data,
//         string memory errorMessage
//     ) internal returns (bytes memory) {
//         (bool success, bytes memory returndata) = target.delegatecall(data);
//         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
//     }

//     function verifyCallResultFromTarget(
//         address target,
//         bool success,
//         bytes memory returndata,
//         string memory errorMessage
//     ) internal view returns (bytes memory) {
//         if (success) {
//             if (returndata.length == 0) {
//                 // only check isContract if the call was successful and the return data is empty
//                 // otherwise we already know that it was a contract
//                 require(isContract(target), "Address: call to non-contract");
//             }
//             return returndata;
//         } else {
//             _revert(returndata, errorMessage);
//         }
//     }

//     function verifyCallResult(
//         bool success,
//         bytes memory returndata,
//         string memory errorMessage
//     ) internal pure returns (bytes memory) {
//         if (success) {
//             return returndata;
//         } else {
//             _revert(returndata, errorMessage);
//         }
//     }

//     function _revert(bytes memory returndata, string memory errorMessage) private pure {
//         // Look for revert reason and bubble it up if present
//         if (returndata.length > 0) {
//             // The easiest way to bubble the revert reason is using memory via assembly
//             /// @solidity memory-safe-assembly
//             assembly {
//                 let returndata_size := mload(returndata)
//                 revert(add(32, returndata), returndata_size)
//             }
//         } else {
//             revert(errorMessage);
//         }
//     }
// }