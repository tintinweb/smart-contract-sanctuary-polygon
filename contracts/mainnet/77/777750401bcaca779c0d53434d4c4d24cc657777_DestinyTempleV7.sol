/**
 *Submitted for verification at polygonscan.com on 2023-05-04
*/

/*=======================================================================================================================
#                                                           ..                                                          #
#                                                           ::                                                          #
#                                                           !!                                                          #
#                                                          .77.                                                         #
#                                                          ~77~                                                         #
#                                                         .7777.                                                        #
#                                                         !7777!                                                        #
#                                                        ^777777^                                                       #
#                                                       ^77777777^                                                      #
#                                                      ^777!~~!777^                                                     #
#                                                     ^7777!::!7777^                                                    #
#                                                   .~77777!  !77777~.                                                  #
#                                                  :!77777!:  :!77777!:                                                 #
#                                                 ~777777!^    ^!777777~                                                #
#                                               :!7777777^      ^7777777!:                                              #
#                                             :!77777777:        :77777777!:                                            #
#                                           :!77777777!.          .!77777777!:                                          #
#                                        .^!77777777!^              ^!77777777!^.                                       #
#                                      :~7777777777^.       ..       .^7777777777~:                                     #
#                                   .^!777777777!^.         ^^         .^!777777777!^.                                  #
#                               .:~!777777777!~:           :77:           :~!777777777!~:.                              #
#                           .:^!7777777777!~:             ^7777^             :~!7777777777!^:.                          #
#                     ..:^~!77777777!!~^:.             .^!777777!^.             .:^~!!77777777!~^:..                    #
#           ...::^^~!!77777777~~^^:..              .:^!777777777777!^:.              ..:^^~~77777777!!~^^::...          #
#           ...::^^~!!77777777~~^^:..              .:^!777777777777!^:.              ..:^^~~77777777!!~^^::...          #
#                     ..:^~!77777777!!~^:.             .^!777777!^.             .:^~!!77777777!~^:..                    #
#                           .:^!7777777777!~:             ^7777^             :~!7777777777!^:.                          #
#                               .:~!777777777!~:           :77:           :~!777777777!~:.                              #
#                                   .^!777777777!^.         ^^         .^!777777777!^.                                  #
#                                      :~7777777777^.       ..       .^7777777777~:                                     #
#                                        .^!77777777!^              ^!77777777!^.                                       #
#                                           :!77777777!.          .!77777777!:                                          #
#                                             :!77777777:        :77777777!:                                            #
#                                               :!7777777^      ^7777777!:                                              #
#                                                 ~777777!^    ^!777777~                                                #
#                                                  :!77777!:  :!77777!:                                                 #
#                                                   .~77777!  !77777~.                                                  #
#                                                     ^7777!::!7777^                                                    #
#                                                      ^777!~~!777^                                                     #
#                                                       ^77777777^                                                      #
#                                                        ^777777^                                                       #
#                                                         !7777!                                                        #
#                                                         .7777.                                                        #
#                                                          ~77~                                                         #
#                                                          .77.                                                         #
#                                                           !!                                                          #
#                                                           ::                                                          #
#                                                           ..                                                          #
#                                                                                                                       #
/*=======================================================================================================================
#                                                                                                                       #
#     ██████╗ ███████╗███████╗████████╗██╗███╗   ██╗██╗   ██╗████████╗███████╗███╗   ███╗██████╗ ██╗     ███████╗       #   
#     ██╔══██╗██╔════╝██╔════╝╚══██╔══╝██║████╗  ██║╚██╗ ██╔╝╚══██╔══╝██╔════╝████╗ ████║██╔══██╗██║     ██╔════╝       #
#     ██║  ██║█████╗  ███████╗   ██║   ██║██╔██╗ ██║ ╚████╔╝    ██║   █████╗  ██╔████╔██║██████╔╝██║     █████╗         #
#     ██║  ██║██╔══╝  ╚════██║   ██║   ██║██║╚██╗██║  ╚██╔╝     ██║   ██╔══╝  ██║╚██╔╝██║██╔═══╝ ██║     ██╔══╝         #
#     ██████╔╝███████╗███████║   ██║   ██║██║ ╚████║   ██║      ██║   ███████╗██║ ╚═╝ ██║██║     ███████╗███████╗       #
#     ╚═════╝ ╚══════╝╚══════╝   ╚═╝   ╚═╝╚═╝  ╚═══╝   ╚═╝      ╚═╝   ╚══════╝╚═╝     ╚═╝╚═╝     ╚══════╝╚══════╝       #
#                                                                                                                       #
=========================================================================================================================
#            __                                 __                               __                                     #
#           /  \ |  o     _  ._ _  o     _.    /  \  _  _  | _|_  _ |  _.       /  \    o _  o                          #
#          | (|/ |< | \/ (_) | | | | \/ (_|   | (|/ _> (_) |  |_ (_ | (_| \/   | (|/ >< | /_ |                          #
#           \__       /              /         \__                        /     \__                                     #
#            __                                  __                                    __                               #
#           /  \  _             _. o ._   _     /  \  _|                    _. ._     /  \  _ o  _  _.  _|  _.          #
#          | (|/ _> |_| \/ |_| (_| | | | (_|   | (|/ (_| |_| \/ |_| >< |_| (_| | |   | (|/ (_ | (_ (_| (_| (_|          #
#           \__         /        |        _|    \__          /                        \__                               #
#            __                             __                    __              __                                    #
#           /  \ o o  _. ._          _     /  \     ._ _   _     /  \     | o    /  \ |_   _. ._    |   _.              #
#          | (|/ | | (_| | | \/ |_| (/_   | (|/ |_| | | | (_)   | (|/ |_| | |   | (|/ | | (_| | |_| |< (_|              #
#           \__ _|           /             \__                   \__             \__                                    #
#                                                                                                                       #
#=======================================================================================================================*/
/**
 *  @custom:storiesBeyondStories storiesBeyondStories-haruka
 *
 * 天语遥 
 *
 * 天语遥在现实里不叫天语遥，她的女名也不叫这个，但是她给自己取的女名我总觉得很奇怪，也有些诡异，并不算好听，所以在这一篇关于她的内容里，就称呼她为小遥好了。 
 * 小遥的在现实里的故事自然是没有小说里那样戏剧性的，她是想当女孩子的，当然，那是在去势之前。 
 * 在去势之后，她就后悔了。 
 * 我认识她的时候，是在她去势之后了，认识她的人认为她是一个性格古怪的人，我也是这么认为的。 
 * 而且她和我的见面，还是她第一次会面网友，这让我有些荣幸，但是并不是什么特别值得开心的事情，因为她身上散发出一些危险阴暗的气息。 
 * 对于她我的了解不多，只是道听途说，得知她好像对去势十分后悔。 
 * 于是见面的时候，我就壮着胆子问了。 
 * 小遥的回答有些逻辑不通，经过我整理之后的意思就是：   讨厌这个残缺的身体，无论是当完整的男人还是女人都好。 
 * 言下之意就是，她讨厌这个中间的过度阶段，她后悔的事情是应该直接攒够钱去做变性手术，而不是去做去势手术。 
 * 做去势手术的原因是她当时无法忍受自己男性的身体了，还有就是做变性手术的钱远远不够，而综合来考虑，从长远来打算的话，做去势手术更划算，因为可以省下一大笔抗雄药物的钱。 
 * 我和小遥在网络上不算很熟，但她却说，我是她比较要好的朋友，所以才来见我的。 
 * 哦，对了，见面的地点不是在我的城市，当时我是在另一座城市里，而小遥也就是住在那一座城市。 
 * 小遥长的是什么样子的呢？   嗯，身高大概一米六左右，皮肤比较白，是那种苍白的白，没有什么血色的。   头发有点乱乱的，黑眼圈很重，显然失眠的症状比较严重，比我所见过的所有药娘都要严重得多。 
 * 感觉仿佛是那种终日不见阳光的人。 
 * 她的外貌，怎么形容呢，嗯……像个小正太。 
 * 或者说是假小子。 
 * 外表的年龄大概是十五岁左右，但实际上她已经十八了。 
 * 从某些方面而言，小遥和小晴是很有相似点的。  
 * 事实上正太和萝莉的差距其实并不是很大，只要进行一些修饰，穿上漂亮点的衣服，换个发型，她也可以变成一个可爱的萝莉，顶多就是达不到小晴那种三百六十度无死角的境界而已。 
 * 她们俩之间最大的差别就在于家庭。 
 * 小遥是真正的从家里逃出来的孩子，一个人在一个陌生的城市里生活。 
 * 其实书中很多关于小晴的故事，事实上素材的来源是小遥。 
 * 只是小遥的故事比这些惨得多了。 
 * 比如她说，她刚来这个城市的时候，丢了钱包，在找工作时拿不出身份证，还被人给轰出来，甚至被人打过。 
 * 她就靠口袋里一百来块钱，生活了一个星期，每天晚上就睡在挡风的地方，但也还是很冷的。 
 * 那个时候和书里一样，都是初春，她发烧的很严重，最后还艰难地坚持了下来。 
 * 在那座城市里她找到的第一份工作是包吃包住，但是没有任何工资的。 
 * 后来也有各种屈辱、刁难甚至是折磨的事情发生，反正要悲惨得多。 
 * 很多事情哪怕是我这样一个旁听者听来，都会觉得心凉。 
 * 社会的残酷好像全都聚集在了她的身上一样。 
 * 以前的她其实不是这样的，只是现在她似乎没有太多的精力顾及到其他的事情了。 
 * 本来就有那么多不好的事情压在她的身上，在去势之后就好像翻倍了一样，那些糟糕的事情变得更多了。 
 * 她就开始变得愈发的阴暗。 
 * 如果说小晴自己就是一轮太阳；夕子是努力站到阳光下的人；而张思凡是在阳光和黑暗之间摇摆不定的人；那么小遥就属于那种一头钻进黑暗里不肯出来的人。 
 * 她的情绪非常不稳定，就像是一个火药桶一样，随时都有可能点燃。 
 * 和她聊天时我都是小心翼翼的，生怕她的情绪就突然爆炸了。 
 * 一般人看人的时候，是直视，而她看人的时候，是微微低下头，然后把两颗眼珠子翻上来，眉头都皱在一起，露出一大片的眼白，再加上她那苍白的脸，浓浓的黑眼圈，让她看起来格外的恐怖。还有，她在坐下来的时候，总是会死死地盯着自己的手腕看，我看过她的手腕，那上面有不少的伤疤。 
 * 她说，她自残过很多次。 
 * 说这话的时候，她的表情很轻松，甚至比之前更愉快一些。 
 * 按照她的说法，每当心情不好的时候，只有用那种方法才可以让她平息下来。 
 * 对于她而言，自残，就是排解苦闷，最好的良方。 
 * 可是在一般人听来，那可真是一件有点神经质的事情了。 
 * 不少药娘都会自残，但那只是在极端苦闷的时候，而小遥却把这种事情当作寻求快乐的方式，可以说出发点几乎是完全不同的。   看得出来，小遥的精神绝对有着很大的问题的。 
 * 印象最深刻的，就是服务生问她需要些什么的时候，将称谓在帅哥和美女之间变换了一下，就惹得她暴跳如雷。 
 * “你看不起我吗！”她几乎是在咆哮着怒吼。 
 * 我感觉我仿佛和她不是一个世界的人，这种场面在我想来，大概也就是电影或者动漫里才会发生吧。 
 * 但它还真就发生在了我的面前。 
 * 在服务员道歉了之后，她的怒火才缓缓平息。 
 * 那一次的餐馆是我吃的最尴尬的一次，感觉吃饭的时候，别人都总是把奇怪的目光放在我和她的身上。 
 * 而当有人看着小遥的时间太长了的时候，她就会猛地扭过头，朝那个人咧牙呲嘴。 
 * 明明是一个挺清秀的正太，但有时候的表现却像是一头野兽一样嗜血又凶猛。 
 * 或许这是她保护自己的一种方式吧。 
 * 用凶狠的外表将脆弱的内心掩藏起来。 
 * 小遥的自虐倾向非常严重，她总是不断地掐着自己手臂或者大腿上的嫩肉，掐出一个又一个的红印子来，看着都很疼，她却觉得很舒服。 
 * 又或者是用牙齿咬住自己的手，在上面留下很深的牙印……   我没有问她为什么总要这么做，因为感觉这是她下意识的动作，也就说，已经成了一个习惯了。 
 * 而且问出来，她也不好解释，反而可能会变得暴躁。 
 * 对于她的情绪变化，我实在是无法掌握住。 
 * 按照我的推测，小遥在和人交流的时候，可能必须得这样子做，用疼痛感来提醒自己，才能保持冷静吧。 
 * 不然她的情绪很快就会达到临界点，然后爆发。 
 * 甚至是街上一个碍事的易拉罐，都会让她咬着牙齿，像是有深仇大恨一样的狠狠踹上一脚。 
 * 我想建议她去看一看心理医生，可想到和她并没有那么熟，而且怕她对我发火，所以还是憋在了心里，或许是因为我也算是比较怕事的那一种人吧。 
 * 和小遥的交流并不多，大多数时候我们都是在沉默，去的地方也就是餐厅和商场，之后就分别了。 
 * 虽然没有太多的交流，但是她给我留下的印象还是蛮深的，就是那种近似于精神病患者的感觉。 
 * 我想，她大概已经是达到轻度甚至中度精神疾病的级别了吧。 
 * 对了，她的自残现象真的很严重。我们见面的那一段时间，她对自己又是掐又是咬的，到离开的时候，她甚至咬破了自己的手指，我清晰地看到她的手指上有鲜血在滴落，但她看起来却显得很轻松。 
 * 想起她身上的那一些我能看到的伤口，就让我觉得不寒而栗。 
 * 虽然很同情她的遭遇，可我还是不太想接近她。 
 * 因为她给人的感觉实在是太危险了，或许有一天她彻底爆发了，真的有可能拿着一把刀去砍死几个人，然后再把自己给砍死吧。 
 * 关于夕子的黑化内容，其实就是出自我对现实里小遥未来事情的一些脑补……   小遥的家世我没有多问，因为她一提到自己的父母就咬牙切齿，好像很不想提到她们似的。 
 * 我只知道小遥的家庭环境很差，是农村家庭，而且父母重男轻女，她的家里有姐姐也有哥哥和弟弟，人口非常庞大，据说算上小遥一共有五个人的样子，足足五个孩子，所以对小遥离家出走似乎都不是很在意。 
 * 他们知道小遥的事情，甚至……按照小遥的说法，是他们把小遥给赶走的。 
 * 直接丢出她的行李，让她滚出这个家。 
 * 对于城市里长大的我，这根本是无法想象的事情。 
 * 但如果是在偏远的乡村里，发生这种事情并不是没有可能呢……   大概正是基于这样的同情，在小说里的时候我才把小遥的父母设置成了善解人意的父母，并且家庭也不再贫穷，而是小康家庭。   而且也把原来小遥主动去势变成了被动去势……   虽然故事依然不算美好，但其实已经算是不错了。 
 * 很多看客觉得书中的章节太过虐心，但实际上对于很多在现实里摸爬滚打的药娘们而言，书中的世界也算是很美好了。 
 * 现实只会比小说更残酷，我还是因为考虑到了大多数读者的感受，才进行了一些美化的。 
 * 至于小遥最后的精神病，倒是和现实里的她差不多呢，我觉得她的精神状况再这样继续下去，精神分裂绝对是迟早的事情。 
 * 那么，关于现实里小遥的故事，大概就是这些了。
 **/
// File: @openzeppelin/contracts/utils/Context.sol
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/utils/math/Math.sol
// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)
pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    enum Rounding {
        Down, // Toward negative infinity
        Up, // Toward infinity
        Zero // Toward zero
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
     * with further edits by Uniswap Labs also under MIT license.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod0 := mul(x, y)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
            // See https://cs.stackexchange.com/q/138556/92363.

            // Does not overflow because the denominator cannot be zero at this stage in the function.
            uint256 twos = denominator & (~denominator + 1);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
            // in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(
        uint256 x,
        uint256 y,
        uint256 denominator,
        Rounding rounding
    ) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10, rounded down, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10**64) {
                value /= 10**64;
                result += 64;
            }
            if (value >= 10**32) {
                value /= 10**32;
                result += 32;
            }
            if (value >= 10**16) {
                value /= 10**16;
                result += 16;
            }
            if (value >= 10**8) {
                value /= 10**8;
                result += 8;
            }
            if (value >= 10**4) {
                value /= 10**4;
                result += 4;
            }
            if (value >= 10**2) {
                value /= 10**2;
                result += 2;
            }
            if (value >= 10**1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256, rounded down, of a positive value.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);
        }
    }
}

// File: @openzeppelin/contracts/utils/Strings.sol
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)
pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _SYMBOLS = "0123456789abcdef";
    uint8 private constant _ADDRESS_LENGTH = 20;

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    }
}


// File: @openzeppelin/contracts/security/ReentrancyGuard.sol
// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)
pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}


// File: @openzeppelin/contracts/utils/StorageSlot.sol
// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)
pragma solidity ^0.8.0;

/**
 * @dev Library for reading and writing primitive types to specific storage slots.
 *
 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
 * This library helps with reading and writing to such slots without the need for inline assembly.
 *
 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
 *
 * Example usage to set ERC1967 implementation slot:
 * ```
 * contract ERC1967 {
 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
 *
 *     function _getImplementation() internal view returns (address) {
 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
 *     }
 *
 *     function _setImplementation(address newImplementation) internal {
 *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
 *     }
 * }
 * ```
 *
 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
 */
library StorageSlot {
    struct AddressSlot {
        address value;
    }

    struct BooleanSlot {
        bool value;
    }

    struct Bytes32Slot {
        bytes32 value;
    }

    struct Uint256Slot {
        uint256 value;
    }

    /**
     * @dev Returns an `AddressSlot` with member `value` located at `slot`.
     */
    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
        /// @solidity memory-safe-assembly
        assembly {
            r.slot := slot
        }
    }

    /**
     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
     */
    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
        /// @solidity memory-safe-assembly
        assembly {
            r.slot := slot
        }
    }

    /**
     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
     */
    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
        /// @solidity memory-safe-assembly
        assembly {
            r.slot := slot
        }
    }

    /**
     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
     */
    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
        /// @solidity memory-safe-assembly
        assembly {
            r.slot := slot
        }
    }
}

// File: @openzeppelin/contracts/utils/Address.sol
// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

// File: @openzeppelin/contracts/interfaces/draft-IERC1822.sol
// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)
pragma solidity ^0.8.0;

/**
 * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified
 * proxy whose upgrades are fully controlled by the current implementation.
 */
interface IERC1822Proxiable {
    /**
     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation
     * address.
     *
     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
     * function revert if invoked through a proxy.
     */
    function proxiableUUID() external view returns (bytes32);
}

// File: @openzeppelin/contracts/interfaces/IERC1967.sol
// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)
pragma solidity ^0.8.0;

/**
 * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.
 *
 * _Available since v4.9._
 */
interface IERC1967 {
    /**
     * @dev Emitted when the implementation is upgraded.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Emitted when the admin account has changed.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Emitted when the beacon is changed.
     */
    event BeaconUpgraded(address indexed beacon);
}

// File: @openzeppelin/contracts/proxy/beacon/IBeacon.sol
// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)
pragma solidity ^0.8.0;

/**
 * @dev This is the interface that {BeaconProxy} expects of its beacon.
 */
interface IBeacon {
    /**
     * @dev Must return an address that can be used as a delegate call target.
     *
     * {BeaconProxy} will check that this address is a contract.
     */
    function implementation() external view returns (address);
}

// File: @openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol
// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)
pragma solidity ^0.8.2;

/**
 * @dev This abstract contract provides getters and event emitting update functions for
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
 *
 * _Available since v4.1._
 *
 * @custom:oz-upgrades-unsafe-allow delegatecall
 */
abstract contract ERC1967Upgrade is IERC1967 {
    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Returns the current implementation address.
     */
    function _getImplementation() internal view returns (address) {
        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 implementation slot.
     */
    function _setImplementation(address newImplementation) private {
        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    }

    /**
     * @dev Perform implementation upgrade
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Perform implementation upgrade with additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCall(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        _upgradeTo(newImplementation);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(newImplementation, data);
        }
    }

    /**
     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCallUUPS(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        // Upgrades from old implementations will perform a rollback test. This test requires the new
        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing
        // this special case will break upgrade paths from old UUPS implementation to new ones.
        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {
            _setImplementation(newImplementation);
        } else {
            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {
                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");
            } catch {
                revert("ERC1967Upgrade: new implementation is not UUPS");
            }
            _upgradeToAndCall(newImplementation, data, forceCall);
        }
    }

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Returns the current admin.
     */
    function _getAdmin() internal view returns (address) {
        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 admin slot.
     */
    function _setAdmin(address newAdmin) private {
        require(newAdmin != address(0), "ERC1967: new admin is the zero address");
        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
    }

    /**
     * @dev Changes the admin of the proxy.
     *
     * Emits an {AdminChanged} event.
     */
    function _changeAdmin(address newAdmin) internal {
        emit AdminChanged(_getAdmin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
     */
    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

    /**
     * @dev Returns the current beacon.
     */
    function _getBeacon() internal view returns (address) {
        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;
    }

    /**
     * @dev Stores a new beacon in the EIP1967 beacon slot.
     */
    function _setBeacon(address newBeacon) private {
        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");
        require(
            Address.isContract(IBeacon(newBeacon).implementation()),
            "ERC1967: beacon implementation is not a contract"
        );
        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;
    }

    /**
     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
     *
     * Emits a {BeaconUpgraded} event.
     */
    function _upgradeBeaconToAndCall(
        address newBeacon,
        bytes memory data,
        bool forceCall
    ) internal {
        _setBeacon(newBeacon);
        emit BeaconUpgraded(newBeacon);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
        }
    }
}

// File: @openzeppelin/contracts/proxy/Proxy.sol
// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)
pragma solidity ^0.8.0;

/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */
abstract contract Proxy {
    /**
     * @dev Delegates the current call to `implementation`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _delegate(address implementation) internal virtual {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    /**
     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
     * and {_fallback} should delegate.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates the current call to the address returned by `_implementation()`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _fallback() internal virtual {
        _beforeFallback();
        _delegate(_implementation());
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
     * function in the contract matches the call data.
     */
    fallback() external payable virtual {
        _fallback();
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
     * is empty.
     */
    receive() external payable virtual {
        _fallback();
    }

    /**
     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
     * call, or as part of the Solidity `fallback` or `receive` functions.
     *
     * If overridden should call `super._beforeFallback()`.
     */
    function _beforeFallback() internal virtual {}
}

// File: @openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol
// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)
pragma solidity ^0.8.0;

/**
 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 * implementation address that can be changed. This address is stored in storage in the location specified by
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the
 * implementation behind the proxy.
 */
contract ERC1967Proxy is Proxy, ERC1967Upgrade {
    /**
     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
     *
     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded
     * function call, and allows initializing the storage of the proxy like a Solidity constructor.
     */
    constructor(address _logic, bytes memory _data) payable {
        _upgradeToAndCall(_logic, _data, false);
    }

    /**
     * @dev Returns the current implementation address.
     */
    function _implementation() internal view virtual override returns (address impl) {
        return ERC1967Upgrade._getImplementation();
    }
}

// File: @openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol
// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/TransparentUpgradeableProxy.sol)
pragma solidity ^0.8.0;

/**
 * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}
 * does not implement this interface directly, and some of its functions are implemented by an internal dispatch
 * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not
 * include them in the ABI so this interface must be used to interact with it.
 */
interface ITransparentUpgradeableProxy is IERC1967 {
    function admin() external view returns (address);

    function implementation() external view returns (address);

    function changeAdmin(address) external;

    function upgradeTo(address) external;

    function upgradeToAndCall(address, bytes memory) external payable;
}

/**
 * @dev This contract implements a proxy that is upgradeable by an admin.
 *
 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
 * clashing], which can potentially be used in an attack, this contract uses the
 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
 * things that go hand in hand:
 *
 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
 * that call matches one of the admin functions exposed by the proxy itself.
 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the
 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says
 * "admin cannot fallback to proxy target".
 *
 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing
 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due
 * to sudden errors when trying to call a function from the proxy implementation.
 *
 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,
 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.
 *
 * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not
 * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch
 * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to
 * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the
 * implementation.
 *
 * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler
 * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function
 * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could
 * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.
 */
contract TransparentUpgradeableProxy is ERC1967Proxy {
    /**
     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and
     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.
     */
    constructor(
        address _logic,
        address admin_,
        bytes memory _data
    ) payable ERC1967Proxy(_logic, _data) {
        _changeAdmin(admin_);
    }

    /**
     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.
     *
     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the
     * implementation provides a function with the same selector.
     */
    modifier ifAdmin() {
        if (msg.sender == _getAdmin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior
     */
    function _fallback() internal virtual override {
        if (msg.sender == _getAdmin()) {
            bytes memory ret;
            bytes4 selector = msg.sig;
            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {
                ret = _dispatchUpgradeTo();
            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {
                ret = _dispatchUpgradeToAndCall();
            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {
                ret = _dispatchChangeAdmin();
            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {
                ret = _dispatchAdmin();
            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {
                ret = _dispatchImplementation();
            } else {
                revert("TransparentUpgradeableProxy: admin cannot fallback to proxy target");
            }
            assembly {
                return(add(ret, 0x20), mload(ret))
            }
        } else {
            super._fallback();
        }
    }

    /**
     * @dev Returns the current admin.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
     */
    function _dispatchAdmin() private returns (bytes memory) {
        _requireZeroValue();

        address admin = _getAdmin();
        return abi.encode(admin);
    }

    /**
     * @dev Returns the current implementation.
     *
     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the
     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
     */
    function _dispatchImplementation() private returns (bytes memory) {
        _requireZeroValue();

        address implementation = _implementation();
        return abi.encode(implementation);
    }

    /**
     * @dev Changes the admin of the proxy.
     *
     * Emits an {AdminChanged} event.
     */
    function _dispatchChangeAdmin() private returns (bytes memory) {
        _requireZeroValue();

        address newAdmin = abi.decode(msg.data[4:], (address));
        _changeAdmin(newAdmin);

        return "";
    }

    /**
     * @dev Upgrade the implementation of the proxy.
     */
    function _dispatchUpgradeTo() private returns (bytes memory) {
        _requireZeroValue();

        address newImplementation = abi.decode(msg.data[4:], (address));
        _upgradeToAndCall(newImplementation, bytes(""), false);

        return "";
    }

    /**
     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified
     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the
     * proxied contract.
     */
    function _dispatchUpgradeToAndCall() private returns (bytes memory) {
        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));
        _upgradeToAndCall(newImplementation, data, true);

        return "";
    }

    /**
     * @dev Returns the current admin.
     */
    function _admin() internal view virtual returns (address) {
        return _getAdmin();
    }

    /**
     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to
     * emulate some proxy functions being non-payable while still allowing value to pass through.
     */
    function _requireZeroValue() private {
        require(msg.value == 0);
    }
}

// File: @openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol
// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)
pragma solidity ^0.8.0;

/**
 * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an
 * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.
 */
contract IProxyAdmin {
    modifier __onlyWallet__(){
        require(msg.sender == address(this),"IProxyAdmin: not wallet.");
        _;
    }
    /**
     * @dev Returns the current implementation of `proxy`.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256("implementation()")) == 0x5c60da1b
        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b");
        require(success);
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Returns the current admin of `proxy`.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {
        // We need to manually run the static call since the getter cannot be flagged as view
        // bytes4(keccak256("admin()")) == 0xf851a440
        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440");
        require(success);
        return abi.decode(returndata, (address));
    }

    /**
     * @dev Changes the admin of `proxy` to `newAdmin`.
     *
     * Requirements:
     *
     * - This contract must be the current admin of `proxy`.
     */
    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual __onlyWallet__ {
        proxy.changeAdmin(newAdmin);
    }

    /**
     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual __onlyWallet__ {
        proxy.upgradeTo(implementation);
    }

    /**
     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See
     * {TransparentUpgradeableProxy-upgradeToAndCall}.
     *
     * Requirements:
     *
     * - This contract must be the admin of `proxy`.
     */
    function upgradeAndCall(
        ITransparentUpgradeableProxy proxy,
        address implementation,
        bytes memory data
    ) public payable virtual __onlyWallet__ {
        proxy.upgradeToAndCall{value: msg.value}(implementation, data);
    }
}

// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
pragma solidity ^0.8.0;

/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)
pragma solidity ^0.8.0;

/**
 * @dev _Available since v3.1._
 */
interface IERC1155Receiver is IERC165 {
    /**
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param operator The address which initiated the transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param id The ID of the token being transferred
     * @param value The amount of tokens being transferred
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
     * @dev Handles the receipt of a multiple ERC1155 token types. This function
     * is called at the end of a `safeBatchTransferFrom` after the balances have
     * been updated.
     *
     * NOTE: To accept the transfer(s), this must return
     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
     * (i.e. 0xbc197c81, or its own function selector).
     *
     * @param operator The address which initiated the batch transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param ids An array containing ids of each token being transferred (order and length must match values array)
     * @param values An array containing amounts of each token being transferred (order and length must match ids array)
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
     */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
pragma solidity ^0.8.0;

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)
pragma solidity ^0.8.0;

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
pragma solidity ^0.8.0;

/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

// File: @openzeppelin/contracts/token/ERC721/ERC721.sol
// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)
pragma solidity ^0.8.0;

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
contract IDestinyExecutor is Context, ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    address internal _destinySwap;

    string constant private _NAME = "Destiny Executor";
    string constant private _SYMBOL = "DSE";
    uint256 private _totalSupply;
    string private _baseURI = "ipfs://QmYVqfnR3YpLueC8HLtdiQdu1y8qC72fPD1QmedfQgyc9P/";

    mapping(uint256 => address) private _owners;
    mapping (address => uint256) private _executorTokenId;
    mapping(address => uint256) private _balances;
    
    modifier _onlyWallet_() {
        require(msg.sender == address(this),"ERC721: not wallet.");
        _;
    }
    modifier _onlyMultiSigOwners_() {
        require(balanceOf(msg.sender) == 1 || msg.sender == address(this),"ERC721: not Owner.");
        _;
    }
    modifier _onlyOne(address owner){
        require(balanceOf(owner) == 0, "only one token");
        _;
    }
    modifier _onlyDestinySwap() {
        require(msg.sender == _destinySwap,"not destinySwap");
        _;
    }
    modifier _requireMinted(uint256 tokenId){
        require(_owners[tokenId]!= address(0), "invalid token ID");
        _;
    }

    function initialization(address __destinySwap) public virtual { 
        _destinySwap = __destinySwap;
    }
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC721-balanceOf}.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        return _balances[owner];
    }

    /**
     * @dev See {IERC721-ownerOf}.
     */
    function ownerOf(uint256 tokenId) public view override _requireMinted(tokenId) returns (address) {
        return _owners[tokenId];
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name() public pure override returns (string memory) {
        return _NAME;
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol() public pure override returns (string memory) {
        return _SYMBOL;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function executorTokenId(address owner) public view returns (uint256) {
        return _executorTokenId[owner];
    }
    function destinySwap() public view returns (address) {
        return _destinySwap;
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {}
    
    /**
     * @dev See {IERC721-isApprovedForAll}.
     */
    function isApprovedForAll(address owner, address operator) public view override returns (bool) {}

    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public override {}

    /**
     * @dev See {IERC721-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public override {}
    
    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view override _requireMinted(tokenId) returns (string memory) {
        return string(abi.encodePacked(baseURI(), tokenId.toString(), ".json"));
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overridden in child contracts.
     */
    function baseURI() public view returns (string memory) {
        return _baseURI;
    }
    function setBaseURI(string calldata uri) public _onlyMultiSigOwners_ returns(bool) {
        _baseURI = uri;
        return true;
    }

    /**
     * @dev See {IERC721-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public override _onlyWallet_ _onlyOne(to){
        tokenId = _executorTokenId[from];
        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        _executorTokenId[to] = tokenId;
        delete _executorTokenId[from];
        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public override {
        transferFrom(from, to, tokenId);
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) public override{
        transferFrom(from, to, tokenId);
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function mint(address to) public _onlyDestinySwap _onlyOne(to){
        uint tokenId = totalSupply();
        require(_owners[tokenId] == address(0), "ERC721: token minted");
        _totalSupply +=1;
        _balances[to] += 1;
        _owners[tokenId] = to;
        _executorTokenId[to] = tokenId;
        emit Transfer(address(0), to, tokenId);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     * This is an internal function that does not check if the sender is authorized to operate on the token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function burn(address from) public _onlyDestinySwap _requireMinted(_executorTokenId[from]) {
        uint256 tokenId = _executorTokenId[from];
        _totalSupply -= 1;
        _balances[from] -= 1;
        delete _owners[tokenId];
        delete _executorTokenId[from];
        emit Transfer(from, address(0), tokenId);
    }
}

// File: DestinyTempleV7/core/IDestinyDeployer.sol
pragma solidity ^0.8.10;

/// @notice Integrated, used to deploy contracts using Create2, only the owner can call.
contract IDestinyDeployer{
    event ContractDeployed(address addr, bytes32 salt);
    /// @notice Calculate create2 deploy contract address.
    function getCreate2Address(bytes memory bytecode, bytes32 salt)
        public
        view
        returns (address)
    {
        // NOTE: cast last 20 bytes of hash to address
        return address(uint160(uint(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(bytecode))))));
    }
    
    /**
    * @custom:title Deploy the contract
    * @notice Check the event log Deployed which contains the address of the deployed Contract.
    * The address in the log should equal the address computed from above.
    */
    function contractDeploy(bytes memory bytecode, bytes32 salt)
        public
        returns(address)
    {
        address addr;
        (,bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature("balanceOf(address)", msg.sender));
        if(msg.sender == address(this) || abi.decode(returnData,(bool))){
            /*
            NOTE: How to call create2

            create2(v, p, n, s)
            create new contract with code at memory p to p + n
            and send v wei
            and return the new address
            where new address = first 20 bytes of keccak256(0xff + address(this) + s + keccak256(mem[p…(p+n)))
                s = big-endian 256-bit value
            */
            assembly {
                addr := create2(
                    callvalue(), // wei sent with current call
                    // Actual code starts after skipping the first 32 bytes
                    add(bytecode, 0x20),
                    mload(bytecode), // Load the size of code contained in the first 32 bytes
                    salt // Salt from function arguments
                )
                if iszero(extcodesize(addr)) {
                    revert(0, 0)
                }
            }
            emit ContractDeployed(addr, salt);
            return addr;
        }else{
            revert("not owner");
        }
    }
}

// File: DestinyTempleV7/core/ITweet.sol
pragma solidity ^0.8.10;

/// @notice Integrated, that allows anyone to tweet.
contract ITweet{
    event TweetReleased(uint[] tweetIDs);

    struct Tweet{
        address user;
        uint256 releaseTime;
        string tweet;
    }

    Tweet[] internal _tweets;
    /**
     *  @notice Allow anyone to tweet.
     */
    function ReleaseTweets(string[] memory tweets)
	public 
	returns (uint[] memory)
	{
        uint[] memory tweetIDs = new uint[](tweets.length);
        for (uint i=0;i<tweets.length;i++){
		    _tweets.push(
                Tweet({
                    user: tx.origin,
                    releaseTime: block.timestamp,
                    tweet:tweets[i]
                })
            );
            tweetIDs[i] = _getLastTweetID();
        }
		emit TweetReleased(tweetIDs);
		return tweetIDs;
	}
    /**
     *  @notice Get all tweet IDs posted by a certain address.
     */
    function _getTweetsByIds(uint[] memory _tweetID) public view returns (Tweet[] memory users_releaseTime_tweets){
        Tweet[] memory tweets = new Tweet[](_tweetID.length);
        for (uint i=0; i<_tweetID.length; i++){
            tweets[i] = _tweets[i];
        }
		return tweets;
	}
    function _getTweetIdsByUser(address userAddr) public view returns (uint[] memory tweetIds){
        uint index;
        uint[] memory tempIds = new uint[](_tweets.length);
        for (uint tweetId=0; tweetId<_tweets.length; tweetId++){
            if(_tweets[tweetId].user == userAddr){
                tempIds[index] = tweetId;
                index++;
            }
        }
        uint[] memory _tweetIds = new uint[](index);
        for (uint i=0;i<index;i++){
            _tweetIds[i] = tempIds[i];
        }
		return _tweetIds;
	}
    
    function _getLastTweetID() public view returns (uint) {return _tweets.length - 1;}
}

// File: DestinyTempleV7/core/IMultiSigTransaction.sol
pragma solidity ^0.8.10;

/// @notice Used to maintain multi-signature contract __transactions.
contract IMultiSigTransaction{
	event Reserved(address indexed sender, uint amount, uint balance);
	event IssueTransaction(address indexed msgSender,uint indexed transactionID,Transaction _transaction);
	event ApproveTransaction(address indexed msgSender, uint indexed transactionID);
	event RevokeApproveaction(address indexed msgSender, uint indexed transactionID);
	event ExecuteTransaction(address indexed msgSender, uint indexed transactionID, bool[] success, bytes[] returnData);
		
	struct Transaction {
		address[] to;
		uint[] value;
		bytes[] data;
		uint approveCount;
		uint canExecuteTimeStamp;
		bool executed;
	}
	mapping(uint => mapping(address => bool)) internal isApproved;
	Transaction[] internal __transactions;

    function _getIsApproved(uint transactionID,address owner) public view returns (bool) {
		return isApproved[transactionID][owner];
	}
	/// @notice Get the transaction type contained in calldata, if there is no match, return the function signature.
    function _getTransactionType(bytes4[] memory _selectors) public pure returns (string[] memory) {
		string[] memory transactionTypeList = new string[](_selectors.length);
		for (uint i=0;i<_selectors.length;i++){
			 
			if(_selectors[i] == 0x5e6af287){transactionTypeList[i] = "_IssueTransaction";}
			else if(_selectors[i] == 0xf557bf1d){transactionTypeList[i] = "_ApproveTransaction";}
			else if(_selectors[i] == 0xeb68dacc){transactionTypeList[i] = "_RevokeApprove";}
			else if(_selectors[i] == 0x128d1f90){transactionTypeList[i] = "_ExecuteTransaction";}

			else if(_selectors[i] == 0x6d8685da){transactionTypeList[i] = "addOwner";}
			else if(_selectors[i] == 0x94e894bf){transactionTypeList[i] = "removeOwner";}
			else if(_selectors[i] == 0xd61a75ee){transactionTypeList[i] = "replaceOwner";}
			else if(_selectors[i] == 0xbd48c0b0){transactionTypeList[i] = "modifyMinApproveCount";}
			else if(_selectors[i] == 0xebae0a36){transactionTypeList[i] = "modifyTransactionLock";}
			else if(_selectors[i] == 0x367edd32){transactionTypeList[i] = "enableContract";}
			else if(_selectors[i] == 0xccece381){transactionTypeList[i] = "disableContract";}

			else if (_selectors[i] == 0x10c69dbb){transactionTypeList[i] = "ReleaseTweets";}
			else if(_selectors[i] == 0xcab8c713){transactionTypeList[i] = "contractDeploy";}

			else if(_selectors[i] == 0x7eff275e){transactionTypeList[i] = "changeProxyAdmin";}
			else if(_selectors[i] == 0x99a88ec4){transactionTypeList[i] = "upgrade";}
			else if(_selectors[i] == 0x9623609d){transactionTypeList[i] = "upgradeAndCall";}

            else if(_selectors[i] == 0x095ea7b3){transactionTypeList[i] = "approve";}
            else if(_selectors[i] == 0xa9059cbb){transactionTypeList[i] = "transfer";}
            else if(_selectors[i] == 0x23b872dd){transactionTypeList[i] = "transferFrom";}
			else {transactionTypeList[i] = Strings.toHexString(uint256(uint32(_selectors[i])));}
		}
		return transactionTypeList;
	}
	/// @notice Obtain transaction data and additionally display transaction types.
    function __getTransaction(uint transactionID)
    public
    view
    returns(
        address[] memory to,
		uint[] memory value,
		bytes[] memory data,
        string[] memory transactionType,
		uint approveCount,
		uint canExecuteTimeStamp,
		bool executed
    ){
        Transaction storage transaction = __transactions[transactionID];
        bytes4[] memory selectors = new bytes4[](transaction.data.length);
        for (uint i=0; i<transaction.data.length; i++){
            selectors[i] = bytes4(transaction.data[i]);
        }
        return(
            transaction.to,
            transaction.value,
            transaction.data,
            _getTransactionType(selectors),
            transaction.approveCount,
            transaction.canExecuteTimeStamp,
            transaction.executed
        );
    }
	function _getLastTransactionID() public view returns (uint) {
		return __transactions.length - 1;
	}

    modifier verifyTxlength3(uint parameter1Length,uint parameter2Length,uint parameter3Length){
        require(parameter1Length == parameter2Length && parameter2Length == parameter3Length && parameter3Length == parameter1Length,"invalid tx length.");
        _;
    }
	modifier verifyTxlength2(uint parameter1Length,uint parameter2Length){
        require(parameter1Length == parameter2Length,"invalid tx length.");
        _;
    }
	modifier txExists(uint transactionID) {
		require(transactionID < __transactions.length, "tx not exist");
		_;
	}
	modifier notExecuted(uint transactionID) {
		require(!__transactions[transactionID].executed, "tx executed");
		_;
	}
	modifier notApproved(uint transactionID) {
		require(!isApproved[transactionID][msg.sender], "tx approved");
		_;
	}
	modifier approved(uint transactionID) {
		require(isApproved[transactionID][msg.sender], "tx not approve");
		_;
	}
}

// File: DestinyTempleV7/core/IMultiSigController.sol
pragma solidity ^0.8.10;

/// @notice Used to manage multi-signature contracts.
contract IMultiSigController{
	event OwnerAddition(address[] owner);
	event OwnerRemoval(address[] owner);
	event MinApproveCountModify(uint minApproveCount);
	event TransactionLockModify(uint transactionLockTime);
	event ContractDisabled(uint enableTime);
	event ContractEnabled(bool success, uint enableTime);

    address immutable internal deployer;
    bool initialized;
	address[] internal initialExecutors = [0x00001C1D6ab92F943eD4A31dA8F447Fd96589960,0x11119C3A27d5D7E13cb52053aF58b2DBddcFE051,0x22222eC77C520Bdb7D6A2450C3dB3c5c138C4372,0x33339BE5D3C5C7ae99c1532df8a09F859770B3E3,0x4444023B8E794eCD3a21335fcA22675739bD7914,0x555599F812DC2Cf428d67339221e2B066e7fCAe5,0x66660Bd655e77b2d8b0Ad9F87b4c48D7f284E9b6,0x77777DCaEfeaC067f21162cd2F48E5b5dB0A2B97,0x888853CFdAB45eB0608Acc157C6295E8eFD617a8];
	
	uint internal minApproveCount = 5;
	bool internal contractDisabled;
	uint internal transactionLockTime = 86400;

	constructor() {deployer = tx.origin;}

	/// @notice Get all owners of multisig wallet.
	function _getMultiSigOwners() public view returns (address[] memory){
		//abi.encodeWithSignature("totalSupply()") == 0x18160ddd;
		(bool success,bytes memory totalSupply) = address(this).staticcall(hex"18160ddd");
		require(success);
        uint256 length = abi.decode(totalSupply,(uint256));
		address[] memory multiSigOwners = new address[](length);
		for (uint tokenId=0;tokenId<length;tokenId++){
			(bool callSuccess,bytes memory owner) = address(this).staticcall(abi.encodeWithSignature("ownerOf(uint256)",tokenId));
			require(callSuccess);
			multiSigOwners[tokenId] = abi.decode(owner,(address));
		}
		return multiSigOwners;
	}
	function _getIsMultiSigOwner(address owner) public view returns (bool){
		(bool success,bytes memory isOwner) = address(this).staticcall(abi.encodeWithSignature("balanceOf(address)", owner));
		require(success);
        return (abi.decode(isOwner, (bool)) || owner == address(this));
	}
	function _getMinApproveCount() public view returns (uint){
		return minApproveCount;
	}
	function _getContractDisabled() public view returns (bool){
		return contractDisabled;
	}
	function _getTransactionLockTime() public view returns (uint){
		return transactionLockTime;
	}
    modifier onlyDeployer(){
        require(msg.sender == deployer);
        _;
    }
    modifier initialize(){
        require(!initialized,"inited");
        initialized = true;
        _;
    }
    modifier onlyWallet(){
        require(msg.sender == address(this),"not wallet");
        _;
    }
    modifier onlyOwners() {
		require(_getIsMultiSigOwner(msg.sender), "not owner");
		_;
	}
	modifier verifyMinApproveCount(uint _minApproveCount,uint ownerCount) {
		require(
			_minApproveCount <= ownerCount
			&& _minApproveCount > 0
			&& ownerCount > 0,
			"invalid minApproveCount"
		);
		_;
	}
	modifier verifyContractStauts(bytes[] memory data){
        for(uint i=0;i<data.length;i++){
            //abi.encodeWithSignature("enableContract()") == 0x367edd32;
		    if (bytes4(data[i]) != 0x367edd32) {
			    require(!contractDisabled, "disabled");
		    }
        }
		_;
	}
}

// File: DestinyTempleV7/core/IDestinyReserve.sol
pragma solidity ^0.8.10;

/// @notice Main,destiny multisig contract.
contract IDestinyReserve is ReentrancyGuard,IMultiSigController,IMultiSigTransaction,IDestinyExecutor{
	
    modifier verifyApproveCount(uint transactionID) {
		require(
			__transactions[transactionID].approveCount >= minApproveCount,
			"Not enough approvals."
		);
		_;
	}
	
	modifier verifyExecuteTimeStamp(uint transactionID){	
		require(getTimeStamp() >= __transactions[transactionID].canExecuteTimeStamp,"Execution time not yet reached.");
		_;
	}

	function getTimeStamp() public view returns (uint timeStamp){
		return block.timestamp;
	}

	function getCanExecuteTimeStamp() public view returns (uint timeStamp){
		return getTimeStamp() + transactionLockTime;
	}

	function getOwnerLength() public view returns (uint ownerLength){
		//abi.encodeWithSignature("totalSupply()") == 0x18160ddd;
		(bool success,bytes memory returnData) = address(this).staticcall(hex"18160ddd");
		require(success);
        return abi.decode(returnData, (uint));
	}

	/** 
	 * @notice Burn DST tokens from 0x77777777777777777777777777777777777777 to mint DSE tokens for the original owner.
	 *	The DST tokens to be destroyed have been pre-allocated when DestinyTempleToken is initialized.
	 */
	function initialization(address _destinySwap_) public override initialize onlyDeployer{
		IDestinyExecutor.initialization(_destinySwap_);
		address[] memory _DST_burnFrom = new address[](initialExecutors.length);
		for(uint i=0;i<_DST_burnFrom.length;i++){
			_DST_burnFrom[i] = address(7);
		}
		this.addOwner(_DST_burnFrom,initialExecutors);
	}
	
    /**
	 *	@custom:title @Application layer.
	 *
     *	@notice Allow anyone to issue transactions
	 *          If the caller is owner,automatically approve this transaction for caller.
     *
     *  @dev If you need to call other contracts,
     *          please enter the address of the target contract in the (_to) field,
     *          and enter the function signature of the function to be called and the input parameters (if any) in the (_data) field;
	 *
	 *	@dev Multiple calls are allowed in one transaction without rollback.
	 *		 Or just execute one call and roll back if it fails.
     */
    function _IssueTransaction
    (
        address[] memory _to,
		uint[] memory _value,
		bytes[] memory _data
    )
    public
    returns (uint transactionID)
    {
        for(uint i=0; i<_data.length; i++){
            /**
             *EnableContract __transactions cannot be initiated manually.
             */
             //abi.encodeWithSignature("enableContract()") == 0x367edd32;
            require(bytes4(_data[i]) != 0x367edd32,"Ban issue enableContract tx");
        }
        return __IssueTransaction(_to,_value,_data,getCanExecuteTimeStamp());
    }

	function __IssueTransaction
	(
		address[] memory _to,
		uint[] memory _value,
		bytes[] memory _data,
		uint _canExecuteTimeStamp
	)
	internal
    verifyTxlength3(_to.length,_value.length,_data.length)
	verifyContractStauts(_data)
	returns (uint transactionID)
	{
		__transactions.push(
			Transaction({
                to : _to,
                value : _value,
                data : _data,
                approveCount : 0,
                canExecuteTimeStamp : _canExecuteTimeStamp,
                executed : false
            })
		);
		emit IssueTransaction(msg.sender, _getLastTransactionID(), __transactions[_getLastTransactionID()]);
		if(_getIsMultiSigOwner(msg.sender)){
			_ApproveTransaction(_getLastTransactionID());
		}
		return _getLastTransactionID();
	}

	/**
	 *	@custom:title @Approve layer.
     *	@notice Approve the transaction corresponding to [transactionID],only owners callable.
	 */
	function _ApproveTransaction(uint transactionID)
	public
	onlyOwners
	verifyContractStauts(__transactions[transactionID].data)
	txExists(transactionID)
	notExecuted(transactionID)
	notApproved(transactionID)
	returns (bool transactionapproved)
	{
		Transaction storage transaction = __transactions[transactionID];
		isApproved[transactionID][tx.origin] = true;
		transaction.approveCount += 1;
		emit ApproveTransaction(tx.origin, transactionID);
		if (transaction.approveCount >= minApproveCount && getTimeStamp() >= transaction.canExecuteTimeStamp && _getIsMultiSigOwner(msg.sender)) {
			_ExecuteTransaction(transactionID);
		}
		return true;
	}

    /**
	 * @notice Unapprove the transaction corresponding to [transactionID] for the caller of the message,only owners callable.
	 */
	function _RevokeApprove(uint transactionID)
	public
	onlyOwners
	verifyContractStauts(__transactions[transactionID].data)
	txExists(transactionID)
	notExecuted(transactionID)
	approved(transactionID)
	returns (bool transctionRevokeapproved)
	{
		Transaction storage transaction = __transactions[transactionID];
		isApproved[transactionID][tx.origin] = false;
		transaction.approveCount -= 1;
		emit RevokeApproveaction(tx.origin, transactionID);
		return true;
	}

    /**
	 *	@custom:title @Executive layer
     *
     *	@notice Execute the transaction corresponding to [transactionID],only owners callable.
	 *
	 *	@dev Multiple calls are allowed in one transaction without rollback.
	 *		 Or just execute one call and roll back if it fails.
	 */
	function _ExecuteTransaction(uint transactionID)
	public
	onlyOwners
	verifyContractStauts(__transactions[transactionID].data)
	txExists(transactionID)
	notExecuted(transactionID)
	verifyApproveCount(transactionID)
	verifyExecuteTimeStamp(transactionID)
	nonReentrant
	returns (bool[]memory,bytes[] memory)
	{
		Transaction storage transaction = __transactions[transactionID];
		transaction.executed = true;
		bool[] memory successList = new bool[](transaction.data.length);
		bytes[] memory returnDataList = new bytes[](transaction.data.length);

		for (uint i=0;i<transaction.data.length;i++){
			(successList[i],returnDataList[i]) = transaction.to[i].call{value : transaction.value[i]}(
				transaction.data[i]
			);
		}
		if(transaction.data.length == 1){
			require(successList[0],"Tx execute fail.");
		}
        emit ExecuteTransaction(msg.sender,transactionID,successList,returnDataList);
		return (successList,returnDataList);
	}

	/**
	 *	@notice Allows anyone to mint DSE tokens for an address by burning 7777 DST tokens (add as multi-signature wallet owner)
	 */
    function addOwner(address[] memory DST_burnFrom, address[] memory DSE_mintToNewOwners) public returns (bool success) {
		return this.addOwner_(DST_burnFrom,DSE_mintToNewOwners);
	}

	function addOwner_(address[] memory DST_burnFrom, address[] memory DSE_mintToNewOwners)
	public 
    onlyWallet
	verifyTxlength2(DST_burnFrom.length,DSE_mintToNewOwners.length)
	verifyMinApproveCount(_getMinApproveCount(), getOwnerLength()+ DSE_mintToNewOwners.length)
	returns (bool success)
	{
		for (uint i=0;i<DSE_mintToNewOwners.length;i++){
			(success,) = _destinySwap.call(abi.encodeWithSignature("swapDSE(address,address)", DST_burnFrom[i], DSE_mintToNewOwners[i]));
			require(success,"addOwner fail.");
		}
		this.modifyMinApproveCount(getOwnerLength()/2+1);
		emit OwnerAddition(DSE_mintToNewOwners);
		return true;
	}

	/**
	 *	@notice Burn DSE tokens (remove owner) to mint 7777 DST tokens to one address.
	 *
	 *	@dev In order to prevent the owner from being coerced or modify the minApproveCount attacks,
	 *		 the destruction of DSE tokens requires multi-signature approval.
	 */
	function removeOwner(address[] calldata DSE_burnFromOwners, address[] calldata DST_mintTo)
	public
	onlyWallet
	verifyTxlength2(DSE_burnFromOwners.length,DST_mintTo.length)
	verifyMinApproveCount(_getMinApproveCount(),getOwnerLength() - DSE_burnFromOwners.length)
	returns (bool success)
	{
		for(uint i=0;i<DST_mintTo.length;i++){
			(success,) = _destinySwap.call(abi.encodeWithSignature("redeemDST(address,address)", DSE_burnFromOwners[i], DST_mintTo[i]));
			require(success,"removeOwner fail.");
		}
		this.modifyMinApproveCount(getOwnerLength()/2+1);
		emit OwnerRemoval(DSE_burnFromOwners);
		return true;
	}

	/**
	*	@notice Allow transfer of DSE tokens (transfer owner).
	*
	*	@dev In order to prevent the owner from being coerced or modify the minApproveCount attacks,
	*		 the transfer of DSE tokens requires multi-signature approval.
	*
	*	@param _from Address of owner to be replaced.
    *	@param _to Address of new owner.
	*/
    function replaceOwner(address[] memory _from, address[] memory _to, uint[] memory _tokenId)
        public
        onlyWallet
		verifyTxlength3(_from.length,_to.length,_tokenId.length)
		returns (bool success)
    {
		for (uint i=0;i<_from.length;i++){
			(success,) = address(this).call(abi.encodeWithSignature("transferFrom(address,address,uint256)", _from[i], _to[i], _tokenId[i]));
			require(success);
		}
		emit OwnerRemoval(_from);
		emit OwnerAddition(_to);
		return success;
    }

	/**
	 *	@notice Allow modification of the minimum number of approvals for a transaction,
	 *			requiring multi-signature approval.
	 */
	function modifyMinApproveCount(uint _minApproveCount)
	public
	onlyWallet
	returns (bool)
	{
        if(minApproveCount != _minApproveCount){
		    minApproveCount = _minApproveCount;
            emit MinApproveCountModify(_minApproveCount);
        }
		return true;
	}

	/**
	 * @notice Allows modification of the transaction lock time,
	 *		   The allowed time frame is one day to 7 days.
	 *		   (but this is not valid for transactions that have already been issued),
	 *		   requiring multi-signature approval.
	 */
	function modifyTransactionLock(uint lockTime)
	public
	onlyWallet
	returns (bool)
	{
		require(lockTime >= 86400 && lockTime <= 604800,"invalid TxLockTime");
		transactionLockTime = lockTime;
		emit TransactionLockModify(transactionLockTime);
		return true;
	}

	/**
	 * @notice Allows the contract to be enabled,
	 *		   this transaction can only be automatically initiated by the disabled contract function,
	 *		   requires multi-signature approval.
	 */
	function enableContract()
	public
	onlyWallet
	returns (bool)
	{
		contractDisabled = false;
		emit ContractEnabled(true, getTimeStamp());
		return true;
	}

	/**
	 *	@notice Allow disabling the multi-signature transaction function,
	 *			the time allowed is from 7 days to 7 years.
	 *			requires multi-signature approval.
	 *
	 *	@dev Specific functions include __IssueTransaction, _ApproveTransaction, _RevokeApprove, _ExecuteTransaction.
	 *		 When the contract is disabled, a transaction to enable the contract that can be executed after the expiration of the disabled time will be automatically initiated.
	 */
	function disableContract(uint disableTime)
	public
	onlyWallet
	returns (bool)
	{
        require(disableTime >= 604800 && disableTime <= 220752000,"invalid disableTime");
		address[] memory to = new address[](1);
		uint[] memory value = new uint[](1);
		bytes[] memory data = new bytes[](1);

		to[0] = address(this);
		value[0] = 0;
		bytes4 selector = 0x367edd32;
		data[0] = bytes.concat(selector);

		__IssueTransaction(to,value,data,getCanExecuteTimeStamp()+disableTime);
		contractDisabled = true;
        emit ContractDisabled(getTimeStamp() +disableTime);
        return true;
	}
}

// File: DestinyTempleV7/core/DestinyTemple.sol
pragma solidity ^0.8.10;

/**                                           
 * @notice The final contract, which integrates all of the above.
 *         The contract can accept ETH, ERC20, ERC721, ERC1155 token deposits.
 */
contract DestinyTempleV7 is IProxyAdmin,IERC721Receiver,IERC1155Receiver,ITweet,IDestinyDeployer,IDestinyReserve{

    fallback()external payable {
		emit Reserved(msg.sender, msg.value, address(this).balance);
	}
	receive() external payable {
		emit Reserved(msg.sender, msg.value, address(this).balance);
	}

    /// See ERC 165.
	function supportsInterface(bytes4 interfaceId) public view override(IERC165,IDestinyExecutor) returns (bool){
		return interfaceId == type(IERC1155Receiver).interfaceId || interfaceId == type(IERC165).interfaceId ||interfaceId == type(IERC721Receiver).interfaceId || super.supportsInterface(interfaceId);
	}

    /// @notice Used to receive ERC721(NFT) tokens.
	function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external pure override  returns (bytes4){
		return IERC721Receiver.onERC721Received.selector;
	}

    /// @notice Used to receive ERC1155 tokens.
	function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external pure override returns (bytes4){
		return IERC1155Receiver.onERC1155Received.selector;
	}

    /// @notice Used to receive ERC1155 tokens in batches.
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external pure override returns (bytes4){
		return IERC1155Receiver.onERC1155BatchReceived.selector;
	}
}
/** @custom:storiesBeyondStories storiesBeyondStories-xizi
 *
 *林夕晨 （一） 
 * 
 *  注：此番外内容和小说剧情没有太大关系，仅仅只是写一些凌驾于虚幻之上的现实故事而已。 
 *  比如在和现实世界里的那些小说中的角色见面时所发生的一些故事。 
 *  其实也可以算是一个资料记录集。 
 * 就像分卷名写着的那样，这些，全都是在「故事之外的故事」。 
 * ============================================= 
 * 林夕晨是我写的故事里的一个重要角色，她的名字当然不叫林夕晨，所有角色的名字基本都不是真名，顶多就是那些角色们各自使用的女名而已。 
 * 林夕晨的女名也不叫林夕晨，说出来大家也不会熟悉，所以暂时就还是用书中的这个名字就好。 
 * 她的QQ昵称有很多，其中有一个知道的人并不多的就是叫夕子，大概用了一个星期的样子就换掉了吧，只是我也是在那一个时间段和她变得熟悉的，所以后来就用「夕子」来称呼她了。 
 * 在网络上我们大概认识了半年的时间吧，夕子在网络上从未动怒过，脾气好的惊人，有时候我也会口无遮拦地说一些不合时宜的话，但她却总是保持着足够的涵养和温柔。 
 * 而且很多时候不是强忍着怒火不发出来，而是由内到外的就没有因此而生气，我想，或许她的心真的是很温柔的吧。 
 * 其实她很少说话，见面时也多是在群里，聊天时都总是蹦几个字，话不多，但并不显得冷，这是一种很奇怪的感觉。 
 * 她是我的一个读者，早在我妻之前就已经进入了我的读者群了，但是我熟悉她的时候，却是写我妻已经到了中后期的时候了，因为她很少说话，自然就没有什么存在感嘛。 
 * 夕子在现实里也是一个药娘，不对，更准确的说，她应该是一个已经完成了手术的变性人，在身份证上的性别清清楚楚地写着‘女’这个字。 
 * 刚开始的时候我是将信将疑的，但是有不少我认识的药娘朋友都证实了一点，我也渐渐相信了。 
 * 在网络上对一个人的了解是有限的，再加上夕子特别的低调，在圈子里可以说几乎没有任何名气，除了少数几个人以外，认识她的，可能都寥寥无几。 
 * 大家都对她不算熟悉，或许我是她后来那一段时间里，最聊得来的朋友吧。   我从其他认识她的人那里，得到一些传闻，据说夕子被包养过，一直到现在都不知道是不是还在被包养着，而且她做的手术并不是最好的手术，而是比较勉强的那一种，或者说是最低价格，最低规格的手术吧。 
 * 手术是在国内的一个医院里进行的，但并不成功，这个是夕子自己告诉我的。   因为做的手术不太成功，所以在做完之后总会有各种各样的问题，比如说模具变形，开口处理不当导致肉重新长在一起——对于身体而言，那个被且开的口子，就像是伤口一样的，必须用各种方法来阻止愈合，才能形成一个稳定的不会变形的女**官。 
 * 那个时间大概要半年或者一年吧，夕子就是在这个不稳定的期间内，发生了很多问题。 
 * 发炎、流脓，之类的事情发生过许多次了，又因为手术的私密性，所以连伸张都不敢，只能私下里处理，这种事情真的很麻烦，钱花出去了，却无法把根源给看好。 
 * 有一段时间她说她甚至憋不住尿，反正也是手术的问题，好在后来这个问题被解决了，好像是使用材料的问题又或者是别的什么，反正我是记得不太清楚了。   很多人以为变性手术结束后就是美好生活的开始，可是夕子告诉了很多人，那可能是更痛苦的根源。 
 * 下身做手术的这段期间总是有各种问题，完全无法使用，甚至清理不干净还会有臭味——制作yin道的是小肠，优点是润滑，缺点是会长毛和发臭。 
 * 有些人使用的是YingJing皮，那个倒是不会发臭，但是不会自动分泌液体来润滑。   总之是各有优点吧，当然夕子不用后者来制作，是因为早早地去势后，失去了那两个器官，导致此处的皮萎缩了，长度不够……   具体的细节也不是很了解，这些仅仅只是从只言片语中整理出来的而已。 
 * 说起来，夕子诉苦的感觉也是很微妙的，不像别人那样打开了话匣子大倒苦水，而且总是表现的情绪很激烈。 
 * 虽然只是文字的聊天，但总能感受到她的温和，即使是这些头疼苦恼，让人发狂的事情，她也能乐观的去承受，也从来不会把悲惨的事情转变为怒火迁怒到其他人，更不会去自残。 
 * 反正我是从来没有听她说过什么要自残的话。 
 * 在那一段较为活跃的时间，夕子是几乎没有什么收入来源的，她的收入基本的依靠做淘宝客服得来，收入相当的低。 
 * 原来包养她的人，也随着她的手术带来的后遗症迟迟没有处理完而失去了耐心，将她甩开了。 
 * 原本被包养的时候，夕子一个月大概能拿到五千到一万不等的「零花钱」，而后来那一段时间，只能依靠当淘宝客服那微薄的工资来生活，到底有多少呢？   大概也就是1500块钱左右吧，可以说是少的可怜，但没办法，这已经是最适合她的工作了。 
 * 想想那一段时间，即使她还有存款，但是一边要生活，一边还要看病，解决手术的后遗症，就能知道，她过的到底是有多么辛苦了。 
 * 和夕子见面，其实是很偶然的一次，她来到了我所在的城市——准确的说应该是路过。 
 * 或许是在一个地方憋久了想四处走走，又或者从哪里拿到了一笔包养她的钱，总之她坐火车去四处旅行，范围不大，就是在沿海这一带的城市之间而已。 
 * 哦对了，题外话，关于包养的这件事情，可怜固然是可怜，但有时候也感觉这是自找的，明明她在大学毕业之后可以找一份工作的，但为了尽快筹集手术的钱就去找人包养她，当包养的习惯了，钱在不用工作的情况下获得的时间久了以后，一个人就几乎失去了工作能力了，这大概才是夕子找不好工作的原因吧，因为她可能……什么都不会。 
 * 或许‘什么都不会’，有些太绝对了，但大致就是这个意思。 
 * 那次她路过我所在的城市，要看一看这边的有名的景区，就问我，要不要见面。 
 * 既然来了，那我也自然不会推脱，当了一次导游，只是出发的匆忙，衣服也没怎么挑选，就是随便穿了平时的便服，相当邋遢的就过去了。 
 * 其实在我们俩见面了以后，风景是什么并不是重要的事情了，重点都被放在了聊天上。 
 * 初次见面，和我想的有些意外，夕子她竟然和网络里一样温柔——仅从外表上来看的话。 
 * 她的胸部不像是小说里写的那么大，但也不算小了，目测应该都有 B+或者 C 的等级吧。 
 * 夕子说，这是隆出来的胸，也就是里面填满了硅胶的产物。 
 * 虽然知道那是假的，但看着那白皙柔嫩的**，还是很有吸引力的，最起码一旁路过的男人，哪怕是老大爷，都会朝她看上一眼。 
 * 她看起来就是个女人，几乎可以说是毫无破绽，但据她自己说，她的缺点就是她的身高稍微高了一些。 
 * 夕子的身高大概是173的样子，比我要高一点。 
 * 但是现代社会，高挑的女性越来越多，所以这个完全不算缺点，甚至可以算是优点，我倒是觉得，她的唯一破绽是盆骨还是不够宽。 
 * 大概正是因为夕子的这种残念，所以我在设定小说的时候，把她的身高设定在了160，这是她心目中最理想的身高了。 
 * 夕子的声音略有些沙哑，她并没有做很完善的声带手术，只是单纯的把喉结给切除了而已。 
 * 如果不用伪声的话，实际上还是男声，只是较为中性一点而已。 
 * 她说的话不多，有各方面的原因，最重要的一点是，喉结手术也做的不是很好……   简单的说，就是耐久度下降了，她说的话多了，就会喉咙疼，甚至变得嘶哑，更何况是用很伤喉咙的伪声来说话呢。 
 * 她见到我的时候还有些害羞，但还是搭住了我的肩膀，就像是好哥们那样的勾肩搭背的感觉吧，只是她做这个动作要收敛得多，也要显得温柔的多。 
 * 夕子扎着双马尾，不是假发，而是真发，摸起来的手感并不算很好，微微有一些粗糙，可能是营养不良的缘故吧。 
 * 她没有做整形手术，因为她的钱只够她做那些最必要的手术，而且用的药物全是国产的……   当然不是支持国产，还是那句话，没钱。 
 * 在药娘的群体里来说，她绝对是那种天赋党，不然也不会有人包养她了，一个月五千到一万的零花钱不多，可也不算少了，要知道那可是白养啊，而且那些钱只是零花钱。 
 * 除了那些外，还有什么食宿费、各种礼物，全都是不要钱的呢。 
 * 夕子也很直白地说，被包养的时候，出去撒撒娇，就有很大的几率买到自己想要的东西，只要那东西不是贵得离谱就行。 
 * 比如那个时候刚出来的苹果手机，苹果电脑，也都是夕子在撒娇后，包养她的人毫不犹豫地买下来的。 
 * 虽然她说的有些话，都很直白，甚至很阴暗，但因为她总是带着那种温柔的笑，所以并不让人觉得讨厌，反而会让人觉得她很真实。 
 *  
 * 林夕晨 （二） 
 * 
 * 午餐选在了一个西餐厅里。 
 * 当然不是景区附近，作为一个……抠……嗯……节俭的人，怎么可能做那么浪费的事情呢。 
 * 景区附近量少质量也不好，而且还贵。 
 * 所以选择的是在我家附近的一家西餐厅里，这里人少，安静，有一种优雅的气氛，最重要的……便宜实惠。 
 * 吃了什么早已记不清了，反正一共是两百块不到的样子，对于西餐厅而言，这个价格并不算高了，而且吃的东西还是蛮多的。 
 * 西餐厅里，我和夕子选的是二楼靠窗的位置，可以看到楼下熙熙攘攘的行人和来往的车辆。 
 * 夕子切牛排的时候很熟练也很优雅，显然是经常吃的，相比之下我就显得笨拙了，最后无奈之下直接用嘴啃，还好没什么人，不然肯定很多人会投来异样的目光。 
 * “你讨厌被包养的我吗。”夕子冷不丁地问。 
 * 我愣了愣，回答她说，每个人都有每个人的苦衷。 
 * 实际上并没有正面回答这个问题，但她聪明的没有选择继续追问。 
 * 对于这种事情，我不支持也不反对，毕竟我不是夕子，不在那种环境下，是不可能判断对方所做所为是正确还是错误的。 
 * 有时候，这么做可能真的是出于无奈吧，最起码夕子她说，是不喜欢被包养的。 
 * 钱可以和很多东西进行取舍，而最终得到的结果，往往是舍弃别的，选择那足够多的金钱。 
 * 这是这个世间最浅显的道理，在各方各面中都会体现出来。 
 * 夕子也算是半个宅，毕竟被包养的那些日子，基本不外出，全都是窝在家里玩着电脑，所以在现实中也是有着不少共同语言的。 
 * 在度过刚开始的尴尬时期，就变得熟络了起来，毕竟在网络的世界里，我们俩可算是熟人呢。 
 * 见网友是一件很微妙的事情，哪怕是之前再三告诫自己，都会因为对方的形象是否符合自己内心的想法而感到失望或者满意……   夕子虽然和我想象中的有些不太一样，但大体的感觉是差不多的。 
 * 聊天的具体内容不太记得了，反正没有什么有营养的东西，都是在聊些动漫罢了。 
 * 而接下来的事情再一次让我见到了她的温柔以及……软弱。 
 * 她说要去超市里买些东西，然后继续去旅行。 
 * 因为超市不远，所以我们选择了步行，一路走过去，夕子也正好可以感受一下不同城市的风土人情嘛，所以她也没有拒绝。 
 * “好累。”她把一只手搭在我的肩膀上，然后单靠一只脚站在地上，用我的身体来保持平衡，一边隔着鞋子揉着脚，一边说道。 
 * 我对于这样是否能够减缓脚部的酸麻深表怀疑，但她看起来好像觉得有所缓解了的样子。 
 * 或许是因为是在冬天，脱了鞋子会很冷，所以才这么做的吧。 
 * 在去的路上，偶遇了一条流浪的土狗，短毛土狗看起来不算脏，但也绝对不算干净，它是黄色和白色相间的，真要形容的话，应该说是有点像秋田犬。 
 * 实际上在农村里这种狗是很常见的。 
 * 她好像很喜欢小动物，即使这是一只流浪狗，在后者表示出友好，并且主动靠近的时候，她很开心地蹲下身子，侧着脑袋，缓缓地摸着土狗身上粗糙的毛发。   流浪狗对她产生了信任感，以至于夕子站起来了，它还是在后面锲而不舍地跟着。 
 * 夕子看它还跟着，就又蹲下身摸它，然后再站起来继续走，见它还跟着，就再一次抚摸它的身子……   如此循环反复，以至于原本并不长的路，走了半个多小时。 
 * 然后她在便利店里买了三根烤肠——我和她一人一根，而额外的那一根，则送给了那只流浪狗。 
 * 她的眼神在那一刻格外的温柔。 
 * 能让人感觉到她内在善良美好的品质。但就算是这样善良美好的人，在经历过社会的黑暗之后，也总会说出一些……   怎么说呢，应该说是一些很负能量的话吧。 
 * 但说的往往都是事实，让人无力反驳呢。 
 * 在超市里的时候，有一个熊孩子逃脱了父母的‘追捕’，绕着林夕晨转圈圈，拉扯着她的衣服，甚至把她的棉制裙子都给拉歪了。 
 * 但夕子一直都没有生气，甚至连一点恼火的感觉都没有，也没有觉得无奈，反而是有一些好奇，甚至有一些羡慕。 
 * 她带着微笑看着那个调皮的熊孩子在自己的身前窜来窜去，一直到他的父母来拉走了他，我们才离开。 
 * “我喜欢小孩子。”夕子她笑着对我说，然后那温柔中带着沙哑的嗓音变得有些失落，“可惜……我不能……”   现实里的夕子不像小说里那样，她是一个非自然的女性，自然也就无法生育。   我其实不太能理解这一点，因为我个人是很讨厌熊孩子的，大概是因为无法忍受那些低情商的家伙吧。 
 * 虽然他们的低情商是年龄的缘故……   可能这和我较真的性格也有关系。 
 * “没关系，以后也可以领养的嘛。”我安慰道。 
 * “嗯，是呀。”夕子脸上的笑容多了起来，“我以后，想要领养一个女孩子。” 
 * “嗯，那很好啊。”   夕子说这话的时候，除了向往外，还有迷茫和惆怅，或许她是在想，自己到底能不能有领养孩子的那一天吧。 
 * 要知道，领养一个孩子，是需要多重手续的，最基本的条件，就是有一个稳定的收入来源，那个收入来源的钱足够的多，就算达不到小康水平，也得要接近才行。 
 * 而夕子她自己，都还是依靠着包养的钱来生活的呢……   超市里的购物车必须得塞入一枚一元硬币才可以借走，这么做是为了让人们主动把购物车给放好——只有把购物车放回到指定地点，才可以把那一元硬币重新取出来。 
 * 刚进超市，也只是随便地逛逛，没有什么想买的，购物车自然也是空荡荡的。   看商品的时候，把购物车放在了一旁，然后往里面走了一点，去看商品，结果回过头来的时候，却发现我们自己的购物车被一个老头给拉走了。 
 * 这里的称呼比较粗俗，但对于这种为老不尊的老人，我觉得在前面加个‘死’ 字，或许才更符合我当时的心情。 
 * 我正想上前质问，但夕子却比我还快地走上了前，她很有礼貌的对那个死老头说：“您好……这辆购物车是我们的，您是不是推错了？” 
 * “怎么就是你的了，这是我自己从外面推进来的。” 
 * “可是，这辆车……真的是我们的……我们刚才就放在这里……车身的一个轮子是破的……我记得……” 
 * “什么破的不破的，现在的年轻人，难道连一块钱的便宜都想占吗！还要不要脸了，有没有素质啊！”   那个老头破口大骂，他后面还说了些什么，终归是一些不好听的话，我不太记得了。 
 * 只记得，夕子在当时表现的很委屈，甚至带着些哭腔说：“对、对不起……” 明明不是她的错，为什么要说对不起？   我上前大声地呵斥了这个老头一顿，对于这种为老不尊的人，只有表现的比他更强势，他才会害怕。 
 * 车子要了回来，但是好心情却被他给破坏干净了。 
 * 我回过头去看的时候，发现夕子正在流泪，两滴泪水从眼角里流了出来，眼眶里还有更多，只是她在强忍着。 
 * “怎么了？”看着她哭的样子，我有些心疼。 
 * 应该说，是个正常人都会觉得心疼吧。 
 * “没事……” 
 * “和那种人不值得生气。”我劝慰道。 
 * 但是从她的眼中看不到生气的情绪，有的只是委屈而已。 
 * 她好像真的不会生气一样，该说她的脾气太好，太温柔了，还是说她实在是太软弱了呢？   走到如今，和她的性格肯定脱不开关系。 
 * 晚上她没有离开这座城市，而是选择在这里过夜。 
 * 住的是我帮她安排的宾馆，不，说是旅馆可能更合适一些，因为我问过她，她说自己手里的钱也不是很多，所以尽量帮她找了一家便宜的地方。 
 * 住一个晚上只要七十块钱。 
 * 在这个大城市里，这个价格已经很低了。 
 * 当然，环境也好不到哪里去。 
 * 晚上的时候，她问我，能不能陪她一起睡……   她觉得寂寞，希望我能再陪她一会儿，因为明天她就要离开了。 
 * 车票是在吃午饭的时候就在网上买好了。 
 * 她那楚楚可怜的样子实在是让人不忍心拒绝，所以我在她的邀请下进入了她的被窝里。 
 * 当然了，虽然床很小，我也还是什么也没做，甚至连触碰她的身体的动作都尽量避免。 
 * 夕子的身上有一股淡淡的香味，像是兰花的香，她说这是香水的味道，是一种不算便宜的香水。 
 * 我陪她聊到了很晚，大概是晚上十二点左右吧，她的回应越来越轻，然后就在这月光的笼罩下睡着了。 
 * 我起身帮她拉上了窗帘，然后穿好衣服悄悄离开了，终究还是没有在这里陪她过夜。 
 * 第二天早上，她发消息问我去哪里了，我就装作是出去买早饭了——那个旅馆离我家很近，我可以很完美的伪装成昨天陪了她一整个晚上。 
 * 她没有察觉，或许是察觉了，但没有说出来吧。 
 * 在中午的时候，我在火车站里和她道别了。 
 * 之后的联系开始变得断断续续起来，或许是因为她正在旅行的缘故。 
 * 生活中总是有很多事情，我对于这种断断续续的联系并不在意。 
 * 但是有一天，我突然就联系不上她了，无论是 QQ 还是手机都无法联系到她，甚至包括她的那些好友，都和她失去了联系。 
 * 她就像是失踪了一样，在这个世界上消失了。 
 * 直到现在。 
 * 我都没有再联系到过她。 
 * 不知道她过的怎么样，甚至不知道她是否还活着。作为她的朋友，我偶尔还会想起她来，只是不知道随着时间的推移，会不会将她忘记，最起码，现在她在我脑海里的记忆已经很淡了。 
 * 一个心里装了美好和善良，温柔又软弱，很少去抱怨世界的不好的人……   虽然只是见了一次，但却给我留下了深刻的印象。 
 * 把她的故事简单的写在这里，或许也是为了在我以后的记忆更模糊的时候，能回过头看看，想起当初她的模样吧。 
 * 我很喜欢温柔的夕子，但我知道那不是爱情，充其量只是友情和同情的混合体吧。 
 * 嗯……说了很多。 
 * 总之，这就是夕子的故事了。 
 * 现实和小说总是有着很多的不同的，小说来源于现实，也高于现实，却永远不可能像现实那样绝对的真实。 
 * 这就是在，故事之外的……故事。 
 **/
/*=======================================================================================================================
#            __                                 __                               __                                     #
#           /  \ |  o     _  ._ _  o     _.    /  \  _  _  | _|_  _ |  _.       /  \    o _  o                          #
#          | (|/ |< | \/ (_) | | | | \/ (_|   | (|/ _> (_) |  |_ (_ | (_| \/   | (|/ >< | /_ |                          #
#           \__       /              /         \__                        /     \__                                     #
#            __                                  __                                    __                               #
#           /  \  _             _. o ._   _     /  \  _|                    _. ._     /  \  _ o  _  _.  _|  _.          #
#          | (|/ _> |_| \/ |_| (_| | | | (_|   | (|/ (_| |_| \/ |_| >< |_| (_| | |   | (|/ (_ | (_ (_| (_| (_|          #
#           \__         /        |        _|    \__          /                        \__                               #
#            __                             __                    __              __                                    #
#           /  \ o o  _. ._          _     /  \     ._ _   _     /  \     | o    /  \ |_   _. ._    |   _.              #
#          | (|/ | | (_| | | \/ |_| (/_   | (|/ |_| | | | (_)   | (|/ |_| | |   | (|/ | | (_| | |_| |< (_|              #
#           \__ _|           /             \__                   \__             \__                                    #
#                                                                                                                       #
/*======================================================================================================================*
#                                                                                                                       #
#     ██████╗ ███████╗███████╗████████╗██╗███╗   ██╗██╗   ██╗████████╗███████╗███╗   ███╗██████╗ ██╗     ███████╗       #
#     ██╔══██╗██╔════╝██╔════╝╚══██╔══╝██║████╗  ██║╚██╗ ██╔╝╚══██╔══╝██╔════╝████╗ ████║██╔══██╗██║     ██╔════╝       #
#     ██║  ██║█████╗  ███████╗   ██║   ██║██╔██╗ ██║ ╚████╔╝    ██║   █████╗  ██╔████╔██║██████╔╝██║     █████╗         #
#     ██║  ██║██╔══╝  ╚════██║   ██║   ██║██║╚██╗██║  ╚██╔╝     ██║   ██╔══╝  ██║╚██╔╝██║██╔═══╝ ██║     ██╔══╝         #
#     ██████╔╝███████╗███████║   ██║   ██║██║ ╚████║   ██║      ██║   ███████╗██║ ╚═╝ ██║██║     ███████╗███████╗       #
#     ╚═════╝ ╚══════╝╚══════╝   ╚═╝   ╚═╝╚═╝  ╚═══╝   ╚═╝      ╚═╝   ╚══════╝╚═╝     ╚═╝╚═╝     ╚══════╝╚══════╝       #
#                                                                                                                       #
*=======================================================================================================================*
#                                                           ..                                                          #
#                                                           ::                                                          #
#                                                           !!                                                          #
#                                                          .77.                                                         #
#                                                          ~77~                                                         #
#                                                         .7777.                                                        #
#                                                         !7777!                                                        #
#                                                        ^777777^                                                       #
#                                                       ^77777777^                                                      #
#                                                      ^777!~~!777^                                                     #
#                                                     ^7777!::!7777^                                                    #
#                                                   .~77777!  !77777~.                                                  #
#                                                  :!77777!:  :!77777!:                                                 #
#                                                 ~777777!^    ^!777777~                                                #
#                                               :!7777777^      ^7777777!:                                              #
#                                             :!77777777:        :77777777!:                                            #
#                                           :!77777777!.          .!77777777!:                                          #
#                                        .^!77777777!^              ^!77777777!^.                                       #
#                                      :~7777777777^.       ..       .^7777777777~:                                     #
#                                   .^!777777777!^.         ^^         .^!777777777!^.                                  #
#                               .:~!777777777!~:           :77:           :~!777777777!~:.                              #
#                           .:^!7777777777!~:             ^7777^             :~!7777777777!^:.                          #
#                     ..:^~!77777777!!~^:.             .^!777777!^.             .:^~!!77777777!~^:..                    #
#           ...::^^~!!77777777~~^^:..              .:^!777777777777!^:.              ..:^^~~77777777!!~^^::...          #
#           ...::^^~!!77777777~~^^:..              .:^!777777777777!^:.              ..:^^~~77777777!!~^^::...          #
#                     ..:^~!77777777!!~^:.             .^!777777!^.             .:^~!!77777777!~^:..                    #
#                           .:^!7777777777!~:             ^7777^             :~!7777777777!^:.                          #
#                               .:~!777777777!~:           :77:           :~!777777777!~:.                              #
#                                   .^!777777777!^.         ^^         .^!777777777!^.                                  #
#                                      :~7777777777^.       ..       .^7777777777~:                                     #
#                                        .^!77777777!^              ^!77777777!^.                                       #
#                                           :!77777777!.          .!77777777!:                                          #
#                                             :!77777777:        :77777777!:                                            #
#                                               :!7777777^      ^7777777!:                                              #
#                                                 ~777777!^    ^!777777~                                                #
#                                                  :!77777!:  :!77777!:                                                 #
#                                                   .~77777!  !77777~.                                                  #
#                                                     ^7777!::!7777^                                                    #
#                                                      ^777!~~!777^                                                     #
#                                                       ^77777777^                                                      #
#                                                        ^777777^                                                       #
#                                                         !7777!                                                        #
#                                                         .7777.                                                        #
#                                                          ~77~                                                         #
#                                                          .77.                                                         #
#                                                           !!                                                          #
#                                                           ::                                                          #
#                                                           ..                                                          #
#                                                                                                                       #
========================================================================================================================*/